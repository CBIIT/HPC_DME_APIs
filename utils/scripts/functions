#!/usr/bin/env bash
# functions
# @author: George Zaki 
# 
# Copyright Leidos Biomedical Research, Inc
# 
# Distributed under the OSI-approved BSD 3-Clause License.
# See http://ncip.github.com/HPC/LICENSE.txt for details.
#
# Common functions to access the API.

source $HPC_DM_UTILS/scripts/utilities

#Generate a DM API authentication token
#Arguments: [password]
function dm_generate_token () {

    local LOG_FILE=$HPC_DM_UTILS/temp/log
    local CONFIG_PATH=$HPC_DM_UTILS/tokens/curl-conf
    rm -f $LOG_FILE 2>/dev/null

    SERVER=$(get_server) || exit 1
    USERNAME=$(get_username) || exit 1

    if [ -z "$1" ]
    then
      curl -k -u $USERNAME  ${SERVER}/authenticate >  $LOG_FILE
    else
      account_password="$1"
      curl -k -u $USERNAME:$account_password  ${SERVER}/authenticate >  $LOG_FILE
    fi

    local TOKEN=$(get_json_value $LOG_FILE token)

    if [ -z $TOKEN ]
    then
        echo "ERROR: no token found in $LOG_FILE " >&2
        MESSAGE=$(get_json_value $LOG_FILE message)
        echo "ERROR MESSAGE: $MESSAGE"   
        return
    else  
      local TOKEN_FILE=$(get_value $HPC_DM_UTILS/hpcdme.properties hpc.login.token)
      local FORMATED_PATH=$(echo $TOKEN_FILE | sed 's/\\/\//g')
      echo $TOKEN > $HPC_DM_UTILS/${FORMATED_PATH}
      local CONFIG_STRING=$(cat "$CONFIG_PATH-sample" | sed "s@Bearer.*@Bearer $TOKEN\"@")
      echo "$CONFIG_STRING" > $CONFIG_PATH
      rm -f $LOG_FILE 2>/dev/null
    fi
}

#Generate a Globus authentication token
function dm_globus_generate_token {

    local LOG_FILE=$HPC_DM_UTILS/temp/globus-log
    local CONFIG_PATH=$HPC_DM_UTILS/tokens/curl-globus
    rm -f $LOG_FILE 2>/dev/null

    SERVER=$(get_globus_server) || exit 1
    GLOBUS_USER=$(get_globus_user) || exit 1
    
    curl -u $GLOBUS_USER ${SERVER}/goauth/token?grant_type=client_credentials -s  >  $LOG_FILE || exit 1
    local TOKEN=$(get_json_value $LOG_FILE access_token)

    if [ -z $TOKEN ]
    then
        echo "ERROR: no globus token found in $LOG_FILE " >&2
        local MESSAGE=$(get_json_value $LOG_FILE message)
        echo "ERROR MESSAGE: $MESSAGE"   
        exit 1 
    else  
      local TOKEN_FILE=$(get_value $HPC_DM_UTILS/hpcdme.properties hpc.globus.login.token)
      local FORMATED_PATH=$(echo $TOKEN_FILE | sed 's/\\/\//g')
      echo ${GLOBUS_USER}:${TOKEN} > $HPC_DM_UTILS/${FORMATED_PATH}
      local CONFIG_STRING=$(cat "$CONFIG_PATH-sample" | sed "s@Bearer.*@Bearer $TOKEN\"@")
      echo "$CONFIG_STRING" > $CONFIG_PATH
      rm -f $LOG_FILE 2>/dev/null
    fi
}




#Register a collection or a dataObject 
#Inputs:  <description.json>: The metadata json file 
#         <destinaton-path>: The logical path of the destination
#         <type>: dataObjet or collection 
#         [data-object-file] : For synchronous dataObject registration only
function dm_register () {

    local USAGE="USAGE: dm_register <description.json> <destination-path> <colleciton|dataObject> [data-object-file]"

    if [ -z "$1" ] || [ -z "$2" ] || [ -z "$3" ]
    then
        echo "ERROR: using dm_register" >&2
        echo "Received: $@" >&2
        echo "$USAGE" >&2
        return 1
    fi


    if [ ! -z "$4" ]
    then
        local DATAOBJECT_FILE="$4"
        if [ ! -e "$DATAOBJECT_FILE" ]
        then 
            echo "ERROR: The data-object-file:$DATAOBJECT_FILE does not exist " >&2
            return 1
        fi
    fi

        
    local DESCRIPTION="$1"
    local DESTINATION_PATH="$2"
    local TYPE="$3"

    USERID=$(get_username) || exit 1
    SERVER=$(get_server) || exit 1
    CONFIG=$(get_config) || exit 1

    if [ ! -e "$DESCRIPTION" ]
    then
      echo "ERROR: Can not access the \"$DESCRIPTION\" file" >&2
      exit 1
    fi
    
    local RESPONSE_MSG=${TYPE}-registration-response-message.json.tmp
    local RESPONSE_HEADER=${TYPE}-registration-response-header.tmp

    rm -f  $RESPONSE_MSG 2>/dev/null 
    rm -f $RESPONSE_HEADER 2>/dev/null 

    local CURL_FLAGS="-X PUT ${SERVER}/${TYPE}/${DESTINATION_PATH}  $CONFIG  -D $RESPONSE_HEADER -o $RESPONSE_MSG "
    
    if [ "$TYPE" == "dataObject" ]
    then
        if [ -z "$DATAOBJECT_FILE" ]
        then
            curl -F "dataObjectRegistration=@$DESCRIPTION;type=application/json" $CURL_FLAGS -H "Accept: application/json"  2> $HPC_DM_UTILS/temp/curl-status
        else
            curl -F "dataObjectRegistration=@$DESCRIPTION;type=application/json" -F "dataObject=@$DATAOBJECT_FILE;type=application/octet-stream" $CURL_FLAGS  -H "Accept: application/json"  2> $HPC_DM_UTILS/temp/curl-status 
        fi
    elif [ "$TYPE" == "collection" ]
    then
            
           curl -H "Content-Type: application/json" -d @$DESCRIPTION $CURL_FLAGS  -H "Accept: application/json" 2>$HPC_DM_UTILS/temp/curl-status
    else
        echo "ERROR: Unsupported registration type:$TYPE"
        exit 1
    fi

    check_connection $RESPONSE_HEADER
}

#Register a collection 
#Inputs:  <description.json>: The metadata json file for the collection 
#         <destinaton-path>: The destination logical path
function dm_register_collection {

    local USAGE="USAGE: dm_register_collection <description.json> <destination-path>"

    if [ -z "$1" ] || [ -z "$2" ] 
    then
        echo "ERROR: using dm_register_collection" >&2
        echo "Received: $@" >&2
        echo "$USAGE" >&2
        return
    fi

    local DESCRIPTION="$1"
    local DESTINATION_PATH="$2"

    dm_register $DESCRIPTION $DESTINATION_PATH collection || exit 1

    local RESPONSE_HEADER=collection-registration-response-header.tmp
    local RESPONSE_MSG=collection-registration-response-message.json.tmp

    verify_registration "$RESPONSE_HEADER" "$RESPONSE_MSG" "$DESTINATION_PATH"

}

#Register a dataObject using presigned S3 URL
#Inputs:  <description.json>: The metadata json file for the dataObject 
#         <destinaton-path>: The destination logical path
#         <source-file>: The source file for synchronous registratio.
function dm_register_dataobject_presigned {

    local USAGE="USAGE: dm_register_dataobject <description.json> <destination-path> <source-file>"

    if [ "$#" -lt 3 ]
    then
        echo "ERROR: using dm_register_dataobject_presigned" >&2
        echo "Received: $@" >&2
        echo "$USAGE" >&2
        return
    fi

    local description="$1"
    local destination_path="$2"
    local source_file="$3"
    dm_register "$description" "$destination_path" dataObject 
    if [ "$?" -eq  1 ]
    then
      return 1
    fi

    local response_header=dataObject-registration-response-header.tmp
    local response_msg=dataObject-registration-response-message.json.tmp

    #verify_registration "$RESPONSE_HEADER" "$RESPONSE_MSG" "$DESTINATION_PATH"
    presigned_url=`get_json_value $response_msg uploadRequestURL`
    if [ -z "$presigned_url" ]
    then
      echo "ERROR: Can not retrieve the presigned url from $response_msg" >&2
      return 1
    fi

    rm $response_header $response_msg
    response_header=presignedURL-registration-response-header.tmp
    response_msg=presignedURL-registration-response-message.tmp
    curl -i -X PUT -F 'Content-Type=application/octet-stream' -F "file=@${source_file}" "${presigned_url}" -D $response_header -o $response_msg -s
    if [ "$?" -ne 0 ]
    then
      echo "ERROR during presigned URL registration" >&2
      echo "Check the files $response_header and $response_msg" >&2
      return 1
    fi

    rm $response_header $response_msg
}



#Register a dataObject 
#Inputs:  <description.json>: The metadata json file for the dataObject 
#         <destinaton-path>: The destination logical path
#         [source-file]: The source file for synchronous registratio.
function dm_register_dataobject {

    local USAGE="USAGE: dm_register_dataobject <description.json> <destination-path> [source-file]"

    if [ -z "$1" ] || [ -z "$2" ] 
    then
        echo "ERROR: using dm_register_collection" >&2
        echo "Received: $@" >&2
        echo "$USAGE" >&2
        return
    fi

    local DESCRIPTION="$1"
    local DESTINATION_PATH="$2"
    local SOURCE_FILE=$3
    dm_register "$DESCRIPTION" "$DESTINATION_PATH" dataObject $SOURCE_FILE 
    if [ "$?" -eq  1 ]
    then
      return 1
    fi

    local RESPONSE_HEADER=dataObject-registration-response-header.tmp
    local RESPONSE_MSG=dataObject-registration-response-message.json.tmp

    verify_registration "$RESPONSE_HEADER" "$RESPONSE_MSG" "$DESTINATION_PATH"
}

#Sync a folder in the current file system with a logical path in the Archive
#There is no metadata for folder and they will be automatically created.
#The files metadata is the list of attributes/values pair that are returned by the 
#function "get_json-file"
#Inputs: Globus endpoint
#        Source path on Globus endpoint
#        Destination logical path on Archive.
#<source-folder>    The source folder on the file system
#        <destination-path> The destination logical path
function dm_sync_globus_endpoint  {

    local USAGE="USAGE: dm_sync_folder <source-folder> <destination-path>"

    if [ -z "$1" ] || [ -z "$2" ] 
    then
        echo "ERROR: using dm_register_collection" >&2
        echo "Received: $@" >&2
        echo "$USAGE" >&2
        return
    fi


    local RESPONSE_HEADER=dataObject-registration-response-header.tmp
    local RESPONSE_MSG=dataObject-registration-response-message.json.tmp


    local FILE_LIST="./test.txt /TEST_Archive/test.txt"

    while read -r  NEW_FILE 
    do 

      local SRC_PATH=$(echo $NEW_FILE | cut -d' ' -f1)
      local DST_PATH=$(echo $NEW_FILE | cut -d' ' -f2)

      local FILE_ATTRIBUTES=$(get_file_attributes $SRC_PATH)      
      local DESC_JSON=$(get_json_description $FILE_ATTRIBUTES)
      echo $DESC_JSON >  temp.json
      echo "dm_register_dataobject  temp.json $DST_PATH $SRC_PATH"
      echo "verify_registration  $REPONSE_HEADER $RESPONSE_MSG $DST_PATH"

      rm -f $RESPONSE_HEADER 2>/dev/null
      rm -f $RESPONSE_MSG 2>/dev/null

    done <<< "$FILE_LIST"

}


#Get an item (collection or dataObject) from the archive
#Inputs: <item-path> (should have a prefix of "dataObject" or "collection")
#      : [metadata-file]
#      : [REST-response]
function dm_get_item {

    local USAGE="dm_get_item  <item-path> [metadata-file] [REST-response]"

    if [ "$#" -lt 1 ] 
    then
        echo "ERROR: using dm_get_item" >&2
        echo "$USAGE" >&2
        return 1
    fi
    local ITEM_PATH="$1"

    local RESPONSE_MSG
    local RESPONSE_HEADER
    if [ ! -z "$2" ]
    then
      RESPONSE_MSG="$2"
    else
      RESPONSE_MSG=get-item-response-message.json.tmp
    fi 

    if [ ! -z "$3" ]
    then
      RESPONSE_HEADER="$3"
    else
      RESPONSE_HEADER=get-item-response-header.tmp
    fi 

    CONFIG=$(get_config) || exit 1
    SERVER=$(get_server) || exit 1

    local TOTAL_PATH="$ITEM_PATH"
    local TOTAL_PATH=$(echo "$TOTAL_PATH" | sed "s#\/\/*#\/#g")
   
    curl -G -X GET "$SERVER/$TOTAL_PATH"  $CONFIG  -D $RESPONSE_HEADER -o $RESPONSE_MSG -s 2> $HPC_DM_UTILS/temp/curl-status 
    check_connection $RESPONSE_HEADER
}


#Get the metadata of a dataobject from the archive
#Inputs: <dataObject-path> 
#      : [metadata-file]
#      : [REST-response]
function dm_get_dataobject {

    local USAGE="dm_get_item_dataobject  <dataobject-path> [metadata-file] [REST-response]"

    if [ "$#" -lt 1 ] 
    then
        echo "ERROR: using get_dataobject" >&2
        echo "recieved $0 $@" 
        echo "$USAGE" >&2
        return
    fi
    local ITEM_PATH="$1"


    local RESPONSE_MSG=${2-get-item-response-message.json.tmp}
    local RESPONSE_HEADER=${3-get-item-response-header.tmp}

    dm_get_item dataObject/$ITEM_PATH  "$RESPONSE_MSG" "$RESPONSE_HEADER" || exit 1

    local RESPONSE_CODE=$(get_http_code $RESPONSE_HEADER)
    if [ "$RESPONSE_CODE" -ne 200 ]
    then
      echo "ERROR getting \"$ITEM_PATH\" " >&2
      #echo "ERROR_CODE:\"$RESPONSE_CODE\"" >&2
      print_error_message "$RESPONSE_MSG" "$RESPONSE_CODE"
      exit 1
    else 
     
      #Check if the user needs the response header file 
      if [ -z "$3" ]
      then 
        rm -f "$RESPONSE_HEADER" 2> /dev/null
      fi

      if [ -z "$2" ]
      then
        print_json_message "$RESPONSE_MSG"    
        rm -f $RESPONSE_MSG 2> /dev/null 
      fi
      exit 0
    fi
}


#Get the metadata of a collection from the archive
#Inputs: <collection-path> 
#      : [metadata-file]
#      : [REST-response]
function dm_get_collection {

    local USAGE="dm_get_collection  <collection-path> [metadata-file] [REST-response]"

    if [ "$#" -lt 1 ] 
    then
        echo "ERROR: using dm_get_collection" >&2
        echo "recieved $0 $@" 
        echo "$USAGE" >&2
        return
    fi
    local ITEM_PATH="$1"

    local RESPONSE_MSG=${2-get-item-response-message.json.tmp}
    local RESPONSE_HEADER=${3-get-item-response-header.tmp}

    dm_get_item collection/$ITEM_PATH  "$RESPONSE_MSG" "$RESPONSE_HEADER" || exit 1

    local RESPONSE_CODE=$(get_http_code $RESPONSE_HEADER)
    if [ "$RESPONSE_CODE" -ne 200 ]
    then
      echo "ERROR getting \"$ITEM_PATH\" " >&2
      print_error_message "$RESPONSE_MSG" "$RESPONSE_CODE"
      exit 1
    else 
     
      #Check if the user needs the response header file 
      if [ -z "$3" ]
      then 
        rm -f "$RESPONSE_HEADER" 2> /dev/null
      fi

      if [ -z "$2" ]
      then
        print_json_message "$RESPONSE_MSG"    
        rm -f $RESPONSE_MSG 2> /dev/null 
      fi
    fi
}




#Download a dataObject synchronously 
#Inputs: logic-path 
#        destination-file
function dm_download_dataobject_sync {


    local USAGE="USAGE:dm_download_dataobject_sync <logic-path> <destination-file>"

    if [ "$#" -lt 2 ] 
    then
        echo "ERROR: using dm_downlaod_dataobject_sync" >&2
        echo "recieved $@" 
        echo "$USAGE" >&2
        return 1
    fi

    local RESPONSE_HEADER=download-dataobject-response-header.tmp

   
    local OBJECT_PATH="$1"
    local DESTINATION_PATH="$2"

    if [ -d "$DESTINATION_PATH"  ]
    then
      
        #Download the file with the same file name 
        local FILE_NAME=$(basename "$OBJECT_PATH")
        if [ "$?" -ne 0 ]
        then
          echo "ERROR:Can not retrieve the file name from \"$OBJECT_PATH\"" >&2
          return 1
        fi

        local DESTINATION_PATH=$DESTINATION_PATH/${FILE_NAME}
    fi


    local SERVER=$(get_server)
    
    local CONFIG=$(get_config)

    local TEMPLATE="$HPC_DM_UTILS/templates/download-sync-template.json"

    curl -H "Content-Type: application/json" -d @$TEMPLATE -X POST ${SERVER}/dataObject/$OBJECT_PATH/download  $CONFIG -H "Accept: application/json" -D $RESPONSE_HEADER -o $DESTINATION_PATH -s 2> $HPC_DM_UTILS/temp/curl-status 
    check_connection $RESPONSE_HEADER


    local CODE=$(get_http_code "$RESPONSE_HEADER") 

    if [ "$CODE" -ne 200 ]
    then 
      #In this case the destination path file will contain the error code
      print_error_message "$DESTINATION_PATH" "$CODE" 
    else
      rm -f $RESPONSE_HEADER 2> /dev/null
    fi
}


#Delete a datafile from the archive using the cmd line client.
#Inputs:  <file-path>: The path on the file system 

function dm_delete_datafile {

    local USAGE="USAGE: dm_delete_datafile <file-path>"

    check_java
    if [ "$?" -ne 0 ]
    then 
      return 1
    fi

    if [ -z "$1" ] 
    then
        echo "ERROR using dm_delete_datafile" >&2
        echo "$USAGE" >&2
        exit 1 
    fi
    
    local file_path="$1"
   
    #Check if the jar exists:
    local jar_file=$(get_jar)
    local jar_path=$HPC_DM_UTILS/hpc-client/$jar_file
    if [ ! -f $jar_path ]
    then
      echo "Can not find $jar_path " >&2
      return 1
    fi

    command_args=""

    #Pass the mandatory arguments
    command_args+=" --path \"$file_path\" "
  
    #Generate the command for the client: 
    local command_file=$HPC_DM_UTILS/temp/cmd-file
    echo "deleteDatafile  " $command_args >  $command_file

    case "$(uname -s)" in
    
       Darwin|Linux)
        java -Dhpc.client.properties=$HPC_DM_UTILS/hpcdme.properties -DHPC_DM_UTILS=$HPC_DM_UTILS -jar $jar_path  --cmdfile $command_file
        exit_code="$?"
       ;;
    
       CYGWIN*|MINGW32*|MSYS*)
            java -DHPC_DM_UTILS=$(cygpath -m $HPC_DM_UTILS) -Dhpc.client.properties=$(cygpath -w $HPC_DM_UTILS/hpcdme.properties)  -jar $(cygpath -w $jar_path)  --cmdfile $(cygpath -w $command_file)
        exit_code="$?"
       ;;
    
       *)
         echo 'Current OS not supported' 
         exit 1
         ;;
    esac

    if [ "$exit_code" -eq  "1" ]
    then
      echo "The datafile deletion did not fully complete successfully" >&2
      echo "Check complete log and error files" >&2
      return 1
    fi

}

#Print Usage of dm_register_directory function
function dm_show_delete_collection_usage {
  read -d  '' usage <<- EOF
  Usage: dm_delete_collection [OPTIONS] <collection-path> 

  Delete the collection at the specified path. 
  OPTIONS:
  -r                      Recursive delete. This will delete all the files and sub-collections under the specified collection recursively. 
EOF
  echo "$usage"
}

#Delete a collection from the archive using the cmd line client.
#Inputs:  <source-path>: The path on the file system 

function dm_delete_collection {

    local USAGE="USAGE: dm_delete_collection <collection-path>"
    local OPTIND
    
    #Set the default parameters
    numthreads=1
    recursive=false
  
   while getopts ":rt:" option
    do
      case "${option}" in
       
        r)
	  recursive=true
          ;;
        *)
          echo "ERROR: Unsupported option ${option}" >&2
          dm_show_delete_collection_usage >&2
          exit 1
          ;;
      esac
    done


    shift $(( OPTIND-1 ))   

    check_java
    if [ "$?" -ne 0 ]
    then 
      return 1
    fi

    if [ -z "$1" ] 
    then
        echo "ERROR: using dm_delete_collection" >&2
        usage=$(dm_show_delete_collection_usage)
        echo "$usage" >&2
        exit 1
    fi


    local collection_path="$1"

    #Check if the jar exists:
    local jar_file=$(get_jar)
    local jar_path=$HPC_DM_UTILS/hpc-client/$jar_file
    if [ ! -f $jar_path ]
    then
       echo "Can not find $jar_path " >&2
       return 1
     fi

    command_args=""

    #Pass the mandatory arguments
    command_args+="--path \"$collection_path\" "

    #Pass the optional ones
    command_args+="--recursive $recursive "

    #Generate the command for the client: 
    local command_file=$HPC_DM_UTILS/temp/cmd-file
    echo "deleteCollection  " $command_args >  $command_file

    case "$(uname -s)" in
    
       Darwin|Linux)
        java -Dhpc.client.properties=$HPC_DM_UTILS/hpcdme.properties -DHPC_DM_UTILS=$HPC_DM_UTILS -jar $jar_path  --cmdfile $command_file
        exit_code="$?"
       ;;
    
       CYGWIN*|MINGW32*|MSYS*)
            java -DHPC_DM_UTILS=$(cygpath -m $HPC_DM_UTILS) -Dhpc.client.properties=$(cygpath -w $HPC_DM_UTILS/hpcdme.properties)  -jar $(cygpath -w $jar_path)  --cmdfile $(cygpath -w $command_file)
        exit_code="$?"
       ;;
    
       *)
         echo 'Current OS not supported' 
         exit 1
         ;;
    esac

    if [ "$exit_code" -eq  "1" ]
    then
      echo "The collection deletion did not fully complete successfully" >&2
      echo "Check complete log and error files" >&2
      return 1
    fi
}



#Print Usage of dm_register_directory function
function dm_show_register_directory_usage {
  read -d  '' usage <<- EOF
  Usage: dm_register_directory [OPTIONS]  <source-path> <destination-path> 

  Recursively copy all files in the <source-path> to the archive's <destination-path>. 
  Metadata can be provided for every directory and file in a specific metadata file called <[directory,filename]>.metadata.json. The metadata file should exist in the same path in its corresponding directory/file. For example the metatadata for the file foo.txt should be foo.txt.metadata.json
  OPTIONS:
  -a[ARCHIVE_TYPE]        The type of the archive. Valid options are "S3" and "POSIX".
  -c                      Turn off checksum calculation. 
  -d                      Print the files to be included in registration an exit 
  -e[EXCLUDE_FILE_PATH]   Exclude the files that match the patterns specified in the file EXCLUDE_FILE_PATH
  -i[INCLUDE_FILE_PATH]   Include the files that match at least one of the patterns specified in INCLUDE_FILE_PATH
  -l[FILES_LIST]          Register the files mentioned in the FILE_LIST only. Each line in the FILES_LIST file contains a relative path to the source-path.
                          All collections should be registered before using this option.
  -m                      Register metadata only. Do not register files.
  -s                      Skip confirmation prompt and register directly
  -h                      Print this message 
  -t[NUM_THREADS]         The number of threads to use while uploading files to cleversafe. This number should be between [1, 32].
EOF
  echo "$usage"
}


#Register a directory from a file system using the cmd line client.
#Inputs:  <source-path>: The path on the file system 
#         <destinaton-path>: The destination logical path on the archive
function dm_register_directory {

    local USAGE="USAGE: dm_register_directory <source-path> <destination-path>"
    local OPTIND
    
    #Set the default parameters
    numthreads=1
    archiveType=S3
    checksum=true

    while getopts ":a:b:cde:i:l:hmp:st:" option
    do
      case "${option}" in
        a)
          archiveType="${OPTARG}"
          if [ "$archiveType" != "S3" ] && [ "$archiveType" != "POSIX" ]
          then
            echo "ERROR: the arhive type can be either \"S3\" or \"POSIX\". Recevied:\"$archiveType\"" >&2
            exit 1 
          fi
          ;;
        c)
          checksum=false
          ;;

        d)
          dry_run=1
          echo "Running dry, no registration will take place."
          ;;
        e)
          exclude_option=1
          exclude_file="${OPTARG}"
          if [ ! -e "$exclude_file" ]
          then
            echo "ERROR: The exclude file $exclude_file does not exists" >&2
            exit 1
          fi
          ;;
        i)
          include_option=1
          include_file="${OPTARG}"
          if [ ! -e "$include_file" ]
          then
            echo "ERROR: The include file $include_file does not exists" >&2
            exit 1
          fi
          ;;
        l)
          file_list=1
          list_of_files="${OPTARG}"
          if [ ! -e "$list_of_files" ]
          then
            echo "ERROR: The FILES_LIST $list_of_files does not exists" >&2
            exit 1
          fi
          ;;
        m)
          metadata_only=1
          ;;
        s)
          skip_confirmation=1
          ;;
        h)
          dm_show_register_directory_usage 
          exit 1
          ;;
        t)
          numthreads="${OPTARG}"
          re='^[0-9]+$'
          if ! [[ "$numthreads" =~ $re ]] ; then
             echo "ERROR: The number of threads $numthreads is not a positive integer." >&2; exit 1
          fi

          if [ "$numthreads" -lt "0" ] || [ "$numthreads" -gt "32" ]
          then
             echo "ERROR: The number of threads $numthreads should be between [1, 32]" >&2; exit 1
          fi
          ;;
        *)
          echo "ERROR: Unsoported option ${option}" >&2
          dm_show_register_directory_usage >&2
          exit 1
          ;;
      esac
    done

    shift $(( OPTIND-1 ))   

    check_java
    if [ "$?" -ne 0 ]
    then 
      return 1
    fi
    if [ -z "$1" ] || [ -z "$2" ] 
    then
        echo "ERROR: using dm_register_directory" >&2
        usage=$(dm_show_register_directory_usage)
        echo "$usage" >&2
        exit 1 
    fi

    local src_path="$1"
    local dst_path="$2"

    #Check if the jar exists:
    local jar_file=$(get_jar)
    local jar_path=$HPC_DM_UTILS/hpc-client/$jar_file
    if [ ! -f $jar_path ]
    then
      echo "Can not find $jar_path " >&2
      return 1
    fi

    #Make sure the source directory exists:
    if [ ! -d "$src_path" ]
    then
      echo "The source directory: $src_path does not exist." >&2
      exit 1
    fi 

    command_args=""

    #Pass the mandatory arguments
    full_src_path=$(myreadlink $src_path)
    full_src_path_converted=$(convert_path "$full_src_path")
    command_args+=" --sourceFilePath \"$full_src_path_converted\" "

    command_args+=" --destinationArchivePath \"$dst_path\" "

    #Pass the options related to files that will be registered. 
  
    if [ $file_list ]
    then
      list_of_files_converted=$(convert_path "$list_of_files")
      command_args+=" --sourceFileList \"${list_of_files_converted}\" "
    else
     #Get the include path
      if [ "$include_option" ] 
      then
        full_include_path=$(myfilereadlink "$include_file")
        full_include_path_converted=$(convert_path "$full_include_path")
        command_args+=" --includePatternFile \"${full_include_path_converted}\" "
      fi
  
      #Get the exclude path
      if [ "$exclude_option" ] 
      then
        full_exclude_path=$(myfilereadlink "$exclude_file")
        full_exclude_path_converted=$(convert_path "$full_exclude_path")
        command_args+=" --excludePatternFile \"${full_exclude_path_converted}\" "
      fi
    fi 

    if [ "$dry_run" ]
    then
      command_args+=" --dryRun true"
    fi

    if [ ! "$skip_confirmation" ]
    then
      command_args+=" --confirm true "
    else  
      command_args+=" --confirm false "
    fi

    if [ "$metadata_only" ]
    then
      command_args+=" --metadata true "
    fi

    #Add all other options
    command_args+=" --threads $numthreads"
    command_args+=" --archiveType $archiveType"
    command_args+=" --checksum $checksum"

    #Generate the command for the client: 
    local command_file=$HPC_DM_UTILS/temp/cmd-file
    echo "registerFromFilePath  " $command_args >  $command_file

    local log_file=./dm_log
    local error_file=./dm_error

    case "$(uname -s)" in
    
       Darwin|Linux)
        java -Dhpc.client.properties=$HPC_DM_UTILS/hpcdme.properties -DHPC_DM_UTILS=$HPC_DM_UTILS -jar $jar_path  --cmdfile $command_file
        exit_code="$?"
       ;;
    
       CYGWIN*|MINGW32*|MSYS*)
            java -DHPC_DM_UTILS=$(cygpath -m $HPC_DM_UTILS) -Dhpc.client.properties=$(cygpath -w $HPC_DM_UTILS/hpcdme.properties)  -jar $(cygpath -w $jar_path)  --cmdfile $(cygpath -w $command_file)
        exit_code="$?"
       ;;
    
       # Add here more strings to compare
       # See correspondence table at the bottom of this answer
    
       *)
         echo 'Current OS not supported' 
         exit 1
         ;;
    esac

    if [ "$exit_code" -eq  "1" ]
    then
      echo "The batch registration did not fully complete successfully" >&2
      echo "Check complete log and error files at:" >&2
      echo "$log_file" >&2
      echo "$error_file" >&2
      return 1
    fi

}


#Print Usage of dm_register_globus_directory function
function dm_show_register_globus_directory_usage {
  read -d  '' usage <<- EOF
  Usage: dm_register_globus_directory [OPTIONS]  <source-path> <destination-path> [endpoint]

  Recursively copy all files in the globus <source-path> to the archive's <destination-path>. If endpoint is not passed, the default globus endpoint in hpcdme.properties file will be used.
  OPTIONS:
  -d                      Print the files to be included in registration an exit 
  -e[EXCLUDE_FILE_PATH]   Exclude the files that match the patterns specified in the file EXCLUDE_FILE_PATH
  -i[INCLUDE_FILE_PATH]   Include the files that match at least one of the patterns specified in INCLUDE_FILE_PATH
  -p[PATTERN_TYPE]        The type of the regex pattern in the include/exclude files. Valid options are "Simple" and "RegEx". The default pattern is "Simple"
  -h                      Print this message 
EOF
  echo "$usage"
}




#Register a directory from a globus endpoint using the cmd line client.
#By default the endpoint specified in hpcdme.properties will be used
#Inputs:  <source-path>: The path on the globus endpoint 
#         <destinaton-path>: The destination logical path on the archive
#         [globus-endpoint]: The endpoint to use other that default
function dm_register_globus_directory {

    local OPTIND

    #Set the default parameters
    patternType=Simple

    while getopts ":de:i:hp:t:" option
    do
      case "${option}" in
        d)
          dry_run=1
          echo "Running dry, no registration will take place."
          ;;
        e)
          exclude_option=1
          exclude_file="${OPTARG}"
          if [ ! -e "$exclude_file" ]
          then
            echo "ERROR: The exclude file $exclude_file does not exists" >&2
            exit 1
          fi
          ;;
        i)
          include_option=1
          include_file="${OPTARG}"
          if [ ! -e "$include_file" ]
          then
            echo "ERROR: The include file $include_file does not exists" >&2
            exit 1
          fi
          ;;
        p)
          patternType="${OPTARG}"
          if [ "$patternType" != "Simple" ] && [ "$patternType" != "RegEx" ]
          then
            echo "ERROR: the include/exclude pattern type can be either \"Simple\" or \"RegEx\". Recevied:\"$patternType\"" >&2
            exit 1 
          fi
          ;;
        h)
          dm_show_register_globus_directory_usage 
          exit 1
          ;;
        *)
          echo "ERROR: Unsoported option ${option}" >&2
          dm_show_register_globus_directory_usage >&2
          exit 1
          ;;
      esac
    done

    shift $(( OPTIND-1 ))   

    check_java
    if [ "$?" -ne 0 ]
    then 
      return 1
    fi
    if [ -z "$1" ] || [ -z "$2" ] 
    then
        echo "ERROR: using dm_register_directory" >&2
        usage=$(dm_show_register_globus_directory_usage)
        echo "$usage" >&2
        exit 1 
    fi

    local src_path="$1"
    local dst_path="$2"

    #Check if the jar exists:
    local jar_file=$(get_jar)
    local jar_path=$HPC_DM_UTILS/hpc-client/$jar_file
    if [ ! -f $jar_path ]
    then
      echo "Can not find $jar_path " >&2
      return 1
    fi

    local globus_endpoint
    if [ -z "$3" ]
    then
      #echo "Using the default globus endpoint in $HPC_DM_UTILS/hpcdme.properties" 
      globus_endpoint=$(get_globus_endpoint)
      if [ "$?" -ne 0 ]
      then
        echo  "ERROR: Can not find the default Globus endpoint in the properties file." >&2
        exit 1
      fi
    else
      globus_endpoint="$3"
    fi       

    command_args=""
    #Get the include path
    if [ "$include_option" ]
    then
      full_include_path=$(myfilereadlink "$include_file")
      command_args+=" --includePatternFile \"$full_include_path\""
    fi

    #Get the exclude path
    if [ "$exclude_option" ]
    then
      full_exclude_path=$(myfilereadlink "$exclude_file")
      command_args+=" --excludePatternFile \"$full_exclude_path\""
    fi

    if [ "$dry_run" ]
    then
      command_args+=" --dryRun true"
    fi

    #Add all other options
    command_args+=" --patternType $patternType"

    #Generate the command for the client: 
    local command_file=$HPC_DM_UTILS/temp/cmd-file
    echo "registerFromGlobusPath --globusEndpoint $globus_endpoint --globusSourcePath $src_path --destinationArchivePath $dst_path" $command_args >  $command_file

    local log_file=./dm_log
    local error_file=./dm_error

    
    case "$(uname -s)" in
    
       Darwin)
         echo 'Mac OS X is not currently supported'
         return 1
         ;;
       Linux)
        java -Dhpc.client.properties=$HPC_DM_UTILS/hpcdme.properties -DHPC_DM_UTILS=$HPC_DM_UTILS -jar $jar_path  --cmdfile $command_file
         ;;
       CYGWIN*|MINGW32*|MSYS*)
            java -DHPC_DM_UTILS=$(cygpath -m $HPC_DM_UTILS) -Dhpc.client.properties=$(cygpath -w $HPC_DM_UTILS/hpcdme.properties)  -jar $(cygpath -w $jar_path)  --cmdfile $(cygpath -w $command_file)
        ;;
       # Add here more strings to compare
       # See correspondence table at the bottom of this answer
       *)
         echo 'Current OS not supported' 
         return 1
         ;;
    esac

    if [ "$?" -eq  1 ]
    then
      echo "The batch registration did not fully complete successfully" >&2
      echo "Check complete log and error files at:" >&2
      echo "$log_file" >&2
      echo "$error_file" >&2
      return 1
    fi

}

#Download a collection to Globus 
#Inputs: collection-apth
#        destination-file
function dm_download_collection_async {


    local USAGE="USAGE:dm_download_collection_async <collection-logical-path> <globus-destination-path> [globus-endpoint]"

    if [ "$#" -lt 2 ] 
    then
        echo "ERROR: using dm_download_collection_async" >&2
        echo "recieved $@" 
        echo "$USAGE" >&2
        return 1
    fi

    local src_path="$1"
    local dst_path="$2"

    local globus_endpoint
    if [ -z "$3" ]
    then
      #echo "Using the default globus endpoint in $HPC_DM_UTILS/hpcdme.properties" 
      globus_endpoint=$(get_globus_endpoint)
      if [ "$?" -ne 0 ]
      then
        return 1
      fi
    else
      globus_endpoint="$3"
    fi       

    local template_file=$HPC_DM_UTILS/templates/download-async-template.json
    if [ ! -e "$template_file" ]
    then
        echo "Can not file the template file: $template_file" >&2
        echo "Please pull the latest version and try again" >&2
        return 1
    fi

    #Make sure the template did not change:
    local container="globus-shared-endpoint-uid"
    local destination="destination-name"

    local container_exists=$(grep  $container $template_file) 
    if [ -z "$container_exists" ]
    then
        echo "The template file $template_file changed." >&2
        echo "Please pull the latest version and try again" >&2
        return 1
    fi 

    local destination_exists=$(grep $destination $template_file) 
    if [ -z "$destination_exists" ]
    then
        echo "The template file $template_file changed." >&2
        echo "Please pull the latest version and try again" >&2
        return 1
    fi 

    local request_file=$HPC_DM_UTILS/temp/async-download.json.tmp
     
    #Update the globus endpoint
    updated_endpoint=$(cat $template_file | sed "s@$container@$globus_endpoint@")

    #Update the file name 
    updated_destination=$(echo "$updated_endpoint" | sed "s#${destination}#${dst_path}#")
    echo  "$updated_destination" > $request_file

    local response_hdr=download-dataobject-response-header.tmp
    local response_msg=download-dataobject-response-message.json.tmp

    local SERVER=$(get_server)
    local CONFIG=$(get_config)

    curl -H "Content-Type: application/json" -d @$request_file -X POST ${SERVER}/collection/$src_path/download  $CONFIG -H "Accept: application/json" -D $response_hdr -o $response_msg -s 2> $HPC_DM_UTILS/temp/curl-status 
    check_connection $response_hdr


    local code=$(get_http_code "$response_hdr") 

    if [ "$code" -ne 200 ]
    then 
      #In this case the destination path file will contain the error code
      print_error_message "$reponse_msg" "$code" 
    else
      rm -f $response_hdr 2> /dev/null
    fi
}


#Download to Globus 
#Inputs: <item-path> path on archive
#        <destination-path> path on Globus
function dm_download_async {


    local USAGE="USAGE:dm_download_async <archive-path> <globus-destination-path> [globus-endpoint]"

    if [ "$#" -lt 2 ] 
    then
        echo "ERROR: using dm_download_async" >&2
        echo "recieved $@" 
        echo "$USAGE" >&2
        exit 1
    fi

    local src_path="$1"
    local dst_path="$2"

    if [ -z "$3" ]
    then
      #echo "Using the default globus endpoint in $HPC_DM_UTILS/hpcdme.properties" 
      globus_endpoint=$(get_globus_endpoint) || exit 1
    else
      globus_endpoint="$3"
    fi       

    local template_file=$HPC_DM_UTILS/templates/download-async-template.json
    if [ ! -e "$template_file" ]
    then
        echo "Can not file the template file: $template_file" >&2
        echo "Please pull the latest version and try again" >&2
        exit 1
    fi

    item_type=$(get_type $src_path) || exit 1
    if [ "$item_type" == "" ]
    then
        echo "ERROR: Can not find the item $src_path in the archive" >&2
        exit 1
    fi
   


    local template_file=$HPC_DM_UTILS/templates/download-async-template.json
    if [ ! -e "$template_file" ]
    then
        echo "Can not file the template file: $template_file" >&2
        echo "Please pull the latest version and try again" >&2
        exit 1
    fi

    #Make sure the template did not change:
    local container="globus-shared-endpoint-uid"
    local destination="destination-name"

    local container_exists=$(grep  $container $template_file) 
    if [ -z "$container_exists" ]
    then
        echo "The template file $template_file changed." >&2
        echo "Please pull the latest version and try again" >&2
        exit  1
    fi 

    local destination_exists=$(grep $destination $template_file) 
    if [ -z "$destination_exists" ]
    then
        echo "The template file $template_file changed." >&2
        echo "Please pull the latest version and try again" >&2
        exit 1
    fi 

    local request_file=$HPC_DM_UTILS/temp/async-download.json.tmp
     
    #Update the globus endpoint
    updated_endpoint=$(cat $template_file | sed "s@$container@$globus_endpoint@")

    #Update the file name 
    updated_destination=$(echo "$updated_endpoint" | sed "s#${destination}#${dst_path}#")
    echo  "$updated_destination" > $request_file


    echo "Sending request to download the $item_type $src_path to Globus..."
    local response_hdr=download-$item_type-response-header.tmp
    local response_msg=download-$item_type-response-message.json.tmp

    local SERVER=$(get_server)
    local CONFIG=$(get_config)

    curl -H "Content-Type: application/json" -d @$request_file -X POST ${SERVER}/$item_type/$src_path/download  $CONFIG -H "Accept: application/json" -D $response_hdr -o $response_msg -s 2> $HPC_DM_UTILS/temp/curl-status 
    check_connection $response_hdr || exit 1


    local code=$(get_http_code "$response_hdr") 

    if [ "$code" -ne 200 ]
    then 
      #In this case the destination path file will contain the error code
      print_error_message "$response_msg" "$code"  || exit 1
    else
      rm -f $response_hdr 2> /dev/null
    fi

    #Parse the download receipt:

    message=$(get_json_value $response_msg message)
    if [ ! -z "$message" ]
    then
        echo "ERROR downloading $src_path:"  >&2
        echo "$message" >&2
        exit 1
    else
        echo "Download request sent to Globus." 
        task_id=$(get_json_value $response_msg taskId)
        echo "taskID:$task_id" 
        echo "Check the full download receipt at $response_msg"
    fi
}



#Get the status of asynchronousl download request 
#Input: <taskId>  a numerical id for the download receipt
#Input: <request_type> dataObject, collection, or empty string for multiple downloads
#Input: [download-status-file]
#Input: [REST-response]
function dm_get_download_status {

 
    local USAGE="dm_get_download_status  <download-taskId> <request-type> [download-status-file] [REST-response]"
    if [ "$#" -lt 2 ] 
    then
        echo "ERROR: using dm_get_download_status" >&2
        echo "recieved $(basename $0) $@" 
        echo "$USAGE" >&2
        return 1
    fi

    task_id="$1"
    request_type="$2"

    if [ "$request_type" != "" ]
    then
      request_type=/${request_type}
    fi



    local response_msg=${2-get-downlaod-status-response-message.json.tmp}
    local response_header=${3-get-item-response-header.tmp}


    config=$(get_config) || exit 1
    server=$(get_server) || exit 1

   
    curl -G -X GET ${server}${request_type}/download?task_id="$taskId"  $config  -H "Accept: application/json" -D $response_header -o $response_msg -s 2> $HPC_DM_UTILS/temp/curl-status
    check_connection $response_header

    #TO CONTINUE

    local response_code=$(get_http_code $response_header)
    if [ "$response_code" -ne 200 ]
    then
      echo "ERROR getting download status for taskID:\"$taskId\" " >&2
      print_error_message "$response_msg" "$response_code"
      exit 1
    else 
     
      #Check if the user needs the response header file 
      if [ -z "$3" ]
      then 
        rm -f "$RESPONSE_HEADER" 2> /dev/null
      fi

      if [ -z "$2" ]
      then
        print_json_message "$response_msg"    
        rm -f $response_msg 2> /dev/null 
      fi
    fi
}

