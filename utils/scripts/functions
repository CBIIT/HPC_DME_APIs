#!/usr/bin/env bash
# functions
# @author: George Zaki 
# 
# Copyright Leidos Biomedical Research, Inc
# 
# Distributed under the OSI-approved BSD 3-Clause License.
# See http://ncip.github.com/HPC/LICENSE.txt for details.
#
# Common functions to access the API.

source $HPC_DM_UTILS/scripts/utilities

#Generate a DM API authentication token
#Arguments: [password]
function dm_generate_token () {

    local LOG_FILE=$HPC_DM_UTILS/temp/log
    local CONFIG_PATH=$HPC_DM_UTILS/tokens/curl-conf
    rm -f $LOG_FILE 2>/dev/null

    SERVER=$(get_server) || exit 1
    USERNAME=$(get_username) || exit 1

    if [ -z "$1" ]
    then
      curl -k -u $USERNAME  ${SERVER}/authenticate >  $LOG_FILE
    else
      account_password="$1"
      curl -k -u $USERNAME:$account_password  ${SERVER}/authenticate >  $LOG_FILE
    fi

    local TOKEN=$(get_json_value $LOG_FILE token)

    if [ -z $TOKEN ]
    then
        echo "ERROR: no token found in $LOG_FILE " >&2
        MESSAGE=$(get_json_value $LOG_FILE message)
        echo "ERROR MESSAGE: $MESSAGE"   
        return
    else  
      local TOKEN_FILE=$(get_value $HPC_DM_UTILS/hpcdme.properties hpc.login.token)
      local FORMATED_PATH=$(echo $TOKEN_FILE | sed 's/\\/\//g')
      echo $TOKEN > $HPC_DM_UTILS/${FORMATED_PATH}
      local CONFIG_STRING=$(cat "$CONFIG_PATH-sample" | sed "s@Bearer.*@Bearer $TOKEN\"@")
      echo "$CONFIG_STRING" > $CONFIG_PATH
      rm -f $LOG_FILE 2>/dev/null
    fi
}


#Register a collection or a dataObject 
#Inputs:  <description.json>: The metadata json file 
#         <destinaton-path>: The logical path of the destination
#         <type>: dataObjet or collection 
#         [data-object-file] : For synchronous dataObject registration only
function dm_register () {

    local USAGE="usage: dm_register <description.json> <destination-path> <colleciton|dataObject> [data-object-file]"

    if [ -z "$1" ] || [ -z "$2" ] || [ -z "$3" ]
    then
        echo "$USAGE" >&2
        return 1
    fi


    if [ ! -z "$4" ]
    then
        local DATAOBJECT_FILE="$4"
        if [ ! -e "$DATAOBJECT_FILE" ]
        then 
            echo "ERROR: The data-object-file:$DATAOBJECT_FILE does not exist " >&2
            return 1
        fi
    fi

        
    local DESCRIPTION="$1"
    local DESTINATION_PATH="$2"
    local TYPE="$3"

    local VALDN_RES=$(validate_archive_path "$DESTINATION_PATH")
    if [ "" != "$VALDN_RES" ]
    then
      echo "$VALDN_RES" >&2
      return 1
    fi
    
    USERID=$(get_username) || exit 1
    SERVER=$(get_server) || exit 1
    CONFIG=$(get_config) || exit 1

    if [ ! -e "$DESCRIPTION" ]
    then
      echo "ERROR: Can not access the \"$DESCRIPTION\" file" >&2
      exit 1
    fi
    
    local RESPONSE_MSG=${TYPE}-registration-response-message.json.tmp
    local RESPONSE_HEADER=${TYPE}-registration-response-header.tmp

    rm -f  $RESPONSE_MSG 2>/dev/null 
    rm -f $RESPONSE_HEADER 2>/dev/null 

    local CURL_FLAGS="-X PUT ${SERVER}/${TYPE}/$(urlencode $DESTINATION_PATH)  $CONFIG  -D $RESPONSE_HEADER -o $RESPONSE_MSG "
    
    if [ "$TYPE" == "dataObject" ]
    then
        if [ -z "$DATAOBJECT_FILE" ]
        then
            curl -F "dataObjectRegistration=@$DESCRIPTION;type=application/json" $CURL_FLAGS -H "Accept: application/json"  2> $HPC_DM_UTILS/temp/curl-status
        else
            curl -F "dataObjectRegistration=@$DESCRIPTION;type=application/json" -F "dataObject=@$DATAOBJECT_FILE;type=application/octet-stream" $CURL_FLAGS  -H "Accept: application/json"  2> $HPC_DM_UTILS/temp/curl-status 
        fi
    elif [ "$TYPE" == "collection" ]
    then
            
           curl -H "Content-Type: application/json" -d @$DESCRIPTION $CURL_FLAGS  -H "Accept: application/json" 2>$HPC_DM_UTILS/temp/curl-status
    else
        echo "ERROR: Unsupported registration type:$TYPE"
        exit 1
    fi

    check_connection $RESPONSE_HEADER
}

#Register a collection 
#Inputs:  <description.json>: The metadata json file for the collection 
#         <destinaton-path>: The destination logical path
function dm_register_collection {

    local USAGE="usage: dm_register_collection <description.json> <destination-path>"

    if [ -z "$1" ] || [ -z "$2" ] 
    then
        echo "$USAGE" >&2
        return
    fi

    local DESCRIPTION="$1"
    local DESTINATION_PATH="$2"

    dm_register "$DESCRIPTION" "$DESTINATION_PATH" collection || exit 1

    local RESPONSE_HEADER=collection-registration-response-header.tmp
    local RESPONSE_MSG=collection-registration-response-message.json.tmp

    verify_registration "$RESPONSE_HEADER" "$RESPONSE_MSG" "$DESTINATION_PATH"

}

#Register a dataObject using presigned S3 URL
#Inputs:  <description.json>: The metadata json file for the dataObject 
#         <destinaton-path>: The destination logical path
#         <source-file>: The source file for synchronous registratio.
function dm_register_dataobject_presigned {

    local USAGE="usage: dm_register_dataobject_presigned <description.json> <destination-path> <source-file>"

    if [ "$#" -lt 3 ]
    then
        echo "$USAGE" >&2
        return
    fi

    local description="$1"
    local destination_path="$2"
    local source_file="$3"
    dm_register "$description" "$destination_path" dataObject 
    if [ "$?" -eq  1 ]
    then
      return 1
    fi

    local response_header=dataObject-registration-response-header.tmp
    local response_msg=dataObject-registration-response-message.json.tmp

    #verify_registration "$RESPONSE_HEADER" "$RESPONSE_MSG" "$DESTINATION_PATH"
    presigned_url=`get_json_value $response_msg uploadRequestURL`
    if [ -z "$presigned_url" ]
    then
      echo "ERROR: Can not retrieve the presigned url from $response_msg for $destination_path" >&2
      return 1
    fi

    rm $response_header $response_msg
    response_header=presignedURL-registration-response-header.tmp
    response_msg=presignedURL-registration-response-message.tmp
    curl -i -X PUT -F 'Content-Type=application/octet-stream' -F "file=@${source_file}" "${presigned_url}" -D $response_header -o $response_msg -s
    if [ "$?" -ne 0 ]
    then
      echo "ERROR during presigned URL registration for $destination_path" >&2
      echo "Check the files $response_header and $response_msg" >&2
      return 1
    fi

    rm $response_header $response_msg
}



#Register a dataObject 
#Inputs:  <description.json>: The metadata json file for the dataObject 
#         <destinaton-path>: The destination logical path
#         [source-file]: The source file for synchronous registratio.
function dm_register_dataobject {

    local USAGE="usage: dm_register_dataobject <description.json> <destination-path> [source-file]"

    if [ -z "$1" ] || [ -z "$2" ] 
    then
        echo "$USAGE" >&2
        return
    fi

    local DESCRIPTION="$1"
    local DESTINATION_PATH="$2"
    local SOURCE_FILE=$3
    dm_register "$DESCRIPTION" "$DESTINATION_PATH" dataObject $SOURCE_FILE 
    if [ "$?" -eq  1 ]
    then
      return 1
    fi
    
    local RESPONSE_HEADER=dataObject-registration-response-header.tmp
    local RESPONSE_MSG=dataObject-registration-response-message.json.tmp

    verify_registration "$RESPONSE_HEADER" "$RESPONSE_MSG" "$DESTINATION_PATH"
}

#Sync a folder in the current file system with a logical path in the Archive
#There is no metadata for folder and they will be automatically created.
#The files metadata is the list of attributes/values pair that are returned by the 
#function "get_json-file"
#Inputs: Globus endpoint
#        Source path on Globus endpoint
#        Destination logical path on Archive.
#<source-folder>    The source folder on the file system
#        <destination-path> The destination logical path
function dm_sync_globus_endpoint  {

    local USAGE="usage: dm_sync_folder <source-folder> <destination-path>"

    if [ -z "$1" ] || [ -z "$2" ] 
    then
        echo "$USAGE" >&2
        return
    fi


    local RESPONSE_HEADER=dataObject-registration-response-header.tmp
    local RESPONSE_MSG=dataObject-registration-response-message.json.tmp


    local FILE_LIST="./test.txt /TEST_Archive/test.txt"

    while read -r  NEW_FILE 
    do 

      local SRC_PATH=$(echo $NEW_FILE | cut -d' ' -f1)
      local DST_PATH=$(echo $NEW_FILE | cut -d' ' -f2)
      local FILE_ATTRIBUTES=$(get_file_attributes $SRC_PATH)      
      local DESC_JSON=$(get_json_description $FILE_ATTRIBUTES)
      echo $DESC_JSON >  temp.json
      echo "dm_register_dataobject  temp.json $DST_PATH $SRC_PATH"
      echo "verify_registration  $REPONSE_HEADER $RESPONSE_MSG $DST_PATH"

      rm -f $RESPONSE_HEADER 2>/dev/null
      rm -f $RESPONSE_MSG 2>/dev/null

    done <<< "$FILE_LIST"

}


#Get an item (collection or dataObject) from the archive
#Inputs: <item-path> (should have a prefix of "dataObject" or "collection")
#      : [metadata-file]
#      : [REST-response]
function dm_get_item {

    local USAGE="usage: dm_get_item <item-path> [metadata-file] [REST-response]"

    if [ "$#" -lt 1 ] 
    then
        echo "$USAGE" >&2
        return 1
    fi
    local ITEM_PATH="$1"

    local RESPONSE_MSG
    local RESPONSE_HEADER
    if [ ! -z "$2" ]
    then
      RESPONSE_MSG="$2"
    else
      RESPONSE_MSG=get-item-response-message.json.tmp
    fi 

    if [ ! -z "$3" ]
    then
      RESPONSE_HEADER="$3"
    else
      RESPONSE_HEADER=get-item-response-header.tmp
    fi 

    CONFIG=$(get_config) || exit 1
    SERVER=$(get_server) || exit 1

    local TOTAL_PATH="$ITEM_PATH"
    local TOTAL_PATH=$(echo "$TOTAL_PATH" | sed "s#\/\/*#\/#g")
    local ITEM_TYPE="$( cut -d '/' -f 1 <<< "$TOTAL_PATH" )"
    local DME_ARCHIVE_PATH="$( cut -d '/' -f 2- <<< "$TOTAL_PATH" )"
   
    curl -G -X GET "$SERVER/$ITEM_TYPE/$(urlencode $DME_ARCHIVE_PATH)"  $CONFIG  -D $RESPONSE_HEADER -o $RESPONSE_MSG -s 2> $HPC_DM_UTILS/temp/curl-status 
    check_connection $RESPONSE_HEADER
}


#Get the metadata of a dataobject from the archive
#Inputs: <dataObject-path> 
#      : [metadata-file]
#      : [REST-response]
function dm_get_dataobject {

    local USAGE="usage: dm_get_dataobject <dataobject-path> [metadata-file] [REST-response]"
    
    while getopts ":rt:" option
    do
      case "${option}" in
        *)
          echo "$USAGE" >&2
          exit 1
          ;;
      esac
    done

    if [ "$#" -lt 1 ] 
    then
        echo "$USAGE" >&2
        return
    fi
    local ITEM_PATH="$1"


    local RESPONSE_MSG=${2-get-item-response-message.json.tmp}
    local RESPONSE_HEADER=${3-get-item-response-header.tmp}

    dm_get_item dataObject/$ITEM_PATH  "$RESPONSE_MSG" "$RESPONSE_HEADER" || exit 1

    local RESPONSE_CODE=$(get_http_code $RESPONSE_HEADER)
    if [ "$RESPONSE_CODE" -ne 200 ]
    then
      echo "ERROR getting \"$ITEM_PATH\" " >&2
      #echo "ERROR_CODE:\"$RESPONSE_CODE\"" >&2
      print_error_message "$RESPONSE_MSG" "$RESPONSE_CODE"
      exit 1
    else 
     
      #Check if the user needs the response header file 
      if [ -z "$3" ]
      then 
        rm -f "$RESPONSE_HEADER" 2> /dev/null
      fi

      if [ -z "$2" ]
      then
        print_json_message "$RESPONSE_MSG"    
        rm -f $RESPONSE_MSG 2> /dev/null 
      fi
      exit 0
    fi
}


#Get the metadata of a collection from the archive
#Inputs: <collection-path> 
#      : [metadata-file]
#      : [REST-response]
function dm_get_collection {

    local USAGE="usage: dm_get_collection <collection-path> [metadata-file] [REST-response]"

    while getopts ":rt:" option
    do
      case "${option}" in
        *)
          echo "$USAGE" >&2
          exit 1
          ;;
      esac
    done


    if [ "$#" -lt 1 ] 
    then
        echo "$USAGE" >&2
        return
    fi
    local ITEM_PATH="$1"

    local RESPONSE_MSG=${2-get-item-response-message.json.tmp}
    local RESPONSE_HEADER=${3-get-item-response-header.tmp}

    dm_get_item collection/$ITEM_PATH  "$RESPONSE_MSG" "$RESPONSE_HEADER" || exit 1

    local RESPONSE_CODE=$(get_http_code $RESPONSE_HEADER)
    if [ "$RESPONSE_CODE" -ne 200 ]
    then
      echo "ERROR getting \"$ITEM_PATH\" " >&2
      print_error_message "$RESPONSE_MSG" "$RESPONSE_CODE"
      exit 1
    else 
     
      #Check if the user needs the response header file 
      if [ -z "$3" ]
      then 
        rm -f "$RESPONSE_HEADER" 2> /dev/null
      fi

      if [ -z "$2" ]
      then
        print_json_message "$RESPONSE_MSG"    
        rm -f $RESPONSE_MSG 2> /dev/null 
      fi
    fi
}


#Print Usage of dm_download_dataobject_sync function
function dm_show_download_dataobject_sync_usage {
  read -d  '' usage <<- EOF
  usage: dm_download_dataobject_sync [-p] <logic-path> <destination-file>

  Download the specified dataobject to the local machine.
  OPTIONS:
  -p                     Use S3-presigned URL for downloading.
EOF
  echo "$usage"
}



#Download a dataObject synchronously 
#Inputs: logic-path 
#        destination-file
function dm_download_dataobject_sync {
  #local USAGE="usage: dm_download_dataobject_sync [-p] <logic-path> <destination-file>\n   -p indicates to use S3-presigned URL for downloading"
  local OPTIND
  #Set the default parameters
  local APPLY_PRESIGNED=0
  local TEMPLATE="$HPC_DM_UTILS/templates/download-sync-template.json"
  while getopts ":p" option
    do
      case "${option}" in
        p)
          APPLY_PRESIGNED=1
          TEMPLATE="$HPC_DM_UTILS/templates/download-sync-presigned-template.json"
        ;;
        *)
          dm_show_download_dataobject_sync_usage >&2
          exit 1
          ;;
      esac
  done
  shift $(( OPTIND-1 ))
  if [ "$#" -lt 2 ] 
  then
    dm_show_download_dataobject_sync_usage >&2
    return 1
  fi
  local OBJECT_PATH="$1"
  local DESTINATION_PATH="$2"
  if [ -d "$DESTINATION_PATH"  ]
  then
    #Download the file with the same file name 
    local FILE_NAME=$(basename "$OBJECT_PATH")
    if [ "$?" -ne 0 ]
    then
      echo "ERROR:Can not retrieve the file name from \"$OBJECT_PATH\"" >&2
      return 1
    fi
    local DESTINATION_PATH=$DESTINATION_PATH/${FILE_NAME}
  fi
  local CONFIG=$(get_config)
  local SERVER=$(get_server)
  local CODE=0
  local RESPONSE_HEADER=download-dataobject-response-header.tmp
  if [ $APPLY_PRESIGNED -eq 0 ]
  then
    curl -H "Content-Type: application/json" -H "Accept: application/json" \
      $CONFIG -d @$TEMPLATE \
      -X POST ${SERVER}/dataObject/$(urlencode $OBJECT_PATH)/download \
      -D $RESPONSE_HEADER -o $DESTINATION_PATH -s \
      2> $HPC_DM_UTILS/temp/curl-status
    check_connection $RESPONSE_HEADER
    CODE=$(get_http_code "$RESPONSE_HEADER")
    if [ "$CODE" -ne 200 ]
    then 
      #In this case the destination path file will contain the error code
      print_error_message "$DESTINATION_PATH" "$CODE" 
    else
      rm -f $RESPONSE_HEADER 2> /dev/null
    fi
  else
    local RESPONSE_HEADER_OBTAIN_PRESIGNED=obtain-presigned-url-response-header.tmp
    local RESPONSE_MESSAGE_OBTAIN_PRESIGNED=obtain-presigned-url-response-message.tmp

    curl -H "Content-Type: application/json" -H "Accept: application/json" \
      $CONFIG -d @$TEMPLATE \
      -X POST ${SERVER}/dataObject/$(urlencode $OBJECT_PATH)/download \
      -D $RESPONSE_HEADER_OBTAIN_PRESIGNED \
      -o $RESPONSE_MESSAGE_OBTAIN_PRESIGNED \
      -s 2> $HPC_DM_UTILS/temp/curl-status

    check_connection $RESPONSE_HEADER_OBTAIN_PRESIGNED

    CODE=$(get_http_code "$RESPONSE_HEADER_OBTAIN_PRESIGNED")
    if [ "$CODE" -ne 200 ]
    then
      if [ "$CODE" -eq 400 ]
      then
        print_error_message $RESPONSE_MESSAGE_OBTAIN_PRESIGNED 400
      else
        >&2 echo "Request to obtain presigned URL failed.  See response data below."
        >&2 echo "( Response data is also available in the following 2 files: "
        >&2 echo "  1. $(pwd)/$RESPONSE_HEADER_OBTAIN_PRESIGNED"
        >&2 echo "  2. $(pwd)/$RESPONSE_MESSAGE_OBTAIN_PRESIGNED"
        >&2 echo ")"
        >&2 echo ""
        >&2 cat $RESPONSE_HEADER_OBTAIN_PRESIGNED
        >&2 cat $RESPONSE_MESSAGE_OBTAIN_PRESIGNED
      fi
    else 
      local PRESIGNED_URL=$(get_json_value  $RESPONSE_MESSAGE_OBTAIN_PRESIGNED  downloadRequestURL)
      if [ -z "$PRESIGNED_URL" ]
      then
        >&2 echo "Request to obtain presigned URL was successfully processed, but response is missing the URL.  See response data below."
        >&2 echo "( Response data is also available in the following 2 files: "
        >&2 echo "  1. $(pwd)/$RESPONSE_HEADER_OBTAIN_PRESIGNED"
        >&2 echo "  2. $(pwd)/$RESPONSE_MESSAGE_OBTAIN_PRESIGNED"
        >&2 echo ")"
        >&2 echo ""
        >&2 cat $RESPONSE_HEADER_OBTAIN_PRESIGNED
        >&2 cat $RESPONSE_MESSAGE_OBTAIN_PRESIGNED
      else
        curl -X GET $PRESIGNED_URL -D $RESPONSE_HEADER -o $DESTINATION_PATH -s 2> $HPC_DM_UTILS/temp/curl-status
        check_connection $RESPONSE_HEADER

        CODE=$(get_http_code "$RESPONSE_HEADER")
        if [ "$CODE" -ne 200 ]
        then 
          >&2 echo "Failed to download file from obtained presigned URL.  See response data below."
          >&2 echo "  ( Response data from request available in file $DESTINATION_PATH. )"
          >&2 echo ""
          >&2 cat $RESPONSE_HEADER
          >&2 cat $DESTINATION_PATH
        else
          rm -f  $RESPONSE_HEADER  $RESPONSE_HEADER_OBTAIN_PRESIGNED  $RESPONSE_MESSAGE_OBTAIN_PRESIGNED  2> /dev/null
        fi
      fi
    fi
  fi
}


#Delete a datafile from the archive using the cmd line client.
#Inputs:  <file-path>: The path on the file system 

function dm_delete_datafile {

    local USAGE="usage: dm_delete_datafile <file-path>"

    check_java
    if [ "$?" -ne 0 ]
    then 
      return 1
    fi

    if [ -z "$1" ] 
    then
        echo "$USAGE" >&2
        exit 1 
    fi
    
    local file_path="$1"
   
    #Check if the jar exists:
    local jar_file=$(get_jar)
    local jar_path=$HPC_DM_UTILS/hpc-client/$jar_file
    if [ ! -f $jar_path ]
    then
      echo "Can not find $jar_path " >&2
      return 1
    fi

    command_args=""

    #Pass the mandatory arguments
    command_args+=" --path \"$file_path\" "
  
    #Generate the command for the client: 
    local command_file=$HPC_DM_UTILS/temp/cmd-file
    echo "deleteDatafile  " $command_args >  $command_file

    case "$(uname -s)" in
    
       Darwin|Linux)
        java -Dhpc.client.properties=$HPC_DM_UTILS/hpcdme.properties -DHPC_DM_UTILS=$HPC_DM_UTILS -jar $jar_path  --cmdfile $command_file
        exit_code="$?"
       ;;
    
       CYGWIN*|MINGW32*|MSYS*)
            java -DHPC_DM_UTILS=$(cygpath -m $HPC_DM_UTILS) -Dhpc.client.properties=$(cygpath -w $HPC_DM_UTILS/hpcdme.properties)  -jar $(cygpath -w $jar_path)  --cmdfile $(cygpath -w $command_file)
        exit_code="$?"
       ;;
    
       *)
         echo 'Current OS not supported' 
         exit 1
         ;;
    esac

    if [ "$exit_code" -eq  "1" ]
    then
      echo "The datafile deletion did not fully complete successfully" >&2
      echo "Check complete log and error files" >&2
      return 1
    fi

}

#Print Usage of dm_register_directory function
function dm_show_delete_collection_usage {
  read -d  '' usage <<- EOF
  usage: dm_delete_collection [OPTIONS] <collection-path> 

  Delete the collection at the specified path. 
  OPTIONS:
  -r                      Recursive delete. This will delete all the files and sub-collections under the specified collection recursively. 
EOF
  echo "$usage"
}

#Delete a collection from the archive using the cmd line client.
#Inputs:  <source-path>: The path on the file system 

function dm_delete_collection {

    #local USAGE="usage: dm_delete_collection <collection-path>"
    local OPTIND
    
    #Set the default parameters
    numthreads=1
    recursive=false
  
   while getopts ":rt:" option
    do
      case "${option}" in
       
        r)
	  recursive=true
          ;;
        *)
          dm_show_delete_collection_usage >&2
          exit 1
          ;;
      esac
    done


    shift $(( OPTIND-1 ))   

    check_java
    if [ "$?" -ne 0 ]
    then 
      return 1
    fi

    if [ -z "$1" ] 
    then
        dm_show_delete_collection_usage >&2
        exit 1
    fi


    local collection_path="$1"

    #Check if the jar exists:
    local jar_file=$(get_jar)
    local jar_path=$HPC_DM_UTILS/hpc-client/$jar_file
    if [ ! -f $jar_path ]
    then
       echo "Can not find $jar_path " >&2
       return 1
     fi

    command_args=""

    #Pass the mandatory arguments
    command_args+="--path \"$collection_path\" "

    #Pass the optional ones
    command_args+="--recursive $recursive "

    #Generate the command for the client: 
    local command_file=$HPC_DM_UTILS/temp/cmd-file
    echo "deleteCollection  " $command_args >  $command_file

    case "$(uname -s)" in
    
       Darwin|Linux)
        java -Dhpc.client.properties=$HPC_DM_UTILS/hpcdme.properties -DHPC_DM_UTILS=$HPC_DM_UTILS -jar $jar_path  --cmdfile $command_file
        exit_code="$?"
       ;;
    
       CYGWIN*|MINGW32*|MSYS*)
            java -DHPC_DM_UTILS=$(cygpath -m $HPC_DM_UTILS) -Dhpc.client.properties=$(cygpath -w $HPC_DM_UTILS/hpcdme.properties)  -jar $(cygpath -w $jar_path)  --cmdfile $(cygpath -w $command_file)
        exit_code="$?"
       ;;
    
       *)
         echo 'Current OS not supported' 
         exit 1
         ;;
    esac

    if [ "$exit_code" -eq  "1" ]
    then
      echo "The collection deletion did not fully complete successfully" >&2
      echo "Check complete log and error files" >&2
      return 1
    fi
}



#Print Usage of dm_register_directory function
function dm_show_register_directory_usage {
  read -d  '' usage <<- EOF
  usage: dm_register_directory [OPTIONS]  <source-path> <destination-path> 

  Recursively copy all files in the <source-path> to the archive's <destination-path>. 
  Metadata can be provided for every directory and file in a specific metadata file called <[directory,filename]>.metadata.json. The metadata file should exist in the same path in its corresponding directory/file. For example the metadata for the file data.txt should be data.txt.metadata.json
  OPTIONS:
  -a[ARCHIVE_TYPE]        The type of the archive. Valid options are "S3" and "POSIX".
  -c                      Turn off checksum calculation. 
  -d                      Print the files to be included in registration and exit 
  -e[EXCLUDE_FILE_PATH]   Exclude the files that match the patterns specified in the file EXCLUDE_FILE_PATH
  -i[INCLUDE_FILE_PATH]   Include the files that match at least one of the patterns specified in INCLUDE_FILE_PATH
  -l[FILES_LIST]          Register the files mentioned in the FILE_LIST only. Each line in the FILES_LIST file contains a relative path to the source-path.
                          All collections should be registered before using this option.
  -m                      Register metadata only. Do not register files.
  -s                      Skip confirmation prompt and register directly
  -h                      Print this message 
  -t[NUM_THREADS]         The number of threads to use while uploading files to the archive. This number should be between [1, 32].
EOF
  echo "$usage"
}


#Register a directory from a file system using the cmd line client.
#Inputs:  <source-path>: The path on the file system 
#         <destinaton-path>: The destination logical path on the archive
function dm_register_directory {

    #local USAGE="USAGE: dm_register_directory <source-path> <destination-path>"
    local OPTIND
    
    #Set the default parameters
    numthreads=1
    archiveType=S3
    checksum=true

    while getopts ":a:b:cde:i:l:hmp:st:" option
    do
      case "${option}" in
        a)
          archiveType="${OPTARG}"
          if [ "$archiveType" != "S3" ] && [ "$archiveType" != "POSIX" ]
          then
            echo "ERROR: the arhive type can be either \"S3\" or \"POSIX\". Recevied:\"$archiveType\"" >&2
            exit 1 
          fi
          ;;
        c)
          checksum=false
          ;;

        d)
          dry_run=1
          echo "Running dry, no registration will take place."
          ;;
        e)
          exclude_option=1
          exclude_file="${OPTARG}"
          if [ ! -e "$exclude_file" ]
          then
            echo "ERROR: The exclude file $exclude_file does not exists" >&2
            exit 1
          fi
          ;;
        i)
          include_option=1
          include_file="${OPTARG}"
          if [ ! -e "$include_file" ]
          then
            echo "ERROR: The include file $include_file does not exists" >&2
            exit 1
          fi
          ;;
        l)
          file_list=1
          list_of_files="${OPTARG}"
          if [ ! -e "$list_of_files" ]
          then
            echo "ERROR: The FILES_LIST $list_of_files does not exists" >&2
            exit 1
          fi
          ;;
        m)
          metadata_only=1
          ;;
        s)
          skip_confirmation=1
          ;;
        h)
          dm_show_register_directory_usage 
          exit 1
          ;;
        t)
          numthreads="${OPTARG}"
          re='^[0-9]+$'
          if ! [[ "$numthreads" =~ $re ]] ; then
             echo "ERROR: The number of threads $numthreads is not a positive integer." >&2; exit 1
          fi

          if [ "$numthreads" -lt "0" ] || [ "$numthreads" -gt "32" ]
          then
             echo "ERROR: The number of threads $numthreads should be between [1, 32]" >&2; exit 1
          fi
          ;;
        *)
          dm_show_register_directory_usage >&2
          exit 1
          ;;
      esac
    done

    shift $(( OPTIND-1 ))   

    check_java
    if [ "$?" -ne 0 ]
    then 
      return 1
    fi
    if [ -z "$1" ] || [ -z "$2" ] 
    then
        dm_show_register_directory_usage >&2
        exit 1 
    fi

    local src_path="$1"
    local dst_path="$2"

    #Check if the jar exists:
    local jar_file=$(get_jar)
    local jar_path=$HPC_DM_UTILS/hpc-client/$jar_file
    if [ ! -f $jar_path ]
    then
      echo "Can not find $jar_path " >&2
      return 1
    fi

    #Make sure the source directory exists:
    if [ ! -d "$src_path" ]
    then
      echo "The source directory: $src_path does not exist." >&2
      exit 1
    fi 

    command_args=""

    #Pass the mandatory arguments
    full_src_path=$(myreadlink $src_path)
    full_src_path_converted=$(convert_path "$full_src_path")
    command_args+=" --sourceFilePath \"$full_src_path_converted\" "

    command_args+=" --destinationArchivePath \"$dst_path\" "

    #Pass the options related to files that will be registered. 
  
    if [ $file_list ]
    then
      list_of_files_converted=$(convert_path "$list_of_files")
      command_args+=" --sourceFileList \"${list_of_files_converted}\" "
    else
     #Get the include path
      if [ "$include_option" ] 
      then
        full_include_path=$(myfilereadlink "$include_file")
        full_include_path_converted=$(convert_path "$full_include_path")
        command_args+=" --includePatternFile \"${full_include_path_converted}\" "
      fi
  
      #Get the exclude path
      if [ "$exclude_option" ] 
      then
        full_exclude_path=$(myfilereadlink "$exclude_file")
        full_exclude_path_converted=$(convert_path "$full_exclude_path")
        command_args+=" --excludePatternFile \"${full_exclude_path_converted}\" "
      fi
    fi 

    if [ "$dry_run" ]
    then
      command_args+=" --dryRun true"
    fi

    if [ ! "$skip_confirmation" ]
    then
      command_args+=" --confirm true "
    else  
      command_args+=" --confirm false "
    fi

    if [ "$metadata_only" ]
    then
      command_args+=" --metadata true "
    fi

    #Add all other options
    command_args+=" --threads $numthreads"
    command_args+=" --archiveType $archiveType"
    command_args+=" --checksum $checksum"

    #Generate the command for the client: 
    local command_file=$HPC_DM_UTILS/temp/cmd-file
    echo "registerFromFilePath  " $command_args >  $command_file

    local log_file=./dm_log
    local error_file=./dm_error

    case "$(uname -s)" in
    
       Darwin|Linux)
        java -Dhpc.client.properties=$HPC_DM_UTILS/hpcdme.properties -DHPC_DM_UTILS=$HPC_DM_UTILS -jar $jar_path  --cmdfile $command_file
        exit_code="$?"
       ;;
    
       CYGWIN*|MINGW32*|MSYS*)
            java -DHPC_DM_UTILS=$(cygpath -m $HPC_DM_UTILS) -Dhpc.client.properties=$(cygpath -w $HPC_DM_UTILS/hpcdme.properties)  -jar $(cygpath -w $jar_path)  --cmdfile $(cygpath -w $command_file)
        exit_code="$?"
       ;;
    
       # Add here more strings to compare
       # See correspondence table at the bottom of this answer
    
       *)
         echo 'Current OS not supported' 
         exit 1
         ;;
    esac

    if [ "$exit_code" -eq  "1" ]
    then
      echo "The batch registration did not fully complete successfully" >&2
      echo "Check complete log and error files at:" >&2
      echo "$log_file" >&2
      echo "$error_file" >&2
      return 1
    fi

}


#Print Usage of dm_register_globus_directory function
function dm_show_register_globus_directory_usage {
  read -d  '' usage <<- EOF
  usage: dm_register_globus_directory [OPTIONS]  <source-path> <destination-path> [endpoint]

  Recursively copy all files in the Globus <source-path> to the archive's <destination-path>. If endpoint is not passed, the default Globus endpoint in hpcdme.properties file will be used.
  OPTIONS:
  -d                      Print the files to be included in registration and exit 
  -e[EXCLUDE_FILE_PATH]   Exclude the files that match the patterns specified in the file EXCLUDE_FILE_PATH
  -i[INCLUDE_FILE_PATH]   Include the files that match at least one of the patterns specified in INCLUDE_FILE_PATH
  -p[PATTERN_TYPE]        The type of the regex pattern in the include/exclude files. Valid options are "Simple" and "RegEx". The default pattern is "Simple"
  -h                      Print this message 
EOF
  echo "$usage"
}




#Register a directory from a globus endpoint using the cmd line client.
#By default the endpoint specified in hpcdme.properties will be used
#Inputs:  <source-path>: The path on the globus endpoint 
#         <destinaton-path>: The destination logical path on the archive
#         [globus-endpoint]: The endpoint to use other that default
function dm_register_globus_directory {

    local OPTIND

    #Set the default parameters
    patternType=Simple

    while getopts ":de:i:hp:t:" option
    do
      case "${option}" in
        d)
          dry_run=1
          echo "Running dry, no registration will take place."
          ;;
        e)
          exclude_option=1
          exclude_file="${OPTARG}"
          if [ ! -e "$exclude_file" ]
          then
            echo "ERROR: The exclude file $exclude_file does not exists" >&2
            exit 1
          fi
          ;;
        i)
          include_option=1
          include_file="${OPTARG}"
          if [ ! -e "$include_file" ]
          then
            echo "ERROR: The include file $include_file does not exists" >&2
            exit 1
          fi
          ;;
        p)
          patternType="${OPTARG}"
          if [ "$patternType" != "Simple" ] && [ "$patternType" != "RegEx" ]
          then
            echo "ERROR: the include/exclude pattern type can be either \"Simple\" or \"RegEx\". Recevied:\"$patternType\"" >&2
            exit 1 
          fi
          ;;
        h)
          dm_show_register_globus_directory_usage >&2
          exit 1
          ;;
        *)
          dm_show_register_globus_directory_usage >&2
          exit 1
          ;;
      esac
    done

    shift $(( OPTIND-1 ))   

    check_java
    if [ "$?" -ne 0 ]
    then 
      return 1
    fi
    if [ -z "$1" ] || [ -z "$2" ] 
    then
        dm_show_register_globus_directory_usage >&2
        exit 1 
    fi

    local src_path="$1"
    local dst_path="$2"

    #Check if the jar exists:
    local jar_file=$(get_jar)
    local jar_path=$HPC_DM_UTILS/hpc-client/$jar_file
    if [ ! -f $jar_path ]
    then
      echo "Can not find $jar_path " >&2
      return 1
    fi

    local globus_endpoint
    if [ -z "$3" ]
    then
      #echo "Using the default globus endpoint in $HPC_DM_UTILS/hpcdme.properties" 
      globus_endpoint=$(get_globus_endpoint)
      if [ "$?" -ne 0 ]
      then
        echo  "ERROR: Can not find the default Globus endpoint in the properties file." >&2
        exit 1
      fi
    else
      globus_endpoint="$3"
    fi       

    command_args=""
    #Get the include path
    if [ "$include_option" ]
    then
      full_include_path=$(myfilereadlink "$include_file")
      command_args+=" --includePatternFile \"$full_include_path\""
    fi

    #Get the exclude path
    if [ "$exclude_option" ]
    then
      full_exclude_path=$(myfilereadlink "$exclude_file")
      command_args+=" --excludePatternFile \"$full_exclude_path\""
    fi

    if [ "$dry_run" ]
    then
      command_args+=" --dryRun true"
    fi

    #Add all other options
    command_args+=" --patternType $patternType"

    #Generate the command for the client: 
    local command_file=$HPC_DM_UTILS/temp/cmd-file
    echo "registerFromGlobusPath --globusEndpoint $globus_endpoint --globusSourcePath $src_path --destinationArchivePath $dst_path" $command_args >  $command_file

    local log_file=./dm_log
    local error_file=./dm_error

    
    case "$(uname -s)" in
    
       Darwin)
         echo 'Mac OS X is not currently supported'
         return 1
         ;;
       Linux)
        java -Dhpc.client.properties=$HPC_DM_UTILS/hpcdme.properties -DHPC_DM_UTILS=$HPC_DM_UTILS -jar $jar_path  --cmdfile $command_file
         ;;
       CYGWIN*|MINGW32*|MSYS*)
            java -DHPC_DM_UTILS=$(cygpath -m $HPC_DM_UTILS) -Dhpc.client.properties=$(cygpath -w $HPC_DM_UTILS/hpcdme.properties)  -jar $(cygpath -w $jar_path)  --cmdfile $(cygpath -w $command_file)
        ;;
       # Add here more strings to compare
       # See correspondence table at the bottom of this answer
       *)
         echo 'Current OS not supported' 
         return 1
         ;;
    esac

    if [ "$?" -eq  1 ]
    then
      echo "The batch registration did not fully complete successfully" >&2
      echo "Check complete log and error files at:" >&2
      echo "$log_file" >&2
      echo "$error_file" >&2
      return 1
    fi

}

#Download a collection to Globus 
#Inputs: collection-apth
#        destination-file
function dm_download_collection_async {


    local USAGE="usage: dm_download_collection_async <collection-logical-path> <globus-destination-path> [globus-endpoint]"

    if [ "$#" -lt 2 ] 
    then
        echo "$USAGE" >&2
        return 1
    fi

    local src_path="$1"
    local dst_path="$2"

    local globus_endpoint
    if [ -z "$3" ]
    then
      #echo "Using the default globus endpoint in $HPC_DM_UTILS/hpcdme.properties" 
      globus_endpoint=$(get_globus_endpoint)
      if [ "$?" -ne 0 ]
      then
        return 1
      fi
    else
      globus_endpoint="$3"
    fi       

    local template_file=$HPC_DM_UTILS/templates/download-async-template.json
    if [ ! -e "$template_file" ]
    then
        echo "Can not file the template file: $template_file" >&2
        echo "Please pull the latest version and try again" >&2
        return 1
    fi

    #Make sure the template did not change:
    local container="globus-shared-endpoint-uid"
    local destination="destination-name"

    local container_exists=$(grep  $container $template_file) 
    if [ -z "$container_exists" ]
    then
        echo "The template file $template_file changed." >&2
        echo "Please pull the latest version and try again" >&2
        return 1
    fi 

    local destination_exists=$(grep $destination $template_file) 
    if [ -z "$destination_exists" ]
    then
        echo "The template file $template_file changed." >&2
        echo "Please pull the latest version and try again" >&2
        return 1
    fi 

    local request_file=$HPC_DM_UTILS/temp/async-download.json.tmp
     
    #Update the globus endpoint
    updated_endpoint=$(cat $template_file | sed "s@$container@$globus_endpoint@")

    #Update the file name 
    updated_destination=$(echo "$updated_endpoint" | sed "s#${destination}#${dst_path}#")
    echo  "$updated_destination" > $request_file

    local response_hdr=download-dataobject-response-header.tmp
    local response_msg=download-dataobject-response-message.json.tmp

    local SERVER=$(get_server)
    local CONFIG=$(get_config)

    curl -H "Content-Type: application/json" -d @$request_file -X POST ${SERVER}/collection/$(urlencode $src_path)/download  $CONFIG -H "Accept: application/json" -D $response_hdr -o $response_msg -s 2> $HPC_DM_UTILS/temp/curl-status 
    check_connection $response_hdr


    local code=$(get_http_code "$response_hdr") 

    if [ "$code" -ne 200 ]
    then 
      #In this case the destination path file will contain the error code
      print_error_message "$reponse_msg" "$code" 
    else
      rm -f $response_hdr 2> /dev/null
    fi
}


#Download to Globus 
#Inputs: <item-path> path on archive
#        <destination-path> path on Globus
function dm_download_async {


    local USAGE="usage: dm_download_async <archive-path> <globus-destination-path> [globus-endpoint]"

    if [ "$#" -lt 2 ] 
    then
        echo "$USAGE" >&2
        exit 1
    fi

    local src_path="$1"
    local dst_path="$2"

    if [ -z "$3" ]
    then
      #echo "Using the default globus endpoint in $HPC_DM_UTILS/hpcdme.properties" 
      globus_endpoint=$(get_globus_endpoint) || exit 1
    else
      globus_endpoint="$3"
    fi       

    local template_file=$HPC_DM_UTILS/templates/download-async-template.json
    if [ ! -e "$template_file" ]
    then
        echo "Can not file the template file: $template_file" >&2
        echo "Please pull the latest version and try again" >&2
        exit 1
    fi

    item_type=$(get_type $src_path) || exit 1
    if [ "$item_type" == "" ]
    then
        echo "ERROR: Can not find the item $src_path in the archive" >&2
        exit 1
    fi
   


    local template_file=$HPC_DM_UTILS/templates/download-async-template.json
    if [ ! -e "$template_file" ]
    then
        echo "Can not file the template file: $template_file" >&2
        echo "Please pull the latest version and try again" >&2
        exit 1
    fi

    #Make sure the template did not change:
    local container="globus-shared-endpoint-uid"
    local destination="destination-name"

    local container_exists=$(grep  $container $template_file) 
    if [ -z "$container_exists" ]
    then
        echo "The template file $template_file changed." >&2
        echo "Please pull the latest version and try again" >&2
        exit  1
    fi 

    local destination_exists=$(grep $destination $template_file) 
    if [ -z "$destination_exists" ]
    then
        echo "The template file $template_file changed." >&2
        echo "Please pull the latest version and try again" >&2
        exit 1
    fi 

    local request_file=$HPC_DM_UTILS/temp/async-download.json.tmp
     
    #Update the globus endpoint
    updated_endpoint=$(cat $template_file | sed "s@$container@$globus_endpoint@")

    #Update the file name 
    updated_destination=$(echo "$updated_endpoint" | sed "s#${destination}#${dst_path}#")
    echo  "$updated_destination" > $request_file


    echo "Sending request to download the $item_type $src_path to Globus..."
    local response_hdr=download-$item_type-response-header.tmp
    local response_msg=download-$item_type-response-message.json.tmp

    local SERVER=$(get_server)
    local CONFIG=$(get_config)

    curl -H "Content-Type: application/json" -d @$request_file -X POST ${SERVER}/$item_type/$(urlencode $src_path)/download  $CONFIG -H "Accept: application/json" -D $response_hdr -o $response_msg -s 2> $HPC_DM_UTILS/temp/curl-status 
    check_connection $response_hdr || exit 1


    local code=$(get_http_code "$response_hdr") 

    if [ "$code" -ne 200 ]
    then 
      #In this case the destination path file will contain the error code
      print_error_message "$response_msg" "$code"  || exit 1
    else
      rm -f $response_hdr 2> /dev/null
    fi

    #Parse the download receipt:

    message=$(get_json_value $response_msg message)
    if [ ! -z "$message" ]
    then
        echo "ERROR downloading $src_path:"  >&2
        echo "$message" >&2
        exit 1
    else
        echo "Download request sent to Globus." 
        task_id=$(get_json_value $response_msg taskId)
        echo "taskID:$task_id" 
        echo "Check the full download receipt at $response_msg"
    fi
}


#Download to s3 bucke/description.json
#Inputs: <archive-path> path on archive
#        <description.json> JSON file containing dextination S3 bucket information
function dm_download_s3_deprecated {


    local USAGE="usage: dm_download_s3 <archive-path> <description.json>"

    if [ "$#" -lt 2 ]
    then
        echo "$USAGE" >&2
        exit 1
    fi

    local SOURCE_PATH="$1"
    local DESCRIPTION="$2"


    item_type=$(get_type $SOURCE_PATH) || exit 1
    if [ "$item_type" == "" ]
    then
        echo "ERROR: Can not find the item $SOURCE_PATH in the archive" >&2
        exit 1
    fi

    echo "Sending request to download the $item_type $SOURCE_PATH to S3..."
    local response_hdr=download-$item_type-response-header.tmp
    local response_msg=download-$item_type-response-message.json.tmp

    local SERVER=$(get_server)
    local CONFIG=$(get_config)

    curl -H "Content-Type: application/json" -d @$DESCRIPTION -X POST ${SERVER}/v2/$item_type/$(urlencode $SOURCE_PATH)/download  $CONFIG -H "Accept: application/json" -D $response_hdr -o $response_msg -s 2> $HPC_DM_UTILS/temp/curl-status
    check_connection $response_hdr || exit 1


    local code=$(get_http_code "$response_hdr")

    if [ "$code" -ne 200 ]
    then
      #In this case the destination path file will contain the error code
      print_error_message "$response_msg" "$code"  || exit 1
    else
      rm -f $response_hdr 2> /dev/null
    fi

    #Parse the download receipt:

    message=$(get_json_value $response_msg message)
    if [ ! -z "$message" ]
    then
        echo "ERROR downloading $src_path:"  >&2
        echo "$message" >&2
        exit 1
    else
        echo "Download request sent to S3."
        task_id=$(get_json_value $response_msg taskId)
        echo "taskID:$task_id"
        echo "Check the full download receipt at $response_msg"
    fi
}


function dm_download_s3 {

    local USAGE="usage: dm_download_s3 <archive-path> <destination_bucket> <destination_folder> <credentials_file>"
    local CREDENTIALS_FILE=~/.aws/credentials
    local DESCRIPTION=description.json

    if [ "$#" -lt 3 ]
    then
        echo "$USAGE" >&2
        exit 1
    fi

    if [ "$#" -gt 3 ]
    then
       CREDENTIALS_FILE=$4
    fi

    local SOURCE_PATH="$1"
    local DESTINATION_BUCKET="$2"
    local DESTINATION_PATH="$3"

    item_type=$(get_type $SOURCE_PATH) || exit 1
    if [ "$item_type" == "" ]
    then
        echo "ERROR: Can not find the item $SOURCE_PATH in the archive" >&2
        exit 1
    fi

   #Create description.json
   local awsAccessKeyId=$(get_value $CREDENTIALS_FILE aws_access_key_id)
   local awsSecretAccessKey=$(get_value $CREDENTIALS_FILE aws_secret_access_key)
   local awsRegion=$(get_value $CREDENTIALS_FILE region)

   echo -e "{\n \"s3DownloadDestination\": {\n \"destinationLocation\": {" > description.json
   echo " \"fileContainerId\": \"$DESTINATION_BUCKET\"," >> description.json
   echo -e " \"fileId\": \"$DESTINATION_PATH\"\n}," >> description.json
   echo -e " \"account\": {\n \"accessKey\": \"$awsAccessKeyId\"," >> description.json
   echo " \"secretKey\": \"$awsSecretAccessKey\"," >> description.json
   echo -e " \"region\": \"$awsRegion\" \n}\n}\n} " >> description.json


    echo "Sending request to download the $item_type $SOURCE_PATH to S3..."
    local response_hdr=download-$item_type-response-header.tmp
    local response_msg=download-$item_type-response-message.json.tmp

    local SERVER=$(get_server)
    local CONFIG=$(get_config)

    curl -H "Content-Type: application/json" -d @$DESCRIPTION -X POST ${SERVER}/v2/$item_type/$(urlencode $SOURCE_PATH)/download  $CONFIG -H "Accept: application/json" -D $response_hdr -o $response_msg -s 2> $HPC_DM_UTILS/temp/curl-status
    check_connection $response_hdr || exit 1


    local code=$(get_http_code "$response_hdr")

    if [ "$code" -ne 200 ]
    then
      #In this case the destination path file will contain the error code
      print_error_message "$response_msg" "$code"  || exit 1
    else
      rm -f $response_hdr 2> /dev/null
    fi

    #Parse the download receipt:

    message=$(get_json_value $response_msg message)
    if [ ! -z "$message" ]
    then
        echo "ERROR downloading $src_path:"  >&2
        echo "$message" >&2
        exit 1
    else
        echo "Download request sent to S3."
        task_id=$(get_json_value $response_msg taskId)
        echo "taskID:$task_id"
        echo "Check the full download receipt at $response_msg"
    fi
}


#Get the status of asynchronousl download request 
#Input: <taskId>  a numerical id for the download receipt
#Input: <request_type> dataObject, collection, or empty string for multiple downloads
#Input: [download-status-file]
#Input: [REST-response]
function dm_get_download_status {

 
    local USAGE="usage: dm_get_download_status <download-taskId> <request-type> [download-status-file] [REST-response]"
    if [ "$#" -lt 2 ] 
    then
        echo "$USAGE" >&2
        return 1
    fi

    task_id="$1"
    request_type="$2"

    if [ "$request_type" != "" ]
    then
      request_type=/${request_type}
    fi



    local response_msg=${2-get-downlaod-status-response-message.json.tmp}
    local response_header=${3-get-item-response-header.tmp}


    config=$(get_config) || exit 1
    server=$(get_server) || exit 1

   
    curl -G -X GET ${server}${request_type}/download?task_id="$taskId"  $config  -H "Accept: application/json" -D $response_header -o $response_msg -s 2> $HPC_DM_UTILS/temp/curl-status
    check_connection $response_header

    #TO CONTINUE

    local response_code=$(get_http_code $response_header)
    if [ "$response_code" -ne 200 ]
    then
      echo "ERROR getting download status for taskID:\"$taskId\" " >&2
      print_error_message "$response_msg" "$response_code"
      exit 1
    else 
     
      #Check if the user needs the response header file 
      if [ -z "$3" ]
      then 
        rm -f "$RESPONSE_HEADER" 2> /dev/null
      fi

      if [ -z "$2" ]
      then
        print_json_message "$response_msg"    
        rm -f $response_msg 2> /dev/null 
      fi
    fi
}


#Rename a collection or a dataObject
#Inputs:  <description.json>: The metadata json file
function dm_rename() {

    local USAGE="usage: dm_rename <description.json> [rename-status-file] [REST-response]"

    if [ -z "$1" ]
    then
        echo "$USAGE" >&2
        return 1
    fi

    local DESCRIPTION="$1"

    if [ ! -e "$DESCRIPTION" ]
    then
      echo "ERROR: Can not access the \"$DESCRIPTION\" file" >&2
      exit 1
    fi

    local RESPONSE_MSG=${2-rename-response-message.json.tmp}
    local RESPONSE_HEADER=${3-rename-response-header.tmp}

    SERVER=$(get_server) || exit 1
    CONFIG=$(get_config) || exit 1

    local CURL_FLAGS="-X POST ${SERVER}/move  $CONFIG  -D $RESPONSE_HEADER -o $RESPONSE_MSG "
    
    curl -H "Content-Type: application/json" -d @$DESCRIPTION $CURL_FLAGS  2>$HPC_DM_UTILS/temp/curl-status

    check_connection $RESPONSE_HEADER
    local response_code=$(get_http_code $RESPONSE_HEADER)
    if [ "$response_code" -ne 200 ] && [ "$response_code" -ne 201 ]
    then
      echo "ERROR performing rename operation " >&2
      print_error_message "$RESPONSE_MSG" "$response_code"
      exit 1
    else

      #Check if the user needs the response header file
      if [ -z "$3" ]
      then
        rm -f "$RESPONSE_HEADER" 2> /dev/null
      fi
      
      if [ -z "$2" ]
      then
        print_json_message "$RESPONSE_MSG"
        rm -f $RESPONSE_MSG 2> /dev/null
      fi
    
    fi 


}



#Add a bookmark for a user
#Inputs:  <bookmark_name>: Name of the bookmark
#         <description.json>: The json file containing the parameters
function dm_add_bookmark () {

    local USAGE="usage: dm_add_bookmark <bookmark_name> <description.json> [REST-response]"

    if [ -z "$1" ] || [ -z "$2" ] 
    then
        echo "$USAGE" >&2
        return 1
    fi

   
    local BOOKMARK_NAME="$1"
    local DESCRIPTION_PATH="$2"
    
    USERID=$(get_username) || exit 1
    SERVER=$(get_server) || exit 1
    CONFIG=$(get_config) || exit 1

    if [ ! -e "$DESCRIPTION_PATH" ]
    then
      echo "ERROR: Can not access the file \"$DESCRIPTION_PATH\" " >&2
      exit 1
    fi
    
    local RESPONSE_MSG=iadd_bookmark-response-message.json.tmp
    local RESPONSE_HEADER=add_bookmark-response-header.tmp

    rm -f  $RESPONSE_MSG 2>/dev/null 
    rm -f $RESPONSE_HEADER 2>/dev/null 

    local CURL_FLAGS="${SERVER}/bookmark/${BOOKMARK_NAME}  $CONFIG  -D $RESPONSE_HEADER -o $RESPONSE_MSG "
    
  
    curl -X PUT -H "Content-Type: application/json" -d @${DESCRIPTION_PATH} $CURL_FLAGS -H "Accept: application/json" 2> $HPC_DM_UTILS/temp/curl-status 

    #Exit with connection error if response header has no data    
    check_connection $RESPONSE_HEADER

    #Process response
    local RESPONSE_CODE=$(get_http_code $RESPONSE_HEADER)
    if [ "$RESPONSE_CODE" -ne 201 ]
    then
      echo "ERROR enrolling user \"$BOOKMARK_NAME\" " >&2
      print_error_message "$RESPONSE_MSG" "$RESPONSE_CODE"
      exit 1
    else

      #Check if the user needs the response header file
      if [ -z "$3" ]
      then
        rm -f "$RESPONSE_HEADER" 2> /dev/null
      fi

      rm -f "$RESPONSE_MSG" 2 > /dev/null
    fi




}

#Register a user
#Inputs:  <user id>: LDAP id of the user
#         <description.json>: The json file containing the parameters
function dm_register_user () {

local USAGE="usage: dm_register_user <userId> <description.json> [REST-response]"

    if [ -z "$1" ] || [ -z "$2" ]
    then
        echo "$USAGE" >&2
        return 1
    fi

  
    local USER_ID="$1"
    local DESCRIPTION_PATH="$2"
   
    USERID=$(get_username) || exit 1
    SERVER=$(get_server) || exit 1
    CONFIG=$(get_config) || exit 1

    if [ ! -e "$DESCRIPTION_PATH" ]
    then
      echo "ERROR: Can not access the file \"$DESCRIPTION_PATH\" " >&2
      exit 1
    fi
   
    local RESPONSE_MSG=register_user-response-message.json.tmp
    local RESPONSE_HEADER=register_user-response-header.tmp

    rm -f  $RESPONSE_MSG 2>/dev/null
    rm -f $RESPONSE_HEADER 2>/dev/null

    local CURL_FLAGS="${SERVER}/user/${USER_ID}  $CONFIG  -D $RESPONSE_HEADER -o $RESPONSE_MSG "
   
 
    curl -X PUT -H "Content-Type: application/json" -d @${DESCRIPTION_PATH} $CURL_FLAGS -H "Accept: application/json" 2> $HPC_DM_UTILS/temp/curl-status
    
    #Exit with connection error if response header has no data
    check_connection $RESPONSE_HEADER

    #Process response
    local RESPONSE_CODE=$(get_http_code $RESPONSE_HEADER)
    if [ "$RESPONSE_CODE" -ne 201 ]
    then
      echo "ERROR enrolling user \"$USER_ID\" " >&2
      print_error_message "$RESPONSE_MSG" "$RESPONSE_CODE"
      exit 1
    else

      #Check if the user needs the response header file
      if [ -z "$3" ]
      then
        rm -f "$RESPONSE_HEADER" 2> /dev/null
      fi

      rm -f "$RESPONSE_MSG" 2 > /dev/null
    fi
}


#Update an existing user
#Inputs:  <user id>: LDAP id of the user
#         <description.json>: The json file containing the parameters
function dm_update_user () {

local USAGE="usage: dm_update_user <userId> <description.json> [REST-response]"

    if [ -z "$1" ] || [ -z "$2" ]
    then
        echo "$USAGE" >&2
        return 1
    fi


    local USER_ID="$1"
    local DESCRIPTION_PATH="$2"

    USERID=$(get_username) || exit 1
    SERVER=$(get_server) || exit 1
    CONFIG=$(get_config) || exit 1

    if [ ! -e "$DESCRIPTION_PATH" ]
    then
      echo "ERROR: Can not access the file \"$DESCRIPTION_PATH\" " >&2
      exit 1
    fi

    local RESPONSE_MSG=register_user-response-message.json.tmp
    local RESPONSE_HEADER=register_user-response-header.tmp

    rm -f  $RESPONSE_MSG 2>/dev/null
    rm -f $RESPONSE_HEADER 2>/dev/null

    local CURL_FLAGS="${SERVER}/user/${USER_ID}  $CONFIG  -D $RESPONSE_HEADER -o $RESPONSE_MSG "


    curl -X POST -H "Content-Type: application/json" -d @${DESCRIPTION_PATH} $CURL_FLAGS -H "Accept: application/json" 2> $HPC_DM_UTILS/temp/curl-status

    #Exit with connection error if response header has no data
    check_connection $RESPONSE_HEADER

    #Process response
    local RESPONSE_CODE=$(get_http_code $RESPONSE_HEADER)
    if [ "$RESPONSE_CODE" -ne 200 ]
    then
      echo "ERROR updating user \"$USER_ID\" " >&2
      print_error_message "$RESPONSE_MSG" "$RESPONSE_CODE"
      exit 1
    else

      #Check if the user needs the response header file
      if [ -z "$3" ]
      then
        rm -f "$RESPONSE_HEADER" 2> /dev/null
      fi

      rm -f "$RESPONSE_MSG" 2 > /dev/null
    fi
}





# Perform percent/URL encoding on given string 
#
# Copied from GitHub
# https://gist.github.com/cdown/1163649
#
#Input: <string>  string to percent/URL encode
urlencode() {
    # urlencode <string>
    old_lc_collate=$LC_COLLATE
    LC_COLLATE=C
    
    local length="${#1}"
    for (( i = 0; i < length; i++ )); do
        local c="${1:i:1}"
        case $c in
            [a-zA-Z0-9.~_-]) printf "$c" ;;
            *) printf '%%%02X' "'$c" ;;
        esac
    done
    
    LC_COLLATE=$old_lc_collate
}


# Perform percent/URL decoding on given string 
#
# Copied from GitHub
# https://gist.github.com/cdown/1163649
#
#Input: <string>  string to percent/URL decode
urldecode() {
    # urldecode <string>

    local url_encoded="${1//+/ }"
    printf '%b' "${url_encoded//%/\\x}"
}


# Validates a given archive path string, specifically to verify that it 
# does not contain any of the forbidden characters in archive paths.
# The forbidden characters comprise the following quoted string "?;\".
#
# Input: <string> archive path
function validate_archive_path () {
  local USAGE="usage: validate_archive_path <archive-path>"
  if [[ $# -ne 1 ]]
  then
    echo "$USAGE" >&2
  else
    local ARCHIVE_PATH="$1"
    # forbidden chars are [space character] plus {? ; \}
    # notice that in grep regex below, ? be escaped as \? and \ must be escaped as \\
    local GREP_RESULT=$(echo $ARCHIVE_PATH | grep -E '[[:space:]]|[\?;\\]')
    if [ -n "$GREP_RESULT" ]
    then
      echo "ERROR: Given archive path '$ARCHIVE_PATH' contains forbidden character(s) from the set { [space character] ? ; \ }."
    fi
  fi
}
