#!/usr/bin/env bash
# functions
# @author: George Zaki 
# 
# Copyright Leidos Biomedical Research, Inc
# 
# Distributed under the OSI-approved BSD 3-Clause License.
# See http://ncip.github.com/HPC/LICENSE.txt for details.
#
# Common functions to access the API.

source $HPC_DM_UTILS/scripts/utilities

#dm_list_commands function
function dm_list_commands {
  read -d  '' usage <<- EOF

  List of DME CLU commands.  
  
	dm_add_bookmark                   dm_get_dataobject
	dm_delete_collection              dm_list_commands
	dm_delete_datafile                dm_query_dataobject
	dm_download_collection            dm_register_collection
	dm_download_collection_globus     dm_register_dataobject
	dm_download_collection_s3         dm_register_dataobject_multipart
	dm_download_dataobject            dm_register_dataobject_presigned
	dm_download_dataobject_globus     dm_register_directory
	dm_download_dataobject_presigned  dm_register_user
	dm_download_dataobject_s3         dm_rename
	dm_generate_token                 dm_update_user
	dm_get_collection
  
To see the detailed information on each command, use '<command name> -h'

To get started with CLU commands, refer to the DME CLU Quick Reference page:
https://wiki.nci.nih.gov/x/wIqhH

EOF
  echo "$usage"
}

#Print Usage of dm_generate_token function
function dm_show_generate_token_usage {
  read -d  '' usage <<- EOF
  usage: dm_generate_token 

  Generates the token for use by CLU commands.  

For detailed information on this command, refer to the following page: 
https://wiki.nci.nih.gov/x/345eFw

EOF
  echo "$usage"
}



#Generate a DM API authentication token
#Arguments: [password]
function dm_generate_token () {

    while getopts ":" option
    do
      case "${option}" in
        *)
          dm_show_generate_token_usage >&2
          exit 1
          ;;
      esac
    done


    local LOG_FILE=$HPC_DM_UTILS/temp/log
    local CONFIG_PATH=$HPC_DM_UTILS/tokens/curl-conf
    rm -f $LOG_FILE 2>/dev/null

    SERVER=$(get_server) || exit 1
    USERNAME=$(get_username) || exit 1

    if [ -z "$1" ]
    then
      curl -k -u $USERNAME  ${SERVER}/authenticate >  $LOG_FILE
    else
      #account_password="$1"
      #curl -k -u $USERNAME:$account_password  ${SERVER}/authenticate >  $LOG_FILE
      dm_show_generate_token_usage >&2
      exit 1
    fi

    local TOKEN=$(get_json_value $LOG_FILE token)

    if [ -z $TOKEN ]
    then
        echo "ERROR: No token found in $LOG_FILE " >&2
        MESSAGE=$(get_json_value $LOG_FILE message)
        echo "ERROR MESSAGE: $MESSAGE"   
        return
    else  
      local TOKEN_FILE=$(get_value $HPC_DM_UTILS/hpcdme.properties hpc.login.token)
      local FORMATED_PATH=$(echo $TOKEN_FILE | sed 's/\\/\//g')
      echo $TOKEN > $HPC_DM_UTILS/${FORMATED_PATH}
      local CONFIG_STRING=$(cat "$CONFIG_PATH-sample" | sed "s@Bearer.*@Bearer $TOKEN\"@")
      echo "$CONFIG_STRING" > $CONFIG_PATH
      rm -f $LOG_FILE 2>/dev/null
    fi
}


#Register a collection or a dataObject 
#Inputs:  [-o output-json-file]
#         [-D REST-response]
#         <description.json>: The metadata json file 
#         <destinaton-path>: The logical path of the destination
#         <type>: dataObjet or collection 
#         [data-object-file] : For synchronous dataObject registration only
function dm_register () {

    local USAGE="usage: dm_register [-D REST-response] [-o output-json-file] <description.json> <destination-path> <collection|dataObject> [data-object-file]"

    local RESPONSE_MSG
    local RESPONSE_HEADER

    while :; do
        case $1 in
            -D|--dump-header)
                if [ "$2" ]; then
                    RESPONSE_HEADER="$2"
                    shift
                else
                    echo "$USAGE" >&2
                    return 1
                fi
            ;;
            -o|--output)
                if [ "$2" ]; then
                    RESPONSE_MSG="$2"
                    shift
                else
                    echo "$USAGE" >&2
                    return 1
                fi
            ;;
            *) break
        esac
        shift
    done

    if [ -z "$1" ] || [ -z "$2" ] || [ -z "$3" ]
    then
        echo "$USAGE" >&2
        return 1
    fi


    if [ ! -z "$4" ]
    then
        local DATAOBJECT_FILE="$4"
        if [ ! -e "$DATAOBJECT_FILE" ]
        then 
            echo "ERROR: The data-object-file:$DATAOBJECT_FILE does not exist " >&2
            return 1
        fi
    fi

        
    local DESCRIPTION="$1"
    local DESTINATION_PATH="$2"
    local TYPE="$3"

    local VALDN_RES=$(validate_archive_path "$DESTINATION_PATH")
    if [ "" != "$VALDN_RES" ]
    then
      echo "$VALDN_RES" >&2
      return 1
    fi
    
    USERID=$(get_username) || exit 1
    SERVER=$(get_server) || exit 1
    CONFIG=$(get_config) || exit 1

	JSON=`get_file_value "$DESCRIPTION"`
    if [ "" == "$JSON" ]
    then
      echo "ERROR: Cannot access the \"$DESCRIPTION\" file" >&2
      exit 1
    fi
    
    if [ -z "$RESPONSE_MSG" ]
     then
        RESPONSE_MSG=${TYPE}-registration-response-message.json.tmp
    fi
    if [ -z "$RESPONSE_HEADER" ]
    then
        RESPONSE_HEADER=${TYPE}-registration-response-header.tmp
    fi

    rm -f  $RESPONSE_MSG 2>/dev/null 
    rm -f $RESPONSE_HEADER 2>/dev/null 

    local CURL_FLAGS_COLLECTION="-X PUT ${SERVER}/${TYPE}/$(urlencode $DESTINATION_PATH)  $CONFIG  -D $RESPONSE_HEADER -o $RESPONSE_MSG "
    local CURL_FLAGS="-X PUT ${SERVER}/v2/${TYPE}/$(urlencode $DESTINATION_PATH)  $CONFIG  -D $RESPONSE_HEADER -o $RESPONSE_MSG "
    
    if [ "$TYPE" == "dataObject" ]
    then
        if [ -z "$DATAOBJECT_FILE" ]
        then
            curl -F "dataObjectRegistration=$JSON;type=application/json" $CURL_FLAGS -H "Accept: application/json"  2> $HPC_DM_UTILS/temp/curl-status
        else
            curl -F "dataObjectRegistration=$JSON;type=application/json" -F "dataObject=@$DATAOBJECT_FILE;type=application/octet-stream" $CURL_FLAGS  -H "Accept: application/json"  2> $HPC_DM_UTILS/temp/curl-status 
        fi
    elif [ "$TYPE" == "collection" ]
    then
            
           curl -H "Content-Type: application/json" -d @$DESCRIPTION $CURL_FLAGS_COLLECTION  -H "Accept: application/json" 2>$HPC_DM_UTILS/temp/curl-status
    else
        echo "ERROR: Unsupported registration type:$TYPE"
        exit 1
    fi

    check_connection $RESPONSE_HEADER
}


#Print Usage of dm_register_collection function
function dm_show_register_collection_usage {
  read -d  '' usage <<- EOF
  usage: dm_register_collection [-D REST-response] [-o output-file] <description.json> <archive-path>

  Register an empty collection
  [-D REST-response]          Optionally specify the filename to capture the REST response
  [-o output-file]            Optionally specify the filename to capture the error output. This is empty if the command is successful
  [description.json]          Path to the JSON file containing the metadata for the new collection.
  [archive-path]              Destination path in the archive

For detailed information on creating a collection, refer to the following page: 
https://wiki.nci.nih.gov/x/g4JeFw

EOF
  echo "$usage"
}


#Register a collection 
#Inputs:  [-o output-json-file]
#         [-D REST-response]
#         <description.json>: The metadata json file for the collection 
#         <destinaton-path>: The destination logical path
function dm_register_collection {

    local RESPONSE_MSG
    local RESPONSE_HEADER

    while :; do
        case $1 in
            -D|--dump-header)
                if [ "$2" ]; then
                    RESPONSE_HEADER="$2"
                    shift
                else
                    dm_show_register_collection_usage >&2
                    return 1
                fi
            ;;
            -o|--output)
                if [ "$2" ]; then
                    RESPONSE_MSG="$2"
                    shift
                else
                    dm_show_register_collection_usage >&2
                    return 1
                fi
            ;;
            *) break
        esac
        shift
    done

    if [ -z "$1" ] || [ -z "$2" ] 
    then
        dm_show_register_collection_usage >&2
        return
    fi


    local DESCRIPTION="$1"
    local DESTINATION_PATH="$2"

    if [ -z "$RESPONSE_MSG" ]
     then
        RESPONSE_MSG=collection-registration-response-message.json.tmp
    fi
    if [ -z "$RESPONSE_HEADER" ]
    then
        RESPONSE_HEADER=collection-registration-response-header.tmp
    fi

    dm_register -D "$RESPONSE_HEADER" -o "$RESPONSE_MSG" "$DESCRIPTION" "$DESTINATION_PATH" collection || exit 1
    verify_registration "$RESPONSE_HEADER" "$RESPONSE_MSG" "$DESTINATION_PATH"

}



#Print Usage of dm_register_dataobject_presigned function
function dm_show_register_dataobject_presigned_usage {
  read -d  '' usage <<- EOF
  usage: dm_register_dataobject_presigned [-D REST-response] [-o output-file] <description.json> <archive-path> [source-file]

For files larger than 2GB, use dm_register_dataobject_multipart.

  Register a dataobject with pre-signed URL
  [-D REST-response]          Optionally specify the filename to capture the REST response
  [-o output-file]            Optionally specify the filename to capture the error output. This is empty if the command is successful
  description-json            Path to the JSON file containing the metadata for the new dataobject
  archive-path                Destination path in the archive
  [source-file]               Path of the file to upload

For detailed information on this command, refer to the following page: 
https://wiki.nci.nih.gov/x/KohzFw

EOF
  echo "$usage"
}


#Register a dataObject using pre-signed URL
#Inputs:  [-o output-json-file]
#         [-D REST-response]
#         <description.json>: The metadata json file for the dataObject 
#         <destinaton-path>: The destination logical path
#         <source-file>: The source file for synchronous registration.
function dm_register_dataobject_presigned {

    local RESPONSE_MSG
    local RESPONSE_HEADER

    while :; do
        case $1 in
            -D|--dump-header)
                if [ "$2" ]; then
                    RESPONSE_HEADER="$2"
                    shift
                else
                    dm_show_register_dataobject_presigned_usage >&2
                    return 1
                fi
            ;;
            -o|--output)
                if [ "$2" ]; then
                    RESPONSE_MSG="$2"
                    shift
                else
                    dm_show_register_dataobject_presigned_usage >&2
                    return 1
                fi
            ;;
            *) break
        esac
        shift
    done

    if [ "$#" -lt 3 ]
    then
        dm_show_register_dataobject_presigned_usage >&2
        return
    fi

    if [ -z "$RESPONSE_MSG" ]
     then
        RESPONSE_MSG=dataObject-registration-response-message.json.tmp
    fi
    if [ -z "$RESPONSE_HEADER" ]
    then
        RESPONSE_HEADER=dataObject-registration-response-header.tmp
    fi

    local description="$1"
    local destination_path="$2"
    local source_file="$3"
    
    checksum_val=`openssl md5 -binary ${source_file} | base64`
    if [ -z "$checksum_val" ]
    then
     echo "cannot extract checksum of source file" >&2
     return 1
    fi
    
    local description_json=`get_file_value "$description"`
    description_json=$(echo $description_json | sed "s|{|{ \"checksum\": \""${checksum_val}"\",|")

    dm_register -D "$RESPONSE_HEADER" -o "$RESPONSE_MSG" "$description_json" "$destination_path" dataObject 
    if [ "$?" -eq  1 ]
    then
      return 1
    fi

    #verify_registration "$RESPONSE_HEADER" "$RESPONSE_MSG" "$DESTINATION_PATH"
    presigned_url=`get_json_value $RESPONSE_MSG uploadRequestURL`
    if [ -z "$presigned_url" ]
    then
      echo "ERROR: Cannot retrieve the presigned url from $RESPONSE_MSG for $destination_path" >&2
      return 1
    fi

    rm -f $response_header $response_msg 2>/dev/null
    response_header=presignedURL-registration-response-header.tmp
    response_msg=presignedURL-registration-response-message.tmp
    curl -X PUT  -H "Content-Type: application/octet-stream" -H "content-md5: ${checksum_val}" --upload-file ${source_file} "${presigned_url}" -D $response_header -o $response_msg 
    if [ "$?" -ne 0 ]
    then
      echo "Error during presigned URL registration for $destination_path" >&2
      echo "Check the files $response_header and $response_msg" >&2
      return 1
    fi

    rm -f $response_header $response_msg 2>/dev/null
}



#Print Usage of dm_register_dataobject function
function dm_show_register_dataobject_usage {
  read -d  '' usage <<- EOF
  usage: dm_register_dataobject [-D REST-response] [-o output-file] <description.json> <archive-path> [source-file]

  Register a dataobject
  [-D REST-response]          Optionally specify the filename to capture the REST response
  [-o output-file]            Optionally specify the filename to capture the error output. This is empty if the command is successful
  [description-json]          Path to the JSON file containing the metadata and source info for the new dataobject 
  [archive-path]              Destination path in the archive
  [source-file]               Path to the source file for synchronous uploads. Omit the parameter for asynchronous upload (Globus and S3).

For detailed information on registering a data file, refer to the following page: 
https://wiki.nci.nih.gov/x/ARtGFw

EOF
  echo "$usage"
}


#Register a dataObject 
#Inputs:  [-o output-json-file]
#         [-D REST-response]
#         <description.json>: The metadata json file for the dataObject 
#         <destinaton-path>: The destination logical path
#         [source-file]: The source file for synchronous registration.
function dm_register_dataobject {

    local RESPONSE_MSG
    local RESPONSE_HEADER

    while :; do
        case $1 in
            -D|--dump-header)
                if [ "$2" ]; then
                    RESPONSE_HEADER="$2"
                    shift
                else
                    dm_show_register_dataobject_usage >&2
                    return 1
                fi
            ;;
            -o|--output)
                if [ "$2" ]; then
                    RESPONSE_MSG="$2"
                    shift
                else
                    dm_show_register_dataobject_usage >&2
                    return 1
                fi
            ;;
            *) break
        esac
        shift
    done

    if [ -z "$1" ] || [ -z "$2" ] 
    then
        dm_show_register_dataobject_usage >&2
        return
    fi

    if [ -z "$RESPONSE_MSG" ]
     then
        RESPONSE_MSG=dataObject-registration-response-message.json.tmp
    fi
    if [ -z "$RESPONSE_HEADER" ]
    then
        RESPONSE_HEADER=dataObject-registration-response-header.tmp
    fi

    local DESCRIPTION="$1"
    local DESTINATION_PATH="$2"
    local SOURCE_FILE=$3
    dm_register -D "$RESPONSE_HEADER" -o "$RESPONSE_MSG" "$DESCRIPTION" "$DESTINATION_PATH" dataObject $SOURCE_FILE 
    if [ "$?" -eq  1 ]
    then
      return 1
    fi
    verify_registration "$RESPONSE_HEADER" "$RESPONSE_MSG" "$DESTINATION_PATH"
}

#Print Usage of dm_register_dataobject_multipart function
function dm_register_dataobject_multipart_usage {
  read -d  '' usage <<- EOF
  usage: dm_register_dataobject_multipart <description-json> <destination-path> <source-path>

  Register a dataobject using multi-part upload.
  description-json            Path to the JSON file containing the metadata for the new dataobject
  destination-path            Destination path in the archive
  source-path                 Path of the file to upload

For detailed information on this command, refer to the following page: 
https://wiki.nci.nih.gov/x/7AIFGg

EOF
  echo "$usage"
}


#Register a datafile from the archive using the cmd line client.
#Inputs:  <description-json>: JSON file containing the metadata for the new dataobject
#		  <destination-path>: Archive destination folder
#		  <source-path>: The path on the file system 
		  

function dm_register_dataobject_multipart {

    #local USAGE="usage: dm_register_dataobject_multipart <description-json> <destination-path> <source-path>"

    check_java
    if [ "$#" -lt 3 ]
    then
        dm_register_dataobject_multipart_usage >&2
        return
    fi

    while getopts ":" option
    do
      case "${option}" in
        *)
          dm_register_dataobject_multipart_usage >&2
          exit 1
          ;;
      esac
    done
    
    local description="$1"
    local destination_path="$2"
    local source_path="$3"
   
    #Check if the jar exists:
    local jar_file=$(get_jar)
    local jar_path=$HPC_DM_UTILS/hpc-client/$jar_file
    if [ ! -f $jar_path ]
    then
      echo "Cannot find $jar_path " >&2
      return 1
    fi

    command_args=""

    #Pass the mandatory arguments
    command_args+=" --sourceFilePath \"$source_path\" --destinationArchivePath \"$destination_path\" --metadataFile \"$description\""
  
    #Generate the command for the client: 
    local command_file=$HPC_DM_UTILS/temp/cmd-file
    echo "putDatafile  " $command_args >  $command_file

    case "$(uname -s)" in
    
       Darwin|Linux)
        java -Dhpc.client.properties=$HPC_DM_UTILS/hpcdme.properties -DHPC_DM_UTILS=$HPC_DM_UTILS -jar -Dhttp.proxyHost=$PROXY_IP -Dhttp.proxyPort=$PROXY_PORT $jar_path  --cmdfile $command_file
        exit_code="$?"
       ;;
    
       CYGWIN*|MINGW32*|MSYS*)
            java -DHPC_DM_UTILS=$(cygpath -m $HPC_DM_UTILS) -Dhpc.client.properties=$(cygpath -w $HPC_DM_UTILS/hpcdme.properties)  -jar $(cygpath -w $jar_path)  --cmdfile $(cygpath -w $command_file)
        exit_code="$?"
       ;;
    
       *)
         echo 'Current OS not supported' 
         exit 1
         ;;
    esac

    if [ "$exit_code" -eq  "1" ]
    then
      echo "The dataobject registration did not fully complete successfully" >&2
      echo "Check complete log and error files" >&2
      return 1
    fi

}

#Sync a folder in the current file system with a logical path in the Archive
#There is no metadata for folder and they will be automatically created.
#The files metadata is the list of attributes/values pair that are returned by the 
#function "get_json-file"
#Inputs: Globus endpoint
#        Source path on Globus endpoint
#        Destination logical path on Archive.
#<source-folder>    The source folder on the file system
#        <destination-path> The destination logical path
function dm_sync_globus_endpoint  {

    local USAGE="usage: dm_sync_folder <source-folder> <destination-path>"

    if [ -z "$1" ] || [ -z "$2" ] 
    then
        echo "$USAGE" >&2
        return
    fi


    local RESPONSE_HEADER=dataObject-registration-response-header.tmp
    local RESPONSE_MSG=dataObject-registration-response-message.json.tmp


    local FILE_LIST="./test.txt /TEST_Archive/test.txt"

    while read -r  NEW_FILE 
    do 

      local SRC_PATH=$(echo $NEW_FILE | cut -d' ' -f1)
      local DST_PATH=$(echo $NEW_FILE | cut -d' ' -f2)
      local FILE_ATTRIBUTES=$(get_file_attributes $SRC_PATH)      
      local DESC_JSON=$(get_json_description $FILE_ATTRIBUTES)
      echo $DESC_JSON >  temp.json
      echo "dm_register_dataobject  temp.json $DST_PATH $SRC_PATH"
      echo "verify_registration  $REPONSE_HEADER $RESPONSE_MSG $DST_PATH"

      rm -f $RESPONSE_HEADER 2>/dev/null
      rm -f $RESPONSE_MSG 2>/dev/null

    done <<< "$FILE_LIST"

}


#Get an item (collection or dataObject) from the archive
#Inputs: [-o metadata-file]
#        [-D REST-response]
#        <item-path> (should have a prefix of "dataObject" or "collection")
#      : [metadata-file] (for backward compatibility)
#      : [REST-response] (for backward compatibility)
function dm_get_item {

    local USAGE="usage: dm_get_item [-D REST-response] [-o metadata-file] <item-path>"

    local RESPONSE_MSG
    local RESPONSE_HEADER

    while :; do
        case $1 in
            -D|--dump-header)
                if [ "$2" ]; then
                    RESPONSE_HEADER="$2"
                    shift
                else
                    echo "$USAGE" >&2
                    return 1
                fi
            ;;
            -o|--output)
                if [ "$2" ]; then
                    RESPONSE_MSG="$2"
                    shift
                else
                    echo "$USAGE" >&2
                    return 1
                fi
            ;;
            *) break
        esac
        shift
    done

    if [ "$#" -lt 1 ] 
    then
        echo "$USAGE" >&2
        return 1
    fi
    local ITEM_PATH="$1"

    if [ ! -z "$2" ]
    then
      RESPONSE_MSG="$2"
    elif [ -z "$RESPONSE_MSG" ]
    then
      RESPONSE_MSG=get-item-response-message.json.tmp
    fi 

    if [ ! -z "$3" ]
    then
      RESPONSE_HEADER="$3"
    elif [ -z "$RESPONSE_HEADER" ]
    then
      RESPONSE_HEADER=get-item-response-header.tmp
    fi 

    CONFIG=$(get_config) || exit 1
    SERVER=$(get_server) || exit 1

    local TOTAL_PATH="$ITEM_PATH"
    local TOTAL_PATH=$(echo "$TOTAL_PATH" | sed "s#\/\/*#\/#g")
    local ITEM_TYPE="$( cut -d '/' -f 1 <<< "$TOTAL_PATH" )"
    local DME_ARCHIVE_PATH="$( cut -d '/' -f 2- <<< "$TOTAL_PATH" )"
    
    if [ "$ITEM_TYPE" == "dataObject" ]
    then
   		curl -G -X GET "$SERVER/v2/$ITEM_TYPE/$(urlencode $DME_ARCHIVE_PATH)"  $CONFIG  -D $RESPONSE_HEADER -o $RESPONSE_MSG -s 2> $HPC_DM_UTILS/temp/curl-status
    else
    	curl -G -X GET "$SERVER/$ITEM_TYPE/$(urlencode $DME_ARCHIVE_PATH)"  $CONFIG  -D $RESPONSE_HEADER -o $RESPONSE_MSG -s 2> $HPC_DM_UTILS/temp/curl-status 
    fi
    check_connection $RESPONSE_HEADER
}



#Print Usage of dm_get_dataobject function
function dm_show_get_dataobject_usage {
  read -d  '' usage <<- EOF
  usage: dm_get_dataobject [-D REST-response] [-o metadata-file] <dataobject-path>

  Get the metadata of a dataobject
  [-D REST-response]          Optionally specify the filename to capture the REST response.
  [-o metadata-file]          Optionally specify the filename to capture the dataobject metadata. If this is not specified, metadata is printed to standard output
  dataobject-path             Full path of the dataobject in the archive.

For detailed information on this command, refer to the following page: 
https://wiki.nci.nih.gov/x/4A1GFw

EOF
  echo "$usage"
}


#Get the metadata of a dataobject from the archive
#Inputs: [-o metadata-file]
#        [-D REST-response]
#        <dataObject-path> 
#      : [metadata-file] (for backward compatibility)
#      : [REST-response] (for backward compatibility)
function dm_get_dataobject {

    local RESPONSE_MSG
    local RESPONSE_HEADER
	local SHOW_OUTPUT=1

    while :; do
        case $1 in
            -D|--dump-header)
                if [ "$2" ]; then
                    RESPONSE_HEADER="$2"
                    shift
                else
                    dm_show_get_dataobject_usage >&2
                    return 1
                fi
            ;;
            -o|--output)
                if [ "$2" ]; then
                    RESPONSE_MSG="$2"
                    SHOW_OUTPUT=0
                    shift
                else
                    dm_show_get_dataobject_usage >&2
                    return 1
                fi
            ;;
            *) break
        esac
        shift
    done

    while getopts ":" option
    do
      case "${option}" in
        *)
          dm_show_get_dataobject_usage >&2
          exit 1
          ;;
      esac
    done

    if [ "$#" -lt 1 ] 
    then
        dm_show_get_dataobject_usage >&2
        return
    fi
    local ITEM_PATH="$1"


    if [ ! -z "$2" ]
    then
      RESPONSE_MSG="$2"
	  SHOW_OUTPUT=0
    elif [ -z "$RESPONSE_MSG" ]
    then
      RESPONSE_MSG=get-item-response-message.json.tmp
    fi 

    if [ ! -z "$3" ]
    then
      RESPONSE_HEADER="$3"
    elif [ -z "$RESPONSE_HEADER" ]
    then
      RESPONSE_HEADER=get-item-response-header.tmp
    fi 
    
    dm_get_item -o "$RESPONSE_MSG" -D "$RESPONSE_HEADER" dataObject/$ITEM_PATH || exit 1

    local RESPONSE_CODE=$(get_http_code $RESPONSE_HEADER)
    if [ "$RESPONSE_CODE" -ne 200 ]
    then
      echo "Error getting \"$ITEM_PATH\" " >&2
      #echo "ERROR_CODE:\"$RESPONSE_CODE\"" >&2
      print_error_message "$RESPONSE_MSG" "$RESPONSE_CODE"
      exit 1
    else 
     

      if [ $SHOW_OUTPUT -eq 1 ]
      then
        print_json_message "$RESPONSE_MSG"
      fi
      return 0
    fi
}

#Print Usage of dm_get_collection function
function dm_show_get_collection_usage {
  read -d  '' usage <<- EOF
  usage: dm_get_collection [-D REST-response] [-o metadata-file] <collection_path>

  Get the metadata of a collection
  [-D REST-response]          Optionally specify the filename to capture the REST response.
  [-o metadata-file]          Optionally specify the filename to capture the collection metadata. If this is not specified, metadata is printed to standard output
  collection_path             Full path of the collection in the archive.

For detailed information on this command, refer to the following page: 
https://wiki.nci.nih.gov/x/ShdGFw

EOF
  echo "$usage"
}


#Get the metadata of a collection from the archive
#Inputs: [-o metadata-file]
#        [-D REST-response]
#        <collection-path> 
#      : [metadata-file] (for backward compatibility)
#      : [REST-response] (for backward compatibility)
function dm_get_collection {

    #local USAGE="usage: dm_get_collection [-D REST-response] [-o metadata-file] <collection-path>"

    local RESPONSE_MSG
    local RESPONSE_HEADER
	local SHOW_OUTPUT=1

    while :; do
        case $1 in
            -D|--dump-header)
                if [ "$2" ]; then
                    RESPONSE_HEADER="$2"
                    shift
                else
                    dm_show_get_collection_usage >&2
                    return 1
                fi
            ;;
            -o|--output)
                if [ "$2" ]; then
                    RESPONSE_MSG="$2"
	            SHOW_OUTPUT=0
                    shift
                else
                    dm_show_get_collection_usage >&2
                    return 1
                fi
            ;;
            *) break
        esac
        shift
    done

    while getopts ":" option
    do
      case "${option}" in
        *)
          dm_show_get_collection_usage >&2
          exit 1
          ;;
      esac
    done


    if [ "$#" -lt 1 ] 
    then
        dm_show_get_collection_usage >&2
        return
    fi
    local ITEM_PATH="$1"


    if [ ! -z "$2" ]
    then
      RESPONSE_MSG="$2"
	  SHOW_OUTPUT=0
    elif [ -z "$RESPONSE_MSG" ]
    then
      RESPONSE_MSG=get-item-response-message.json.tmp
    fi 

    if [ ! -z "$3" ]
    then
      RESPONSE_HEADER="$3"
    elif [ -z "$RESPONSE_HEADER" ]
    then
      RESPONSE_HEADER=get-item-response-header.tmp
    fi 

    dm_get_item -o "$RESPONSE_MSG"  -D "$RESPONSE_HEADER" collection/$ITEM_PATH || exit 1

    local RESPONSE_CODE=$(get_http_code $RESPONSE_HEADER)
    if [ "$RESPONSE_CODE" -ne 200 ]
    then
      echo "Error getting \"$ITEM_PATH\" " >&2
      print_error_message "$RESPONSE_MSG" "$RESPONSE_CODE"
      exit 1
    else 
     

      if [ $SHOW_OUTPUT -eq 1 ]
      then
        print_json_message "$RESPONSE_MSG"    
      fi
    fi
}


#Print Usage of dm_query_dataobject function
function dm_show_query_dataobject_usage {
read -d  '' usage <<- EOF
usage: dm_query_dataobject [-D REST-response] [-o output-file] <criteria.json> [search-path]

Search for dataobjects based on the given compound query and optional search path.
OPTIONS:
[-D REST-response]          Optionally specify the filename to capture the REST response
[-o output-file]            Optionally specify the filename to capture the query output
<criteria.json>             JSON file containing the compound query for the search
[search-path]               Optionally specify the collection path to search in


For detailed information on this command, refer to the following page: 
https://wiki.nci.nih.gov/x/7QRuG

EOF
echo "$usage"
}


#Get the metadata of a dataobject from the archive
#Inputs: [-D REST-responsea]
#        [-o metadata-file]
#        <criteria.json>
#        [search-path]
function dm_query_dataobject {

local RESPONSE_MSG
local RESPONSE_HEADER
local SHOW_OUTPUT=1

while :; do
case $1 in
    -D|--dump-header)
        if [ "$2" ]; then
            RESPONSE_HEADER="$2"
            shift
        else
            dm_show_query_dataobject_usage >&2
                    return 1
        fi
        ;;
    -o|--output)
        if [ "$2" ]; then
           RESPONSE_MSG="$2"
           SHOW_OUTPUT=0
           shift
        else
           dm_show_query_dataobject_usage >&2
           return 1
        fi
        ;;
        *) break
        esac
        shift
    done

    while getopts ":" option
    do
      case "${option}" in
        *)
          dm_show_query_dataobject_usage >&2
          exit 1
          ;;
      esac
    done

    if [ "$#" -lt 1 ]
    then
      dm_show_query_dataobject_usage >&2
      return 1
     fi
    local CRITERIA="$1"

    if [ ! -f $CRITERIA ]
    then
      echo "ERROR: Cannot find $CRITERIA " >&2
      return 1
    fi



    if [ ! -z "$2" ]
    then
      local SEARCH_PATH="$2"
      local VALDN_RES=$(validate_archive_path "$SEARCH_PATH")
      if [ "" != "$VALDN_RES" ]
      then
          echo "$VALDN_RES" >&2
          return 1
      fi
    fi


    if [ -z "$RESPONSE_MSG" ]
     then
        RESPONSE_MSG=query-dataobject-response-message.json.tmp
    fi
    if [ -z "$RESPONSE_HEADER" ]
    then
        RESPONSE_HEADER=query-dataobject-response-header.tmp
    fi

    SERVER=$(get_server) || exit 1
    CONFIG=$(get_config) || exit 1

    if [ -z "$SEARCH_PATH" ]
    then
      local CURL_FLAGS="-X POST ${SERVER}/dataObject/query  $CONFIG  -D $RESPONSE_HEADER -o $RESPONSE_MSG "
    else
      local CURL_FLAGS="-X POST ${SERVER}/dataObject/query/$(urlencode $SEARCH_PATH)  $CONFIG  -D $RESPONSE_HEADER -o $RESPONSE_MSG "
    fi 

    curl -H "Content-Type: application/json" -d @$CRITERIA $CURL_FLAGS -H "Accept: application/json" 2> $HPC_DM_UTILS/temp/curl-status

    #Process response
    local RESPONSE_CODE=$(get_http_code $RESPONSE_HEADER)
    if [ "$RESPONSE_CODE" -ne 200 ]
    then
      echo "Error querying dataobjects " >&2
      print_error_message "$RESPONSE_MSG" "$RESPONSE_CODE"
    else
      print_json_message "$RESPONSE_MSG" > ${RESPONSE_MSG}.tmp
      mv ${RESPONSE_MSG}.tmp $RESPONSE_MSG
      if [ $SHOW_OUTPUT -eq 1 ]
      then
        cat "$RESPONSE_MSG"
      fi
      return 0
    fi

}


#Print Usage of dm_download_dataobject function
function dm_show_download_dataobject_usage {
  read -d  '' usage <<- EOF

  usage: dm_download_dataobject [-D REST-response] [-f json-file] <source-path> <destination-file>

  Download the specified dataobject to the local machine.
  [-D REST-response]     Optionally specify the filename to capture the REST response
  [-f json-file]         Optionally specify the json file for specifying download filter
  source_path            Full path to the source file in the archive
  destination-file       The location for the destination file

For detailed information on this command, refer to the following page:
https://wiki.nci.nih.gov/x/owRlGQ

EOF
  echo "$usage"
}


#Download a dataObject synchronously 
#Inputs: [-D REST-response]
#        [-f json-file]
#        [-p]
#        logic-path 
#        destination-file
function dm_download_dataobject {
  #local USAGE="usage: dm_download_dataobject [-D REST-response] [-f json-file] [-p] <logic-path> <destination-file>\n   -p indicates to use S3-presigned URL for downloading"

  #Set the default parameters
  local APPLY_PRESIGNED=0
  local TEMPLATE
  local RESPONSE_HEADER
  local template_file

  while :; do
        case $1 in
            -D|--dump-header)
                if [ "$2" ]; then
                    RESPONSE_HEADER="$2"
                    shift
                else
                    dm_show_download_dataobject_usage >&2 
                    return 1
                fi
            ;;
            -f|--file)
            	if [ "$2" ]; then
                	template_file="$2"
                	shift
                else
                	dm_show_download_dataobject_usage >&2 
                	return 1
                fi
            ;;
            -p)
                APPLY_PRESIGNED=1
                TEMPLATE="$HPC_DM_UTILS/templates/download-sync-presigned-template-internal.json"
            ;;
            *) break
        esac
        shift
  done

  if [ $APPLY_PRESIGNED -eq 0 ]
  then
    if [ ! -e "$template_file" ]
    then
        printf '{\n}' > $HPC_DM_UTILS/templates/download-sync-template.json.tmp
        TEMPLATE="$HPC_DM_UTILS/templates/download-sync-template.json.tmp"
    else
    	TEMPLATE="$template_file"
    fi
    echo $TEMPLATE
  fi

  if [ "$#" -lt 2 ] 
  then
    dm_show_download_dataobject_usage >&2
    return 1
  fi
  local OBJECT_PATH="$1"
  local DESTINATION_PATH="$2"
  if [ -d "$DESTINATION_PATH"  ]
  then
    #Download the file with the same file name
    local FILE_NAME=$(basename "$OBJECT_PATH")
    if [ "$?" -ne 0 ]
    then
      echo "ERROR: Cannot retrieve the file name from \"$OBJECT_PATH\"" >&2
      return 1
    fi
    local DESTINATION_PATH=$DESTINATION_PATH/${FILE_NAME}
  fi
  local CONFIG=$(get_config)
  local SERVER=$(get_server)
  local CODE=0
  if [ -z "$RESPONSE_HEADER" ]
    then
      RESPONSE_HEADER=download-dataobject-response-header.tmp
  fi 
  if [ $APPLY_PRESIGNED -eq 0 ]
  then
    curl -H "Content-Type: application/json" -H "Accept: application/json" \
      $CONFIG -d @$TEMPLATE \
      -X POST ${SERVER}/v2/dataObject/$(urlencode $OBJECT_PATH)/download \
      -D $RESPONSE_HEADER -o $DESTINATION_PATH -s \
      2> $HPC_DM_UTILS/temp/curl-status
    check_connection $RESPONSE_HEADER
    CODE=$(get_http_code "$RESPONSE_HEADER")
    rm -f $HPC_DM_UTILS/templates/download-sync-template.json.tmp
    if [ "$CODE" -ne 200 ]
    then 
      #In this case the destination path file will contain the error code
      print_error_message "$DESTINATION_PATH" "$CODE" 
    fi
  else
    local RESPONSE_HEADER_OBTAIN_PRESIGNED=obtain-presigned-url-response-header.tmp
    local RESPONSE_MESSAGE_OBTAIN_PRESIGNED=obtain-presigned-url-response-message.tmp

    curl -H "Content-Type: application/json" -H "Accept: application/json" \
      $CONFIG -d @$TEMPLATE \
      -X POST ${SERVER}/v2/dataObject/$(urlencode $OBJECT_PATH)/download \
      -D $RESPONSE_HEADER_OBTAIN_PRESIGNED \
      -o $RESPONSE_MESSAGE_OBTAIN_PRESIGNED \
      -s 2> $HPC_DM_UTILS/temp/curl-status

    check_connection $RESPONSE_HEADER_OBTAIN_PRESIGNED

    CODE=$(get_http_code "$RESPONSE_HEADER_OBTAIN_PRESIGNED")
    if [ "$CODE" -ne 200 ]
    then
      if [ "$CODE" -eq 400 ]
      then
        print_error_message $RESPONSE_MESSAGE_OBTAIN_PRESIGNED 400
      else
        >&2 echo "Request to obtain presigned URL failed.  See response data below."
        >&2 echo "( Response data is also available in the following 2 files: "
        >&2 echo "  1. $(pwd)/$RESPONSE_HEADER_OBTAIN_PRESIGNED"
        >&2 echo "  2. $(pwd)/$RESPONSE_MESSAGE_OBTAIN_PRESIGNED"
        >&2 echo ")"
        >&2 echo ""
        >&2 cat $RESPONSE_HEADER_OBTAIN_PRESIGNED
        >&2 cat $RESPONSE_MESSAGE_OBTAIN_PRESIGNED
      fi
    else 
      local PRESIGNED_URL=$(get_json_value  $RESPONSE_MESSAGE_OBTAIN_PRESIGNED  downloadRequestURL)
      if [ -z "$PRESIGNED_URL" ]
      then
        >&2 echo "Request to obtain presigned URL was successfully processed, but response is missing the URL.  See response data below."
        >&2 echo "( Response data is also available in the following 2 files: "
        >&2 echo "  1. $(pwd)/$RESPONSE_HEADER_OBTAIN_PRESIGNED"
        >&2 echo "  2. $(pwd)/$RESPONSE_MESSAGE_OBTAIN_PRESIGNED"
        >&2 echo ")"
        >&2 echo ""
        >&2 cat $RESPONSE_HEADER_OBTAIN_PRESIGNED
        >&2 cat $RESPONSE_MESSAGE_OBTAIN_PRESIGNED
      else
        curl -X GET $PRESIGNED_URL -D $RESPONSE_HEADER -o $DESTINATION_PATH -s 2> $HPC_DM_UTILS/temp/curl-status
        check_connection $RESPONSE_HEADER

        CODE=$(get_http_code "$RESPONSE_HEADER")
        if [ "$CODE" -ne 200 ]
        then 
          >&2 echo "Failed to download file from obtained presigned URL.  See response data below."
          >&2 echo "  ( Response data from request available in file $DESTINATION_PATH. )"
          >&2 echo ""
          >&2 cat $RESPONSE_HEADER
          >&2 cat $DESTINATION_PATH
        fi
      fi
    fi
  fi
}


#Print Usage of dm_download_dataobject_presigned function
function dm_show_download_dataobject_presigned_usage {
  read -d  '' usage <<- EOF
  
  usage: dm_download_dataobject_presigned [-D REST-response] <source-path> <destination-file>

  Download the specified dataobject to the local machine using presigned URL.
  [-D REST-response]     Optionally specify the filename to capture the REST response
  source_path            Full path to the source file in the archive
  destination-file       The location for the destination file

For detailed information on this command, refer to the following page:
https://wiki.nci.nih.gov/x/PwMFGg

EOF
  echo "$usage"
}


#Download a dataObject to the local machine using presigned URL
#Inputs: [-D REST-response]
#        [-p]
#        logic-path
#        destination-file
function dm_download_dataobject_presigned {

  #Set the default parameters
  local TEMPLATE="$HPC_DM_UTILS/templates/download-sync-presigned-template-internal.json"
  local RESPONSE_STATUS

  while :; do
        case $1 in
            -D|--dump-header)
                if [ "$2" ]; then
                    RESPONSE_STATUS="$2"
                    shift
                else
                    dm_show_download_dataobject_presigned_usage >&2
                    return 1
                fi
            ;;
            *) break
        esac
        shift
  done

  if [ "$#" -lt 2 ] || [ "$#" -gt 4 ]
  then
    dm_show_download_dataobject_presigned_usage >&2
    return 1
  fi
  local OBJECT_PATH="$1"
  local DESTINATION_PATH="$2"
  if [ -d "$DESTINATION_PATH"  ]
  then
    #Download the file with the same file name
    local FILE_NAME=$(basename "$OBJECT_PATH")
    if [ "$?" -ne 0 ]
    then
      echo "ERROR: Cannot retrieve the file name from \"$OBJECT_PATH\"" >&2
      return 1
    fi
    local DESTINATION_PATH=$DESTINATION_PATH/${FILE_NAME}
  fi
  local CONFIG=$(get_config)
  local SERVER=$(get_server)
  local CODE=0
  local SUFFIX=`date +"%Y%m%d%H%M%S"_$RANDOM`
  if [ -z "$RESPONSE_STATUS" ]
    then
      RESPONSE_STATUS=download-dataobject-response-header-$SUFFIX.tmp
  fi
  
  
  local RESPONSE_HEADER_OBTAIN_PRESIGNED=obtain-presigned-url-response-header-$SUFFIX.tmp
  local RESPONSE_MESSAGE_OBTAIN_PRESIGNED=download-dataobject-response-message-$SUFFIX.tmp
  local RESPONSE_MESSAGE=download-dataobject-response-message-$SUFFIX.tmp

  curl -H "Content-Type: application/json" -H "Accept: application/json" \
      $CONFIG -d @$TEMPLATE \
      -X POST ${SERVER}/dataObject/$(urlencode $OBJECT_PATH)/download \
      -D $RESPONSE_HEADER_OBTAIN_PRESIGNED \
      -o $RESPONSE_MESSAGE_OBTAIN_PRESIGNED \
      -s 2> $HPC_DM_UTILS/temp/curl-status

  check_connection $RESPONSE_HEADER_OBTAIN_PRESIGNED

  CODE=$(get_http_code "$RESPONSE_HEADER_OBTAIN_PRESIGNED")
  if [ "$CODE" -ne 200 ]
  then
    if [ "$CODE" -eq 400 ]
    then
      print_error_message $RESPONSE_MESSAGE_OBTAIN_PRESIGNED 400
    else
      >&2 echo "Request to obtain presigned URL failed.  See response data below."
      >&2 echo "( Response data is also available in the following 2 files: "
      >&2 echo "  1. $(pwd)/$RESPONSE_HEADER_OBTAIN_PRESIGNED"
      >&2 echo "  2. $(pwd)/$RESPONSE_MESSAGE_OBTAIN_PRESIGNED"
      >&2 echo ")"
      >&2 echo ""
      >&2 cat $RESPONSE_HEADER_OBTAIN_PRESIGNED
      >&2 cat $RESPONSE_MESSAGE_OBTAIN_PRESIGNED
    fi
  else
    local PRESIGNED_URL=$(get_json_value  $RESPONSE_MESSAGE_OBTAIN_PRESIGNED  downloadRequestURL)
    if [ -z "$PRESIGNED_URL" ]
    then
      >&2 echo "Request to obtain presigned URL was successfully processed, but response is missing the URL.  See response data below."
      >&2 echo "( Response data is also available in the following 2 files: "
      >&2 echo "  1. $(pwd)/$RESPONSE_HEADER_OBTAIN_PRESIGNED"
      >&2 echo "  2. $(pwd)/$RESPONSE_MESSAGE_OBTAIN_PRESIGNED"
      >&2 echo ")"
      >&2 echo ""
      >&2 cat $RESPONSE_HEADER_OBTAIN_PRESIGNED
      >&2 cat $RESPONSE_MESSAGE_OBTAIN_PRESIGNED
    else
      curl -X GET $PRESIGNED_URL -D $RESPONSE_STATUS -o $DESTINATION_PATH -s 2> $HPC_DM_UTILS/temp/curl-status
      check_connection $RESPONSE_STATUS

      CODE=$(get_http_code "$RESPONSE_STATUS")
      if [ "$CODE" -ne 200 ]
      then 
		mv ${DESTINATION_PATH} $RESPONSE_MESSAGE
        >&2 echo "Failed to download file from obtained presigned URL.  See response data below."
        >&2 echo "  ( Response data from request available in file $RESPONSE_MESSAGE. )"
        >&2 echo ""
        >&2 cat $RESPONSE_STATUS
        >&2 cat $RESPONSE_MESSAGE
      else
        rm -f $RESPONSE_HEADER_OBTAIN_PRESIGNED $RESPONSE_MESSAGE_OBTAIN_PRESIGNED  2>/dev/null
      fi
    fi
  fi
}



#Print Usage of dm_delete_datafile function
function dm_show_delete_datafile_usage {
  read -d  '' usage <<- EOF
  usage: dm_delete_datafile <file-path>

  Delete the file at the specified path.
  
  OPTIONS:
  -f                      Force delete. This perform a hard delete and permanently deletes the file.

For detailed information on this command, refer to the following page: 
https://wiki.nci.nih.gov/x/_xpGFw

EOF
  echo "$usage"
}


#Delete a datafile from the archive using the cmd line client.
#Inputs:  <file-path>: The path on the file system 

function dm_delete_datafile {

    #local USAGE="usage: dm_delete_datafile <file-path>"

    check_java
    if [ "$?" -ne 0 ]
    then 
      return 1
    fi

  #set default parameters
  force=false
   while :; do
        case $1 in
            -D|--dump-header)
                if [ "$2" ]; then
                    RESPONSE_HEADER="$2"
                    shift
                else
                    dm_show_delete_datafile_usage >&2
                    return 1
                fi
            ;;
            -f|--force)
              force=true
            ;;
            *) break
        esac
        shift
    done


    if [ -z "$1" ]
    then
        dm_show_delete_datafile_usage >&2
        exit 1
    fi
    
    local file_path="$1"
   
    #Check if the jar exists:
    local jar_file=$(get_jar)
    local jar_path=$HPC_DM_UTILS/hpc-client/$jar_file
    if [ ! -f $jar_path ]
    then
      echo "Cannot find $jar_path " >&2
      return 1
    fi

    command_args=""

    #Pass the mandatory arguments
    command_args+=" --path \"$file_path\" "
 
    #Pass the optional ones
    command_args+=" --force $force "
 
    #Generate the command for the client: 
    local command_file=$HPC_DM_UTILS/temp/cmd-file
    echo "deleteDatafile  " $command_args >  $command_file

    case "$(uname -s)" in
    
       Darwin|Linux)
        java -Dhpc.client.properties=$HPC_DM_UTILS/hpcdme.properties -DHPC_DM_UTILS=$HPC_DM_UTILS -jar -Dhttp.proxyHost=$PROXY_IP -Dhttp.proxyPort=$PROXY_PORT $jar_path  --cmdfile $command_file
        exit_code="$?"
       ;;
    
       CYGWIN*|MINGW32*|MSYS*)
            java -DHPC_DM_UTILS=$(cygpath -m $HPC_DM_UTILS) -Dhpc.client.properties=$(cygpath -w $HPC_DM_UTILS/hpcdme.properties)  -jar $(cygpath -w $jar_path)  --cmdfile $(cygpath -w $command_file)
        exit_code="$?"
       ;;
    
       *)
         echo 'Current OS not supported' 
         exit 1
         ;;
    esac

    if [ "$exit_code" -eq  "1" ]
    then
      echo "The datafile deletion did not fully complete successfully" >&2
      echo "Check complete log and error files" >&2
      return 1
    fi

}

#Print Usage of dm_delete_collection function
function dm_show_delete_collection_usage {
  read -d  '' usage <<- EOF
  usage: dm_delete_collection [OPTIONS] <collection-path> 

  Delete the collection at the specified path. 
  OPTIONS:
  -r                      Recursive delete. This will delete all the files and sub-collections under the specified collection recursively. 
  -f                      Force delete. This performs a hard delete and permanently deletes the collection.

For detailed information on this command, refer to the following page: 
https://wiki.nci.nih.gov/x/zR5GFw

EOF
  echo "$usage"
}

#Delete a collection from the archive using the cmd line client.
#Inputs:  <source-path>: The path on the file system 

function dm_delete_collection {

    #local USAGE="usage: dm_delete_collection <collection-path>"
    #local OPTIND
    
    #Set the default parameters
    numthreads=1
    recursive=false
    force=false


 while :; do
        case $1 in
            -D|--dump-header)
                if [ "$2" ]; then
                    RESPONSE_HEADER="$2"
                    shift
                else
                    dm_show_delete_collection_usage >&2
                    return 1
                fi
            ;;
            -r|--recursive)
                recursive=true
            ;;
            -f|--force)
                force=true
            ;;
            *) break
        esac
        shift
    done


    if [ -z "$1" ]
    then
        dm_show_delete_collection_usage >&2
        exit 1
    fi


    local collection_path="$1"

    #Check if the jar exists:
    local jar_file=$(get_jar)
    local jar_path=$HPC_DM_UTILS/hpc-client/$jar_file
    if [ ! -f $jar_path ]
    then
       echo "Cannot find $jar_path " >&2
       return 1
     fi

    command_args=""

    #Pass the mandatory arguments
    command_args+="--path \"$collection_path\" "

    #Pass the optional ones
    command_args+="--recursive $recursive "
    command_args+="--force $force "

    #Generate the command for the client: 
    local command_file=$HPC_DM_UTILS/temp/cmd-file
    echo "deleteCollection  " $command_args >  $command_file

    case "$(uname -s)" in
    
       Darwin|Linux)
        java -Dhpc.client.properties=$HPC_DM_UTILS/hpcdme.properties -DHPC_DM_UTILS=$HPC_DM_UTILS -Dhttp.proxyHost=$PROXY_IP -Dhttp.proxyPort=$PROXY_PORT -jar $jar_path  --cmdfile $command_file
        exit_code="$?"
       ;;
    
       CYGWIN*|MINGW32*|MSYS*)
            java -DHPC_DM_UTILS=$(cygpath -m $HPC_DM_UTILS) -Dhpc.client.properties=$(cygpath -w $HPC_DM_UTILS/hpcdme.properties)  -jar $(cygpath -w $jar_path)  --cmdfile $(cygpath -w $command_file)
        exit_code="$?"
       ;;
    
       *)
         echo 'Current OS not supported' 
         exit 1
         ;;
    esac

    if [ "$exit_code" -eq  "1" ]
    then
      echo "The collection deletion did not fully complete successfully" >&2
      echo "Check complete log and error files" >&2
      return 1
    fi
}



#Print Usage of dm_register_directory function
function dm_show_register_directory_usage {
  read -d  '' usage <<- EOF
  usage: dm_register_directory [OPTIONS]  <source-path> <destination-path> 

  Recursively copy all files in the <source-path> to the archive's <destination-path>. 
  Metadata can be provided for every directory and file in a specific metadata file called <[directory,filename]>.metadata.json. The metadata file should exist in the same path in its corresponding directory/file. For example, the metadata for the file data.txt should be data.txt.metadata.json
  OPTIONS:
  -c                      Turn on checksum calculation. 
  -d                      Print the files to be included in registration and exit 
  -e[EXCLUDE_FILE_PATH]   Exclude the files that match the patterns specified in the file EXCLUDE_FILE_PATH
  -i[INCLUDE_FILE_PATH]   Include the files that match at least one of the patterns specified in INCLUDE_FILE_PATH
  -l[FILES_LIST]          Register the files mentioned in the FILE_LIST only. Each line in the FILES_LIST file contains a relative path to the source-path.
                          All collections should be registered before using this option.
  -m                      Register metadata only. Do not register files.
  -x                      Extract metadata automatically from files.
  -s                      Skip confirmation prompt and register directly
  -h                      Print this message 
  -t[NUM_THREADS]         The number of threads to use while uploading files to the archive. This number should be between [1, 32].


For detailed information on this command, refer to the following page: 
https://wiki.nci.nih.gov/x/-xpGFw

EOF
  echo "$usage"
}


#Register a directory from a file system using the cmd line client.
#Inputs:  <source-path>: The path on the file system 
#         <destinaton-path>: The destination logical path on the archive
function dm_register_directory {

    #local USAGE="USAGE: dm_register_directory <source-path> <destination-path>"
    local OPTIND
    
    #Set the default parameters
    numthreads=1
    archiveType=S3
    checksum=false

    while getopts ":a:b:cde:i:l:hmp:st:x" option
    do
      case "${option}" in
        a)
          archiveType="${OPTARG}"
          if [ "$archiveType" != "S3" ] && [ "$archiveType" != "POSIX" ]
          then
            echo "ERROR: The archive type can be either \"S3\" or \"POSIX\". Recevied:\"$archiveType\"" >&2
            exit 1 
          fi
          ;;
        c)
          checksum=true
          ;;

        d)
          dry_run=1
          echo "Running dry, no registration will take place."
          ;;
        e)
          exclude_option=1
          exclude_file="${OPTARG}"
          if [ ! -e "$exclude_file" ]
          then
            echo "ERROR: The exclude file $exclude_file does not exist" >&2
            exit 1
          fi
          ;;
        i)
          include_option=1
          include_file="${OPTARG}"
          if [ ! -e "$include_file" ]
          then
            echo "ERROR: The include file $include_file does not exist" >&2
            exit 1
          fi
          ;;
        l)
          file_list=1
          list_of_files="${OPTARG}"
          if [ ! -e "$list_of_files" ]
          then
            echo "ERROR: The FILES_LIST $list_of_files does not exist" >&2
            exit 1
          fi
          ;;
        m)
          metadata_only=1
          ;;
        x)
          extract_metadata=1
          ;;
        s)
          skip_confirmation=1
          ;;
        h)
          dm_show_register_directory_usage 
          exit 1
          ;;
        t)
          numthreads="${OPTARG}"
          re='^[0-9]+$'
          if ! [[ "$numthreads" =~ $re ]] ; then
             echo "ERROR: The number of threads $numthreads is not a positive integer." >&2; exit 1
          fi

          if [ "$numthreads" -lt "0" ] || [ "$numthreads" -gt "32" ]
          then
             echo "ERROR: The number of threads $numthreads should be between [1, 32]" >&2; exit 1
          fi
          ;;
        *)
          dm_show_register_directory_usage >&2
          exit 1
          ;;
      esac
    done

    shift $(( OPTIND-1 ))   

    check_java
    if [ "$?" -ne 0 ]
    then 
      return 1
    fi
    if [ -z "$1" ] || [ -z "$2" ] 
    then
        dm_show_register_directory_usage >&2
        exit 1 
    fi

    local src_path="$1"
    local dst_path="$2"

	case "$(uname -s)" in
	    Linux|CYGWIN*|MINGW32*|MSYS*)
	      src_path=$(readlink -f "$1")
	    ;;
	esac
	
    #Check if the jar exists:
    local jar_file=$(get_jar)
    local jar_path=$HPC_DM_UTILS/hpc-client/$jar_file
    if [ ! -f $jar_path ]
    then
      echo "Cannot find $jar_path " >&2
      return 1
    fi

    #Make sure the source directory exists:
    if [ ! -d "$src_path" ]
    then
      echo "The source directory: $src_path does not exist." >&2
      exit 1
    fi 

    command_args=""

    #Pass the mandatory arguments
    full_src_path=$(myreadlink $src_path)
    full_src_path_converted=$(convert_path "$full_src_path")
    command_args+=" --sourceFilePath \"$full_src_path_converted\" "

    command_args+=" --destinationArchivePath \"$dst_path\" "

    #Pass the options related to files that will be registered. 
  
    if [ $file_list ]
    then
      list_of_files_converted=$(convert_path "$list_of_files")
      command_args+=" --sourceFileList \"${list_of_files_converted}\" "
    else
     #Get the include path
      if [ "$include_option" ] 
      then
        full_include_path=$(myfilereadlink "$include_file")
        full_include_path_converted=$(convert_path "$full_include_path")
        command_args+=" --includePatternFile \"${full_include_path_converted}\" "
      fi
  
      #Get the exclude path
      if [ "$exclude_option" ] 
      then
        full_exclude_path=$(myfilereadlink "$exclude_file")
        full_exclude_path_converted=$(convert_path "$full_exclude_path")
        command_args+=" --excludePatternFile \"${full_exclude_path_converted}\" "
      fi
    fi 

    if [ "$dry_run" ]
    then
      command_args+=" --dryRun true"
    fi

    if [ ! "$skip_confirmation" ]
    then
      command_args+=" --confirm true "
    else  
      command_args+=" --confirm false "
    fi

    if [ "$metadata_only" ]
    then
      command_args+=" --metadataOnly true "
    fi

	if [ "$extract_metadata" ]
    then
      command_args+=" --extractMetadata true "
    fi
	
    #Add all other options
    command_args+=" --threads $numthreads"
    command_args+=" --archiveType $archiveType"
    command_args+=" --checksum $checksum"

    #Generate the command for the client: 
    local command_file=$HPC_DM_UTILS/temp/cmd-file
    echo "registerFromFilePath  " $command_args >  $command_file

    case "$(uname -s)" in
    
       Darwin|Linux)
        java -Dhpc.client.properties=$HPC_DM_UTILS/hpcdme.properties -DHPC_DM_UTILS=$HPC_DM_UTILS -Dhttp.proxyHost=$PROXY_IP -Dhttp.proxyPort=$PROXY_PORT -jar $jar_path  --cmdfile $command_file
        exit_code="$?"
       ;;
    
       CYGWIN*|MINGW32*|MSYS*)
            java -DHPC_DM_UTILS=$(cygpath -m $HPC_DM_UTILS) -Dhpc.client.properties=$(cygpath -w $HPC_DM_UTILS/hpcdme.properties)  -jar $(cygpath -w $jar_path)  --cmdfile $(cygpath -w $command_file)
        exit_code="$?"
       ;;
    
       # Add here more strings to compare
       # See correspondence table at the bottom of this answer
    
       *)
         echo 'Current OS not supported' 
         exit 1
         ;;
    esac

    if [ "$exit_code" -eq  "1" ]
    then
      echo "The batch registration did not fully complete successfully" >&2
      return 1
    fi

}


#Print Usage of dm_register_globus_directory function
function dm_show_register_globus_directory_usage {
  read -d  '' usage <<- EOF
  usage: dm_register_globus_directory [OPTIONS]  <source-path> <destination-path> [endpoint]

  Recursively copy all files in the Globus <source-path> to the archive's <destination-path>. If endpoint is not passed, the default Globus endpoint in hpcdme.properties file will be used.
  OPTIONS:
  -d                      Print the files to be included in registration and exit 
  -e[EXCLUDE_FILE_PATH]   Exclude the files that match the patterns specified in the file EXCLUDE_FILE_PATH
  -i[INCLUDE_FILE_PATH]   Include the files that match at least one of the patterns specified in INCLUDE_FILE_PATH
  -p[PATTERN_TYPE]        The type of the regex pattern in the include/exclude files. Valid options are "Simple" and "RegEx". The default pattern is "Simple"
  -h                      Print this message 
  
EOF
  read -d  '' message <<- EOF
dm_register_globus_directory has been deprecated. Use Bulk Data Files Registration (V2) API.
  
EOF
  echo "$message"
}




#Register a directory from a Globus endpoint using the cmd line client.
#By default the endpoint specified in hpcdme.properties will be used
#Inputs:  <source-path>: The path on the Globus endpoint 
#         <destinaton-path>: The destination logical path on the archive
#         [globus-endpoint]: The Globus endpoint to use other that default
function dm_register_globus_directory {

    local OPTIND

    #Set the default parameters
    patternType=Simple

    while getopts ":de:i:hp:t:" option
    do
      case "${option}" in
        d)
          dry_run=1
          echo "Running dry, no registration will take place."
          ;;
        e)
          exclude_option=1
          exclude_file="${OPTARG}"
          if [ ! -e "$exclude_file" ]
          then
            echo "ERROR: The exclude file $exclude_file does not exist" >&2
            exit 1
          fi
          ;;
        i)
          include_option=1
          include_file="${OPTARG}"
          if [ ! -e "$include_file" ]
          then
            echo "ERROR: The include file $include_file does not exist" >&2
            exit 1
          fi
          ;;
        p)
          patternType="${OPTARG}"
          if [ "$patternType" != "Simple" ] && [ "$patternType" != "RegEx" ]
          then
            echo "ERROR: The include/exclude pattern type can be either \"Simple\" or \"RegEx\". Recevied:\"$patternType\"" >&2
            exit 1 
          fi
          ;;
        h)
          dm_show_register_globus_directory_usage >&2
          exit 1
          ;;
        *)
          dm_show_register_globus_directory_usage >&2
          exit 1
          ;;
      esac
    done

    shift $(( OPTIND-1 ))   

    check_java
    if [ "$?" -ne 0 ]
    then 
      return 1
    fi
    if [ -z "$1" ] || [ -z "$2" ] 
    then
        dm_show_register_globus_directory_usage >&2
        exit 1 
    fi

    local src_path="$1"
    local dst_path="$2"

    #Check if the jar exists:
    local jar_file=$(get_jar)
    local jar_path=$HPC_DM_UTILS/hpc-client/$jar_file
    if [ ! -f $jar_path ]
    then
      echo "Cannot find $jar_path " >&2
      return 1
    fi

    local globus_endpoint
    if [ -z "$3" ]
    then
      #echo "Using the default Globus endpoint in $HPC_DM_UTILS/hpcdme.properties" 
      globus_endpoint=$(get_globus_endpoint)
      if [ "$?" -ne 0 ]
      then
        echo  "ERROR: Cannot find the default Globus endpoint in the properties file." >&2
        exit 1
      fi
    else
      globus_endpoint="$3"
    fi       

    command_args=""
    #Get the include path
    if [ "$include_option" ]
    then
      full_include_path=$(myfilereadlink "$include_file")
      command_args+=" --includePatternFile \"$full_include_path\""
    fi

    #Get the exclude path
    if [ "$exclude_option" ]
    then
      full_exclude_path=$(myfilereadlink "$exclude_file")
      command_args+=" --excludePatternFile \"$full_exclude_path\""
    fi

    if [ "$dry_run" ]
    then
      command_args+=" --dryRun true"
    fi

    #Add all other options
    command_args+=" --patternType $patternType"

    #Generate the command for the client: 
    local command_file=$HPC_DM_UTILS/temp/cmd-file
    echo "registerFromGlobusPath --globusEndpoint $globus_endpoint --globusSourcePath $src_path --destinationArchivePath $dst_path" $command_args >  $command_file

    
    case "$(uname -s)" in
    
       Darwin|Linux)
        java -Dhpc.client.properties=$HPC_DM_UTILS/hpcdme.properties -DHPC_DM_UTILS=$HPC_DM_UTILS -Dhttp.proxyHost=$PROXY_IP -Dhttp.proxyPort=$PROXY_PORT -jar $jar_path  --cmdfile $command_file
         ;;
       CYGWIN*|MINGW32*|MSYS*)
            java -DHPC_DM_UTILS=$(cygpath -m $HPC_DM_UTILS) -Dhpc.client.properties=$(cygpath -w $HPC_DM_UTILS/hpcdme.properties)  -jar $(cygpath -w $jar_path)  --cmdfile $(cygpath -w $command_file)
        ;;
       # Add here more strings to compare
       # See correspondence table at the bottom of this answer
       *)
         echo 'Current OS not supported' 
         return 1
         ;;
    esac

    if [ "$?" -eq  1 ]
    then
      echo "The batch registration did not fully complete successfully" >&2
      return 1
    fi

}


#Print Usage of dm_download_collection_globus function
function dm_show_download_collection_globus_usage {
  read -d  '' usage <<- EOF
  usage: dm_download_collection_globus [-D REST-response] [-o output-file] [-f paths-file] [archive-path] <globus-destination_path> [globus-endpoint]

  Download the specified collection or list of collections to the Globus endpoint
  [-D REST-response]          Optionally specify the filename to capture the REST response status
  [-o output-file]            Optionally specify the filename to capture the error output. This is empty if the command is successful
  [-f paths-file]             Optionally specify newline delimited file which contains the collection paths in DME to be downloaded
  [archive-path]              Optionally specify source path in the archive (Not needed if the paths-file parameter is specified.)
  globus-destination_path     Full path of the destination folder at the Globus endpoint
  [globus-endpoint]           The UUID of the Globus endpoint that you want to use. If this is not specified, then the one specified in the hpcdme.properties file is used.

For detailed information on this command, refer to the following page: 
https://wiki.nci.nih.gov/x/JYlNG

EOF
  echo "$usage"
}


#Download a collection to Globus 
#Inputs: [-o output-json-file]
#        [-D REST-response]
#        [-f paths-file]
#        [collection-path]
#        destination-file
function dm_download_collection_globus {

    local response_msg
    local response_hdr
	local path_file

    while :; do
        case $1 in
            -D|--dump-header)
                if [ "$2" ]; then
                    response_hdr="$2"
                    shift
                else
                    dm_show_download_collection_globus_usage >&2
                    return 1
                fi
            ;;
            -o|--output)
                if [ "$2" ]; then
                    response_msg="$2"
                    shift
                else
                    dm_show_download_collection_globus_usage >&2
                    return 1
                fi
            ;;
            -f|--file)
                if [ "$2" ]; then
                    path_file="$2"
                else
                    dm_show_download_collection_globus_usage >&2
                    exit 1
                fi
            ;;
            *) break
        esac
        shift
    done

    if [ "$#" -lt 2 ] || [ "$#" -gt 3 ] || [[ "$3" =~ "/" ]]
    then
        dm_show_download_collection_globus_usage >&2
        return 1
    fi

    local src_path="$1"
    local dst_path="$2"

    local globus_endpoint
    if [ -z "$3" ]
    then
      #echo "Using the default Globus endpoint in $HPC_DM_UTILS/hpcdme.properties" 
      globus_endpoint=$(get_globus_endpoint)
      if [ "$?" -ne 0 ]
      then
        return 1
      fi
    else
      globus_endpoint="$3"
    fi       

	if [ -z "$path_file" ]
	then
		local template_file=$HPC_DM_UTILS/templates/download-async-template-internal.json
	else
		if [ ! -e "$path_file" ]
		then
			echo "Cannot find the path file: $path_file" >&2
			echo "Please check the file location and try again" >&2
			exit 1
		fi
		IFS=$'\n' read -d '' -r -a arr_paths < $path_file
		local src_paths=$(IFS=, ; echo "${arr_paths[*]}" | sed "s/,/\",\"/g")
		local template_file=$HPC_DM_UTILS/templates/download-async-list-template-internal.json
	fi 
	
    if [ ! -e "$template_file" ]
    then
        echo "Cannot find the template file: $template_file" >&2
        echo "Please pull the latest version and try again" >&2
        return 1
    fi

    #Make sure the template did not change:
    local container="globus-shared-endpoint-uid"
    local destination="destination-name"
	local sourcepaths="source-paths"
	local attribute="dataObjectPaths"


    local container_exists=$(grep  $container $template_file) 
    if [ -z "$container_exists" ]
    then
        echo "The template file $template_file changed." >&2
        echo "Please pull the latest version and try again" >&2
        return 1
    fi 

    local destination_exists=$(grep $destination $template_file) 
    if [ -z "$destination_exists" ]
    then
        echo "The template file $template_file changed." >&2
        echo "Please pull the latest version and try again" >&2
        return 1
    fi 

	if [ ! -z "$path_file" ]
	then
		local source_paths_exists=$(grep $sourcepaths $template_file) 
		if [ -z "$source_paths_exists" ]
		then
			echo "The template file $template_file changed." >&2
			echo "Please pull the latest version and try again" >&2
			exit 1
		fi
		local attribute_exists=$(grep $attribute $template_file) 
		if [ -z "$attribute_exists" ]
		then
			echo "The template file $template_file changed." >&2
			echo "Please pull the latest version and try again" >&2
			exit 1
		fi
	fi
	
	local request_file=$HPC_DM_UTILS/temp/async-download.json.tmp
     
    #Update the Globus endpoint
    updated_endpoint=$(cat $template_file | sed "s@$container@$globus_endpoint@")

    #Update the file name 
    updated_destination=$(echo "$updated_endpoint" | sed "s#${destination}#${dst_path}#")
	
	if [ -z "$path_file" ]
	then
		echo  "$updated_destination" > $request_file
	else
		#Update the source paths
		updated_source_paths=$(echo "$updated_destination" | sed "s#${attribute}#collectionPaths#" | sed "s#${sourcepaths}#${src_paths}#")
		echo  "$updated_source_paths" > $request_file
	fi

    if [ -z "$response_msg" ]
     then
        response_msg=download-collection-response-message.json.tmp
    fi
    if [ -z "$response_hdr" ]
    then
        response_hdr=download-collection-response-header.tmp
    fi

    local SERVER=$(get_server)
    local CONFIG=$(get_config)

	if [ -z "$path_file" ]
	then
		curl -H "Content-Type: application/json" -d @$request_file -X POST ${SERVER}/v2/collection/$(urlencode $src_path)/download  $CONFIG -H "Accept: application/json" -D $response_hdr -o $response_msg -s 2> $HPC_DM_UTILS/temp/curl-status 
	else
		curl -H "Content-Type: application/json" -d @$request_file -X POST ${SERVER}/v2/download  $CONFIG -H "Accept: application/json" -D $response_hdr -o $response_msg -s 2> $HPC_DM_UTILS/temp/curl-status 
	fi
    check_connection $response_hdr


    local code=$(get_http_code "$response_hdr") 

    if [ "$code" -ne 200 ]
    then 
      #In this case the destination path file will contain the error code
      print_error_message "$response_msg" "$code" 
    fi
}

#Download to Globus 
#Inputs: [-o output-json-file]
#        [-D REST-response]
#        [-f paths-file]
#        [item-path] path on archive
#        <destination-path> path on Globus
function dm_download_async {
	echo "dm_download_async has been deprecated. Use dm_download_dataobject_globus." >&2
	dm_download_dataobject_globus $@
}


#Print Usage of dm_download_dataobject_globus function
function dm_show_download_dataobject_globus_usage {
  read -d  '' usage <<- EOF
  usage: dm_download_dataobject_globus [-D REST-response] [-o output-file] [-f paths-file] [archive-path] <globus-destination_path> [globus-endpoint]

  Download the specified dataobject or list of dataobjects to the Globus endpoint
  [-D REST-response]          Optionally specify the filename to capture the REST response
  [-o output-file]            Optionally specify the filename to capture the error output. This is empty if the command is successful
  [-f paths-file]             New line delimited file which contains the file paths in DME to be downloaded
  [archive-path]              Source path in the archive (Not needed if the paths-file parameter is specified.)
  globus-destination_path     Full path of the destination file in the Globus endpoint
  [globus-endpoint]           The UUID of the Globus endpoint that you want to use. If this is not specified, then the one specified in the hpcdme.properties file is used.

For detailed information on this command, refer to the following page: 
https://wiki.nci.nih.gov/x/awRuG

EOF
  echo "$usage"
}

#Download to Globus 
#Inputs: [-o output-json-file]
#        [-D REST-response]
#        [-f paths-file]
#        [item-path] path on archive
#        <destination-path> path on Globus
function dm_download_dataobject_globus {

    local response_msg
    local response_hdr
	local path_file

    while :; do
        case $1 in
            -D|--dump-header)
                if [ "$2" ]; then
                    response_hdr="$2"
                    shift
                else
                    dm_show_download_dataobject_globus_usage >&2
                    return 1
                fi
            ;;
            -o|--output)
                if [ "$2" ]; then
                    response_msg="$2"
                    shift
                else
                    dm_show_download_dataobject_globus_usage >&2
                    return 1
                fi
            ;;
			-f|--file)
                if [ "$2" ]; then
                    path_file="$2"
                else
                    dm_show_download_dataobject_globus_usage >&2
                    return 1
                fi
            ;;
            *) break
        esac
        shift
    done

    if [ "$#" -lt 2 ] || [ "$#" -gt 3 ] || [[ "$3" =~ "/" ]]
    then
        dm_show_download_dataobject_globus_usage >&2
        return 1
    fi

    local src_path="$1"
    local dst_path="$2"

    if [ -z "$3" ]
    then
      #echo "Using the default Globus endpoint in $HPC_DM_UTILS/hpcdme.properties" 
      globus_endpoint=$(get_globus_endpoint) || exit 1
    else
      globus_endpoint="$3"
    fi       

    local template_file=$HPC_DM_UTILS/templates/download-async-template-internal.json
    if [ ! -e "$template_file" ]
    then
        echo "Cannot file the template file: $template_file" >&2
        echo "Please pull the latest version and try again" >&2
        exit 1
    fi

	if [ -z "$path_file" ]
	then 
		item_type=$(get_type $src_path) || exit 1
		if [ "$item_type" == "" ]
		then
			echo "ERROR: Cannot find the item $src_path in the archive" >&2
			exit 1
		fi
		local template_file=$HPC_DM_UTILS/templates/download-async-template-internal.json
	else
		if [ ! -e "$path_file" ]
		then
			echo "Cannot find the path file: $path_file" >&2
			echo "Please check the file location and try again" >&2
			exit 1
		fi
		IFS=$'\n' read -d '' -r -a arr_paths < $path_file
		local src_paths=$(IFS=, ; echo "${arr_paths[*]}" | sed "s/,/\",\"/g")
		local template_file=$HPC_DM_UTILS/templates/download-async-list-template-internal.json
	fi
   

    if [ ! -e "$template_file" ]
    then
        echo "Cannot find the template file: $template_file" >&2
        echo "Please pull the latest version and try again" >&2
        exit 1
    fi

    #Make sure the template did not change:
    local container="globus-shared-endpoint-uid"
    local destination="destination-name"
	local sourcepaths="source-paths"

    local container_exists=$(grep  $container $template_file) 
    if [ -z "$container_exists" ]
    then
        echo "The template file $template_file changed." >&2
        echo "Please pull the latest version and try again" >&2
        exit  1
    fi 

    local destination_exists=$(grep $destination $template_file) 
    if [ -z "$destination_exists" ]
    then
        echo "The template file $template_file changed." >&2
        echo "Please pull the latest version and try again" >&2
        exit 1
    fi 

	if [ ! -z "$path_file" ]
	then
		local source_paths_exists=$(grep $sourcepaths $template_file) 
		if [ -z "$source_paths_exists" ]
		then
			echo "The template file $template_file changed." >&2
			echo "Please pull the latest version and try again" >&2
			exit 1
		fi
	fi
	
    local request_file=$HPC_DM_UTILS/temp/async-download.json.tmp
     
    #Update the Globus endpoint
    updated_endpoint=$(cat $template_file | sed "s@$container@$globus_endpoint@")

    #Update the file name 
    updated_destination=$(echo "$updated_endpoint" | sed "s#${destination}#${dst_path}#")
	if [ -z "$path_file" ]
	then
		echo  "$updated_destination" > $request_file
	else
		#Update the source paths
		updated_source_paths=$(echo "$updated_destination" | sed "s#${sourcepaths}#${src_paths}#")
		echo  "$updated_source_paths" > $request_file
		item_type="dataObject"
	fi

    echo "Sending request to download the $item_type $src_path to Globus..."
    if [ -z "$response_msg" ]
     then
        response_msg=download-$item_type-response-message.json.tmp
    fi
    if [ -z "$response_hdr" ]
    then
        response_hdr=download-$item_type-response-header.tmp
    fi


    local SERVER=$(get_server)
    local CONFIG=$(get_config)

	if [ -z "$path_file" ]
	then
		curl -H "Content-Type: application/json" -d @$request_file -X POST ${SERVER}/v2/$item_type/$(urlencode $src_path)/download  $CONFIG -H "Accept: application/json" -D $response_hdr -o $response_msg -s 2> $HPC_DM_UTILS/temp/curl-status 
	else
		curl -H "Content-Type: application/json" -d @$request_file -X POST ${SERVER}/v2/download  $CONFIG -H "Accept: application/json" -D $response_hdr -o $response_msg -s 2> $HPC_DM_UTILS/temp/curl-status 
	fi
    check_connection $response_hdr || exit 1


    local code=$(get_http_code "$response_hdr") 

    if [ "$code" -ne 200 ]
    then 
      #In this case the destination path file will contain the error code
      print_error_message "$response_msg" "$code"  || exit 1
    fi

    #Parse the download receipt:

    message=$(get_json_value $response_msg message)
    if [ ! -z "$message" ]
    then
        echo "Error downloading $src_path:"  >&2
        echo "$message" >&2
        exit 1
    else
        echo "Download request sent to Globus." 
        task_id=$(get_json_value $response_msg taskId)
        echo "taskID:$task_id" 
        echo "Check the full download receipt at $response_msg"
    fi
}


#Download to S3 bucke/description.json
#Inputs: <archive-path> path on archive
#        <description.json> JSON file containing dextination S3 bucket information
function dm_download_s3_deprecated {


    local USAGE="usage: dm_download_s3 <archive-path> <description.json>"

    if [ "$#" -lt 2 ]
    then
        echo "$USAGE" >&2
        exit 1
    fi

    local SOURCE_PATH="$1"
    local DESCRIPTION="$2"


    item_type=$(get_type $SOURCE_PATH) || exit 1
    if [ "$item_type" == "" ]
    then
        echo "ERROR: Cannot find the item $SOURCE_PATH in the archive" >&2
        exit 1
    fi

    echo "Sending request to download the $item_type $SOURCE_PATH to S3..."
    local response_hdr=download-$item_type-response-header.tmp
    local response_msg=download-$item_type-response-message.json.tmp

    local SERVER=$(get_server)
    local CONFIG=$(get_config)

    curl -H "Content-Type: application/json" -d @$DESCRIPTION -X POST ${SERVER}/v2/$item_type/$(urlencode $SOURCE_PATH)/download  $CONFIG -H "Accept: application/json" -D $response_hdr -o $response_msg -s 2> $HPC_DM_UTILS/temp/curl-status
    check_connection $response_hdr || exit 1


    local code=$(get_http_code "$response_hdr")

    if [ "$code" -ne 200 ]
    then
      #In this case the destination path file will contain the error code
      print_error_message "$response_msg" "$code"  || exit 1
    else
      rm -f $response_hdr 2> /dev/null
    fi

    #Parse the download receipt:

    message=$(get_json_value $response_msg message)
    if [ ! -z "$message" ]
    then
        echo "Error downloading $src_path:"  >&2
        echo "$message" >&2
        exit 1
    else
        echo "Download request sent to S3."
        task_id=$(get_json_value $response_msg taskId)
        echo "taskID:$task_id"
        echo "Check the full download receipt at $response_msg"
    fi
}

#Print Usage of dm_download_dataobject_s3 function
function dm_show_download_dataobject_s3_usage {
  read -d  '' usage <<- EOF
  usage: dm_download_dataobject_s3 [-D REST-response] [-o output-file] [-f paths-file] [archive-path] <destination_bucket> <destination_path> [aws_credentials_file_path]
  Download the specified dataobject or list of dataobjects to an S3 bucket
  [-D REST-response]          Optionally specify the filename to capture the REST response
  [-o output-file]            Optionally specify the filename to capture the error output. This is empty if the command is successful
  [-f paths-file]             New line delimited file which contains the data object paths in DME to be downloaded
  [archive-path]              Source path in the archive (Not needed if the paths-file parameter is specified.)
  destination-bucket          Destination S3 bucket to transfer data to
  destination_path            Full path of the destination file/folder in the S3 bucket
  [aws_credentials_file_path] Full path of the AWS credentials file on the local machine. If this is not specified, then the default file located at ~/.aws/credentials will be used.

For detailed information on this command, refer to the following page: 
https://wiki.nci.nih.gov/x/bQRuG

EOF
  echo "$usage"
}

function dm_download_s3 {
	echo "dm_download_s3 has been deprecated. Use dm_download_dataobject_s3." >&2
	dm_download_dataobject_s3 $@
}

function dm_download_dataobject_s3 {

    local CREDENTIALS_FILE=~/.aws/credentials
    local DESCRIPTION=description.json

    local response_msg
    local response_hdr
	local path_file

    while :; do
        case $1 in
            -D|--dump-header)
                if [ "$2" ]; then
                    response_hdr="$2"
                    shift
                else
                    dm_show_download_dataobject_s3_usage >&2
                    return 1
                fi
            ;;
            -o|--output)
                if [ "$2" ]; then
                    response_msg="$2"
                    shift
                else
                    dm_show_download_dataobject_s3_usage >&2
                    return 1
                fi
            ;;
			-f|--file)
                if [ "$2" ]; then
                    path_file="$2"
                else
                    dm_show_download_dataobject_s3_usage >&2
                    return 1
                fi
            ;;
            *) break
        esac
        shift
    done

    if [ "$#" -lt 3 ] || [ "$#" -gt 4 ]
    then
        dm_show_download_dataobject_s3_usage >&2
        exit 1
    fi

    if [ "$#" -gt 3 ]
    then
       CREDENTIALS_FILE=$4
    fi

    local SOURCE_PATH="$1"
    local DESTINATION_BUCKET="$2"
    local DESTINATION_PATH="$3"

	if [ -z "$path_file" ]
	then
		item_type=$(get_type $SOURCE_PATH) || exit 1
		if [ "$item_type" == "" ]
		then
			echo "ERROR: Cannot find the item $SOURCE_PATH in the archive" >&2
			exit 1
		fi
	else
		if [ ! -e "$path_file" ]
		then
			echo "Cannot find the path file: $path_file" >&2
			echo "Please check the file location and try again" >&2
			exit 1
		fi
		IFS=$'\n' read -d '' -r -a arr_paths < $path_file
		local SOURCE_PATHS=$(IFS=, ; echo "${arr_paths[*]}" | sed "s/,/\",\"/g")
		item_type="dataObject"
	fi 
	
    

   #Create description.json
   local awsAccessKeyId=$(get_value $CREDENTIALS_FILE aws_access_key_id)
   if [ -z "$awsAccessKeyId" ]
   then
       echo "ERROR: Credentials file does not contain aws_access_key_id property"
       exit 1
   fi

   local awsSecretAccessKey=$(get_value $CREDENTIALS_FILE aws_secret_access_key)
   if [ -z "$awsSecretAccessKey" ]
   then
       echo "ERROR: Credentials file does not contain aws_secret_access_key property"
       exit 1
   fi
  
   local awsRegion=$(get_value $CREDENTIALS_FILE region)
   if [ -z "$awsRegion" ]
   then
       echo "ERROR: Credentials file does not contain region property"
       exit 1
   fi

   echo -e "{\n \"s3DownloadDestination\": {\n \"destinationLocation\": {" > description.json
   echo " \"fileContainerId\": \"$DESTINATION_BUCKET\"," >> description.json
   echo -e " \"fileId\": \"$DESTINATION_PATH\"\n}," >> description.json
   echo -e " \"account\": {\n \"accessKey\": \"$awsAccessKeyId\"," >> description.json
   echo " \"secretKey\": \"$awsSecretAccessKey\"," >> description.json
   echo -e " \"region\": \"$awsRegion\" \n}" >> description.json
   if [ -z "$path_file" ]
   then
        echo -e "\n}\n} " >> description.json
   else
		echo -e "\n},\n \"dataObjectPaths\": [\n \"$SOURCE_PATHS\"\n]" >> description.json
		echo -e "\n}" >> description.json
   fi
   echo "$description.json"


    echo "Sending request to download the $item_type $SOURCE_PATH to S3..."
    if [ -z "$response_msg" ]
     then
        response_msg=download-$item_type-response-message.json.tmp
    fi
    if [ -z "$response_hdr" ]
    then
        response_hdr=download-$item_type-response-header.tmp
    fi

    local SERVER=$(get_server)
    local CONFIG=$(get_config)

	if [ -z "$path_file" ]
	then
		curl -H "Content-Type: application/json" -d @$DESCRIPTION -X POST ${SERVER}/v2/$item_type/$(urlencode $SOURCE_PATH)/download  $CONFIG -H "Accept: application/json" -D $response_hdr -o $response_msg -s 2> $HPC_DM_UTILS/temp/curl-status
	else
		curl -H "Content-Type: application/json" -d @$DESCRIPTION -X POST ${SERVER}/v2/download  $CONFIG -H "Accept: application/json" -D $response_hdr -o $response_msg -s 2> $HPC_DM_UTILS/temp/curl-status
	fi
    check_connection $response_hdr || exit 1


    local code=$(get_http_code "$response_hdr")

    if [ "$code" -ne 200 ]
    then
      #In this case the destination path file will contain the error code
      print_error_message "$response_msg" "$code"  || exit 1
    fi

    #Parse the download receipt:

    message=$(get_json_value $response_msg message)
    if [ ! -z "$message" ]
    then
        echo "Error downloading $src_path:"  >&2
        echo "$message" >&2
        exit 1
    else
        echo "Download request sent to S3."
        task_id=$(get_json_value $response_msg taskId)
        echo "taskID:$task_id"
        echo "Check the full download receipt at $response_msg"
    fi
}

#Print Usage of dm_download_collection_s3 function
function dm_show_download_collection_s3_usage {
  read -d  '' usage <<- EOF
  usage: dm_download_collection_s3 [-D REST-response] [-o output-file] [-f paths-file] [archive-path] <destination_bucket> <destination_path> [aws_credentials_file_path]
  Download the specified collection or list of collections to an S3 bucket
  [-D REST-response]          Optionally specify the filename to capture the REST response
  [-o output-file]            Optionally specify the filename to capture the error output. This will be empty if the command is successful
  [-f paths-file]             New line delimited file which contains the collection paths in DME to be downloaded
  [archive-path]              Source path in the archive (Not needed if the paths-file parameter is specified.)
  destination-bucket          Destination S3 bucket to transfer the data to
  destination_path            Full path of the destination folder in the S3 bucket
  [aws_credentials_file_path] Full path of the AWS credentials file on the local machine. If this is not specified, then the default file located at ~/.aws/credentials will be used.

For detailed information on this command, refer to the following page: 
https://wiki.nci.nih.gov/x/q4tbG

EOF
  echo "$usage"
}


function dm_download_collection_s3 {

    local CREDENTIALS_FILE=~/.aws/credentials
    local DESCRIPTION=description.json

    local response_msg
    local response_hdr
	local path_file

    while :; do
        case $1 in
            -D|--dump-header)
                if [ "$2" ]; then
                    response_hdr="$2"
                    shift
                else
                    echo "$USAGE" >&2
                    return 1
                fi
            ;;
            -o|--output)
                if [ "$2" ]; then
                    response_msg="$2"
                    shift
                else
                    echo "$USAGE" >&2
                    return 1
                fi
            ;;
			-f|--file)
                if [ "$2" ]; then
                    path_file="$2"
                else
                    echo "$USAGE" >&2
                    return 1
                fi
            ;;
            *) break
        esac
        shift
    done

    if [ "$#" -lt 3 ] || [ "$#" -gt 4 ]
    then
        dm_show_download_collection_s3_usage >&2
        exit 1
    fi

    if [ "$#" -gt 3 ]
    then
       CREDENTIALS_FILE=$4
    fi

    local SOURCE_PATH="$1"
    local DESTINATION_BUCKET="$2"
    local DESTINATION_PATH="$3"

	item_type="collection"
	
	if [ ! -z "$path_file" ]
	then
		if [ ! -e "$path_file" ]
		then
			echo "Cannot find the path file: $path_file" >&2
			echo "Please check the file location and try again" >&2
			exit 1
		fi
		IFS=$'\n' read -d '' -r -a arr_paths < $path_file
		local SOURCE_PATHS=$(IFS=, ; echo "${arr_paths[*]}" | sed "s/,/\",\"/g")
	fi 
	
    

   #Create description.json
   local awsAccessKeyId=$(get_value $CREDENTIALS_FILE aws_access_key_id)
   if [ -z "$awsAccessKeyId" ]
   then
       echo "ERROR: Credentials file does not contain aws_access_key_id property"
       exit 1
   fi

   local awsSecretAccessKey=$(get_value $CREDENTIALS_FILE aws_secret_access_key)
   if [ -z "$awsSecretAccessKey" ]
   then
       echo "ERROR: Credentials file does not contain aws_secret_access_key property"
       exit 1
   fi
  
   local awsRegion=$(get_value $CREDENTIALS_FILE region)
   if [ -z "$awsRegion" ]
   then
       echo "ERROR: Credentials file does not contain region property"
       exit 1
   fi

   echo -e "{\n \"s3DownloadDestination\": {\n \"destinationLocation\": {" > description.json
   echo " \"fileContainerId\": \"$DESTINATION_BUCKET\"," >> description.json
   echo -e " \"fileId\": \"$DESTINATION_PATH\"\n}," >> description.json
   echo -e " \"account\": {\n \"accessKey\": \"$awsAccessKeyId\"," >> description.json
   echo " \"secretKey\": \"$awsSecretAccessKey\"," >> description.json
   echo -e " \"region\": \"$awsRegion\" \n}" >> description.json
   if [ -z "$path_file" ]
   then
        echo -e "\n}\n} " >> description.json
   else
		echo -e "\n},\n \"collectionPaths\": [\n \"$SOURCE_PATHS\"\n]" >> description.json
		echo -e "\n}" >> description.json
   fi
   echo "$description.json"


    echo "Sending request to download the $item_type $SOURCE_PATH to S3..."
    if [ -z "$response_msg" ]
     then
        response_msg=download-$item_type-response-message.json.tmp
    fi
    if [ -z "$response_hdr" ]
    then
        response_hdr=download-$item_type-response-header.tmp
    fi

    local SERVER=$(get_server)
    local CONFIG=$(get_config)

	if [ -z "$path_file" ]
	then
		curl -H "Content-Type: application/json" -d @$DESCRIPTION -X POST ${SERVER}/v2/$item_type/$(urlencode $SOURCE_PATH)/download  $CONFIG -H "Accept: application/json" -D $response_hdr -o $response_msg -s 2> $HPC_DM_UTILS/temp/curl-status
	else
		curl -H "Content-Type: application/json" -d @$DESCRIPTION -X POST ${SERVER}/v2/download  $CONFIG -H "Accept: application/json" -D $response_hdr -o $response_msg -s 2> $HPC_DM_UTILS/temp/curl-status
	fi
    check_connection $response_hdr || exit 1


    local code=$(get_http_code "$response_hdr")

    if [ "$code" -ne 200 ]
    then
      #In this case the destination path file will contain the error code
      print_error_message "$response_msg" "$code"  || exit 1
    fi

    #Parse the download receipt:

    message=$(get_json_value $response_msg message)
    if [ ! -z "$message" ]
    then
        echo "Error downloading $src_path:"  >&2
        echo "$message" >&2
        exit 1
    else
        echo "Download request sent to S3."
        task_id=$(get_json_value $response_msg taskId)
        echo "taskID:$task_id"
        echo "Check the full download receipt at $response_msg"
    fi
}


#Get the status of asynchronousl download request 
#Input: [-o download-status-file]
#       [-D REST-response]
#       <taskId>  a numerical id for the download receipt
#Input: <request_type> dataObject, collection, or empty string for multiple downloads
#Input: [download-status-file] (for backward compatibility)
#Input: [REST-response] (for backward compatibility)
function dm_get_download_status {

 
    local USAGE="usage: dm_get_download_status [-D REST-response] [-o download-status-file] <download-taskId> <request-type>"

    local RESPONSE_MSG
    local response_hdr
	local SHOW_OUTPUT=1

    while :; do
        case $1 in
            -D|--dump-header)
                if [ "$2" ]; then
                    response_hdr="$2"
                    shift
                else
                    echo "$USAGE" >&2
                    return 1
                fi
            ;;
            -o|--output)
                if [ "$2" ]; then
                    RESPONSE_MSG="$2"
					SHOW_OUTPUT=0
                    shift
                else
                    echo "$USAGE" >&2
                    return 1
                fi
            ;;
            *) break
        esac
        shift
    done

    if [ "$#" -lt 2 ] 
    then
        echo "$USAGE" >&2
        return 1
    fi

    task_id="$1"
    request_type="$2"

    if [ "$request_type" != "" ]
    then
      request_type=/${request_type}
    fi


    if [ ! -z "$3" ]
    then
      RESPONSE_MSG="$3"
	  SHOW_OUTPUT=0
    elif [ -z "$RESPONSE_MSG" ]
    then
      RESPONSE_MSG=get-download-status-response-message.json.tmp
    fi 

    if [ ! -z "$4" ]
    then
      response_header="$4"
    elif [ -z "$response_header" ]
    then
      response_header=get-download-status-response-header.tmp
    fi 


    config=$(get_config) || exit 1
    server=$(get_server) || exit 1

   
    curl -G -X GET ${server}${request_type}/download?taskId="$task_id"  $config  -H "Accept: application/json" -D $response_header -o $RESPONSE_MSG -s 2> $HPC_DM_UTILS/temp/curl-status
    check_connection $response_header

    #TO CONTINUE

    local response_code=$(get_http_code $response_header)
    if [ "$response_code" -ne 200 ]
    then
      echo "Error getting download status for taskID:\"$task_id\" " >&2
      print_error_message "$RESPONSE_MSG" "$response_code"
      exit 1
    else 
     

      if [ $SHOW_OUTPUT -eq 1 ]
      then
        print_json_message "$RESPONSE_MSG"    
      fi
    fi
}


#Print Usage of dm_rename function
function dm_show_rename_usage {
  read -d  '' usage <<- EOF
  usage: dm_rename [-D REST-response] [-o output-file] <description.json> 

  Move a file or collection
  [-D REST-response]          Optionally specify the filename to capture the REST response
  [-o output-file]            Optionally specify the filename to capture the error output. This is empty if the command is successful
  [description-json]          Path to the JSON file containing the source and destination path in the archive

For detailed information on this command, refer to the following page: 
https://wiki.nci.nih.gov/x/Lg5GFw

EOF
  echo "$usage"
}


#Rename a collection or a dataObject
#Inputs: [-o rename-status-file]
#        [-D REST-response]
#        <description.json>: The metadata json file
#      : [rename-status-file] (for backward compatibility)
#      : [REST-response] (for backward compatibility)
function dm_rename() {

    local RESPONSE_MSG
    local RESPONSE_HEADER
	local SHOW_OUTPUT=1

    while :; do
        case $1 in
            -D|--dump-header)
                if [ "$2" ]; then
                    RESPONSE_HEADER="$2"
                    shift
                else
                    dm_show_rename_usage >&2
                    return 1
                fi
            ;;
            -o|--output)
                if [ "$2" ]; then
                    RESPONSE_MSG="$2"
                    SHOW_OUTPUT=0
                    shift
                else
                    dm_show_rename_usage >&2
                    return 1
                fi
            ;;
            *) break
        esac
        shift
    done

    if [ -z "$1" ]
    then
        dm_show_rename_usage >&2
        return 1
    fi

    local DESCRIPTION="$1"

    if [ ! -e "$DESCRIPTION" ]
    then
      echo "ERROR: Cannot access the \"$DESCRIPTION\" file" >&2
      exit 1
    fi


    if [ ! -z "$2" ]
    then
      RESPONSE_MSG="$2"
	  SHOW_OUTPUT=0
    elif [ -z "$RESPONSE_MSG" ]
    then
      RESPONSE_MSG=rename-response-message.json.tmp
    fi 

    if [ ! -z "$3" ]
    then
      RESPONSE_HEADER="$3"
    elif [ -z "$RESPONSE_HEADER" ]
    then
      RESPONSE_HEADER=rename-response-header.tmp
    fi 

    SERVER=$(get_server) || exit 1
    CONFIG=$(get_config) || exit 1

    local CURL_FLAGS="-X POST ${SERVER}/move  $CONFIG  -D $RESPONSE_HEADER -o $RESPONSE_MSG "
    
    curl -H "Content-Type: application/json" -d @$DESCRIPTION $CURL_FLAGS  2>$HPC_DM_UTILS/temp/curl-status

    check_connection $RESPONSE_HEADER
    local response_code=$(get_http_code $RESPONSE_HEADER)
    if [ "$response_code" -ne 200 ] && [ "$response_code" -ne 201 ]
    then
      echo "Error performing rename operation " >&2
      print_error_message "$RESPONSE_MSG" "$response_code"
      exit 1
    else

      
      if [ $SHOW_OUTPUT -eq 1 ]
      then
        print_json_message "$RESPONSE_MSG"
      fi
    
    fi 


}



#Print Usage of dm_add_bookmark function
function dm_show_add_bookmark_usage {
  read -d  '' usage <<- EOF
  usage: dm_add_bookmark [-D REST-response] [-o output-file] <bookmark_name> <description.json>

  Create a bookmark for a user 
  [-D REST-response]          Optionally specify the filename to capture the REST response.
  [-o output-file]            Optionally specify the filename to capture the error output. This is empty if the command is successful
  bookmark_name               Display name for the bookmark 
  description-json            Path to the JSON file containing the bookmark path in the archive

For detailed information on this command, refer to the following page: 
https://wiki.nci.nih.gov/x/ooheFw

EOF
  echo "$usage"
}


#Add a bookmark for a user
#Inputs:  [-o status-file]
#         [-D REST-response]
#         <bookmark_name>: Name of the bookmark
#         <description.json>: The json file containing the parameters
#      : [status-file] (for backward compatibility)
#      : [REST-response] (for backward compatibility)
function dm_add_bookmark () {

    local RESPONSE_MSG
    local RESPONSE_HEADER

    while :; do
        case $1 in
            -D|--dump-header)
                if [ "$2" ]; then
                    RESPONSE_HEADER="$2"
                    shift
                else
                    dm_show_add_bookmark_usage >&2
                    return 1
                fi
            ;;
            -o|--output)
                if [ "$2" ]; then
                    RESPONSE_MSG="$2"
                    shift
                else
                    dm_show_add_bookmark_usage >&2
                    return 1
                fi
            ;;
            *) break
        esac
        shift
    done

    if [ -z "$1" ] || [ -z "$2" ] 
    then
        dm_show_add_bookmark_usage >&2
        return 1
    fi

   
    local BOOKMARK_NAME="$1"
    local DESCRIPTION_PATH="$2"
    
    USERID=$(get_username) || exit 1
    SERVER=$(get_server) || exit 1
    CONFIG=$(get_config) || exit 1

    if [ ! -e "$DESCRIPTION_PATH" ]
    then
      echo "ERROR: Cannot access the file \"$DESCRIPTION_PATH\" " >&2
      exit 1
    fi
    

    if [ ! -z "$3" ]
    then
      RESPONSE_MSG="$3"
    elif [ -z "$RESPONSE_MSG" ]
    then
      RESPONSE_MSG=add_bookmark-response-message.json.tmp
    fi 

    if [ ! -z "$4" ]
    then
      RESPONSE_HEADER="$4"
    elif [ -z "$RESPONSE_HEADER" ]
    then
      RESPONSE_HEADER=add_bookmark-response-header.tmp
    fi 

    rm -f  $RESPONSE_MSG 2>/dev/null 
    rm -f $RESPONSE_HEADER 2>/dev/null 

    local CURL_FLAGS="${SERVER}/bookmark/$(urlencode $BOOKMARK_NAME)  $CONFIG  -D $RESPONSE_HEADER -o $RESPONSE_MSG "
    
  
    curl -X PUT -H "Content-Type: application/json" -d @${DESCRIPTION_PATH} $CURL_FLAGS -H "Accept: application/json" 2> $HPC_DM_UTILS/temp/curl-status 

    #Exit with connection error if response header has no data    
    check_connection $RESPONSE_HEADER

    #Process response
    local RESPONSE_CODE=$(get_http_code $RESPONSE_HEADER)
    if [ "$RESPONSE_CODE" -ne 201 ]
    then
      echo "Error creating bookmark \"$BOOKMARK_NAME\" " >&2
      print_error_message "$RESPONSE_MSG" "$RESPONSE_CODE"
      exit 1
    fi

}



#Print Usage of dm_register_user function
function dm_show_register_user_usage {
  read -d  '' usage <<- EOF
  usage: dm_register_user [-D REST-response] [-o output-file] <user_id> <description.json> 

  Register a user
  [-D REST-response]          Optionally specify the filename to capture the REST response
  [-o output-file]            Optionally specify the filename to capture the error output. This is empty if the command is successful
  user_id                     NIH user ID of the user
  description.json            Path to the JSON file containing input data for registration

For detailed information on this command, refer to the following page: 
https://wiki.nci.nih.gov/x/xh5GFw

EOF
  echo "$usage"
}


#Register a user
#Inputs:  [-o status-file]
#         [-D REST-response]
#         <user id>: LDAP id of the user
#         <description.json>: The json file containing the parameters
#      : [status-file] (for backward compatibility)
#      : [REST-response] (for backward compatibility)
function dm_register_user () {

    local RESPONSE_MSG
    local RESPONSE_HEADER

    while :; do
        case $1 in
            -D|--dump-header)
                if [ "$2" ]; then
                    RESPONSE_HEADER="$2"
                    shift
                else
                    dm_show_register_user_usage >&2
                    return 1
                fi
            ;;
            -o|--output)
                if [ "$2" ]; then
                    RESPONSE_MSG="$2"
                    shift
                else
                    dm_show_register_user_usage >&2
                    return 1
                fi
            ;;
            *) break
        esac
        shift
    done

    if [ -z "$1" ] || [ -z "$2" ]
    then
        dm_show_register_user_usage >&2
        return 1
    fi

  
    local USER_ID="$1"
    local DESCRIPTION_PATH="$2"
   
    USERID=$(get_username) || exit 1
    SERVER=$(get_server) || exit 1
    CONFIG=$(get_config) || exit 1

    if [ ! -e "$DESCRIPTION_PATH" ]
    then
      echo "ERROR: Cannot access the file \"$DESCRIPTION_PATH\" " >&2
      exit 1
    fi


    if [ ! -z "$3" ]
    then
      RESPONSE_MSG="$3"
    elif [ -z "$RESPONSE_MSG" ]
    then
      RESPONSE_MSG=register_user-response-message.json.tmp
    fi 

    if [ ! -z "$4" ]
    then
      RESPONSE_HEADER="$4"
    elif [ -z "$RESPONSE_HEADER" ]
    then
      RESPONSE_HEADER=register_user-response-header.tmp
    fi 

    rm -f  $RESPONSE_MSG 2>/dev/null
    rm -f $RESPONSE_HEADER 2>/dev/null

    local CURL_FLAGS="${SERVER}/user/${USER_ID}  $CONFIG  -D $RESPONSE_HEADER -o $RESPONSE_MSG "
   
 
    curl -X PUT -H "Content-Type: application/json" -d @${DESCRIPTION_PATH} $CURL_FLAGS -H "Accept: application/json" 2> $HPC_DM_UTILS/temp/curl-status
    
    #Exit with connection error if response header has no data
    check_connection $RESPONSE_HEADER

    #Process response
    local RESPONSE_CODE=$(get_http_code $RESPONSE_HEADER)
    if [ "$RESPONSE_CODE" -ne 201 ]
    then
      echo "Error enrolling user \"$USER_ID\" " >&2
      print_error_message "$RESPONSE_MSG" "$RESPONSE_CODE"
      exit 1
    fi
}



#Print Usage of dm_update_user function
function dm_show_update_user_usage {
  read -d  '' usage <<- EOF
  usage: dm_update_user [-D REST-response] [-o output-file] <user_id> <description.json>

  Update a registered user
  [-D REST-response]          Optionally specify the filename to capture the REST response
  [-o output-file]            Optionally specify the filename to capture the error output. This is empty if the command is successful
  user_id                     NIH user ID of the user
  description-json            Path to the JSON file containing additional command parameters

For detailed information on this command, refer to the following page: 
https://wiki.nci.nih.gov/x/yB5GFw

EOF
  echo "$usage"
}


#Update an existing user
#Inputs:  [-o status-file]
#         [-D REST-response]
#         <user id>: LDAP id of the user
#         <description.json>: The json file containing the parameters
#      : [status-file] (for backward compatibility)
#      : [REST-response] (for backward compatibility)
function dm_update_user () {

    local RESPONSE_MSG
    local RESPONSE_HEADER

    while :; do
        case $1 in
            -D|--dump-header)
                if [ "$2" ]; then
                    RESPONSE_HEADER="$2"
                    shift
                else
                    dm_show_update_user_usage >&2
                    return 1
                fi
            ;;
            -o|--output)
                if [ "$2" ]; then
                    RESPONSE_MSG="$2"
                    shift
                else
                    dm_show_update_user_usage >&2
                    return 1
                fi
            ;;
            *) break
        esac
        shift
    done

    if [ -z "$1" ] || [ -z "$2" ]
    then
        dm_show_update_user_usage >&2
        return 1
    fi


    local USER_ID="$1"
    local DESCRIPTION_PATH="$2"

    USERID=$(get_username) || exit 1
    SERVER=$(get_server) || exit 1
    CONFIG=$(get_config) || exit 1

    if [ ! -e "$DESCRIPTION_PATH" ]
    then
      echo "ERROR: Cannot access the file \"$DESCRIPTION_PATH\" " >&2
      exit 1
    fi



    if [ ! -z "$3" ]
    then
      RESPONSE_MSG="$3"
    elif [ -z "$RESPONSE_MSG" ]
    then
      RESPONSE_MSG=update_user-response-message.json.tmp
    fi 

    if [ ! -z "$4" ]
    then
      RESPONSE_HEADER="$4"
    elif [ -z "$RESPONSE_HEADER" ]
    then
      RESPONSE_HEADER=update_user-response-header.tmp
    fi 

    rm -f  $RESPONSE_MSG 2>/dev/null
    rm -f $RESPONSE_HEADER 2>/dev/null

    local CURL_FLAGS="${SERVER}/user/${USER_ID}  $CONFIG  -D $RESPONSE_HEADER -o $RESPONSE_MSG "


    curl -X POST -H "Content-Type: application/json" -d @${DESCRIPTION_PATH} $CURL_FLAGS -H "Accept: application/json" 2> $HPC_DM_UTILS/temp/curl-status

    #Exit with connection error if response header has no data
    check_connection $RESPONSE_HEADER

    #Process response
    local RESPONSE_CODE=$(get_http_code $RESPONSE_HEADER)
    if [ "$RESPONSE_CODE" -ne 200 ]
    then
      echo "Error updating user \"$USER_ID\" " >&2
      print_error_message "$RESPONSE_MSG" "$RESPONSE_CODE"
      exit 1
    fi
}





# Perform percent/URL encoding on given string 
#
# Copied from GitHub
# https://gist.github.com/cdown/1163649
#
#Input: <string>  string to percent/URL encode
urlencode() {
    # urlencode <string>
    old_lc_collate=$LC_COLLATE
    LC_COLLATE=C
    
    local length="${#1}"
    for (( i = 0; i < length; i++ )); do
        local c="${1:i:1}"
        case $c in
            [a-zA-Z0-9.~_-]) printf "$c" ;;
            *) printf '%%%02X' "'$c" ;;
        esac
    done
    
    LC_COLLATE=$old_lc_collate
}


# Perform percent/URL decoding on given string 
#
# Copied from GitHub
# https://gist.github.com/cdown/1163649
#
#Input: <string>  string to percent/URL decode
urldecode() {
    # urldecode <string>

    local url_encoded="${1//+/ }"
    printf '%b' "${url_encoded//%/\\x}"
}


# Validates a given archive path string, specifically to verify that it 
# does not contain any of the forbidden characters in archive paths.
# The forbidden characters comprise the following quoted string "?;\".
#
# Input: <string> archive path
function validate_archive_path () {
  local USAGE="usage: validate_archive_path <archive-path>"
  if [[ $# -ne 1 ]]
  then
    echo "$USAGE" >&2
  else
    local ARCHIVE_PATH="$1"
    # forbidden chars are [space character] plus {? ; \}
    # notice that in grep regex below, ? be escaped as \? and \ must be escaped as \\
    local GREP_RESULT=$(echo $ARCHIVE_PATH | grep -E '[[:space:]]|[\?;\\]')
    if [ -n "$GREP_RESULT" ]
    then
      echo "ERROR: Given archive path '$ARCHIVE_PATH' contains forbidden character(s) from the set { [space character] ? ; \ }."
    fi
  fi
}

#Print Usage of dm_download_collection function
function dm_download_collection_usage {
  read -d  '' usage <<- EOF
  usage: dm_download_collection [OPTIONS]  <source-path> <destination-path> 

  Download the specified collection from the archive <source-path> to the local <destination-path>. 
  OPTIONS:
  -h                      Print this message 
  -t[NUM_THREADS]         The number of threads to use while downloading files from the archive to the local file system. This number should be between [1, 32].


For detailed information on this command, refer to the following page: 
https://wiki.nci.nih.gov/x/tIWqGQ

EOF
  echo "$usage"
}


#Download a collection from the archive to the file system using the cmd line client.
#Inputs:  <source-path>: The path on the archive
#         <destinaton-path>: The destination path on the local file system 
function dm_download_collection {

    #local USAGE="USAGE: dm_download_collection <source-path> <destination-path>"
    local OPTIND
    
    #Set the default parameters
    numthreads=1

    while getopts ":h:t:" option
    do
      case "${option}" in
        h)
          dm_show_register_directory_usage 
          exit 1
          ;;
        t)
          numthreads="${OPTARG}"
          re='^[0-9]+$'
          if ! [[ "$numthreads" =~ $re ]] ; then
             echo "ERROR: The number of threads $numthreads is not a positive integer." >&2; exit 1
          fi

          if [ "$numthreads" -lt "0" ] || [ "$numthreads" -gt "32" ]
          then
             echo "ERROR: The number of threads $numthreads should be between [1, 32]" >&2; exit 1
          fi
          ;;
        *)
          dm_download_collection_usage >&2
          exit 1
          ;;
      esac
    done

    shift $(( OPTIND-1 ))   

    check_java
    if [ "$?" -ne 0 ]
    then 
      return 1
    fi
    if [ -z "$1" ] || [ -z "$2" ] 
    then
        dm_download_collection_usage >&2
        exit 1 
    fi

    local src_path="$1"
    local dst_path="$2"

    #Check if the jar exists:
    local jar_file=$(get_jar)
    local jar_path=$HPC_DM_UTILS/hpc-client/$jar_file
    if [ ! -f $jar_path ]
    then
      echo "Can not find $jar_path " >&2
      return 1
    fi

    #Make sure the destination directory exists:
    if [ ! -d "$dst_path" ]
    then
      echo "The destination directory: $dst_path does not exist." >&2
      exit 1
    fi 
	
	if [ ! -w "$dst_path" ]
	then 
	echo "The destination directory: $dst_path is not writable." >&2
      exit 1
    fi 
	
    command_args=""

	pushd $dst_path > /dev/null
	if [ "$?" -ne 0 ]
	then
	echo "The destination directory: $dst_path is not accessible." >&2
      exit 1
    fi
	absolute_path=$(pwd)
	popd > /dev/null
	
    #Pass the mandatory arguments
    full_dst_path=$absolute_path
    full_dst_path_converted=$(convert_path "$full_dst_path")
    command_args+=" --sourceArchivePath \"$src_path\" "
    command_args+=" --destinationPath \"$full_dst_path_converted\" "
    command_args+=" --threads $numthreads"

    #Generate the command for the client: 
    local command_file=$HPC_DM_UTILS/temp/cmd-file
    echo "downloadCollection  " $command_args >  $command_file

    case "$(uname -s)" in
    
       Darwin|Linux)
        java -Dhpc.client.properties=$HPC_DM_UTILS/hpcdme.properties -DHPC_DM_UTILS=$HPC_DM_UTILS -Dhttp.proxyHost=$PROXY_IP -Dhttp.proxyPort=$PROXY_PORT -jar $jar_path  --cmdfile $command_file
        exit_code="$?"
       ;;
    
       CYGWIN*|MINGW32*|MSYS*)
            java -DHPC_DM_UTILS=$(cygpath -m $HPC_DM_UTILS) -Dhpc.client.properties=$(cygpath -w $HPC_DM_UTILS/hpcdme.properties)  -jar $(cygpath -w $jar_path)  --cmdfile $(cygpath -w $command_file)
        exit_code="$?"
       ;;
    
       # Add here more strings to compare
       # See correspondence table at the bottom of this answer
    
       *)
         echo 'Current OS not supported' 
         exit 1
         ;;
    esac

    if [ "$exit_code" -eq  "1" ]
    then
      echo "The collection download did not fully complete successfully" >&2
      return 1
    fi

}
