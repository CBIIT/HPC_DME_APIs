#!/usr/bin/env bash
# functions
# @author: George Zaki 
# 
# Copyright Leidos Biomedical Research, Inc
# 
# Distributed under the OSI-approved BSD 3-Clause License.
# See http://ncip.github.com/HPC/LICENSE.txt for details.
#
# Common functions to access the API.



source $HPC_DM_UTILS/utilities

#Generate a DM API authentication token
function dm_generate_token {

    LOG_FILE=$HPC_DM_UTILS/log
    rm $LOG_FILE 2>/dev/null

    SERVER=$(get_server)
    
    curl -k -u `get_username` ${SERVER}/authenticate >  $LOG_FILE
    TOKEN=$(get_json_value $LOG_FILE token)

    if [ -z $TOKEN ]
    then
        echo "ERROR: no token found in $LOG_FILE " >&2
        MESSAGE=$(get_json_value $LOG_FILE message)
        echo "ERROR MESSAGE: $MESSAGE"   
        return 
    else  
      CONFIG_STRING=$(cat "$HPC_DM_UTILS/curl-conf" | sed "s/Bearer.*/Bearer $TOKEN\"/")
      echo "$CONFIG_STRING" > $HPC_DM_UTILS/curl-conf
      rm $LOG_FILE 2>/dev/null
    fi
}

#Generate a Globus authentication token
function dm_globus_generate_token {

    LOG_FILE=$HPC_DM_UTILS/log-globus
    rm $LOG_FILE 2>/dev/null

    SERVER=$(get_globus_server)
    GLOBUS_USER=$(get_globus_user)
    
    curl -u $GLOBUS_USER ${SERVER}/goauth/token?grant_type=client_credentials -s  >  $LOG_FILE
    TOKEN=$(get_json_value $LOG_FILE access_token)

    if [ -z $TOKEN ]
    then
        echo "ERROR: no token found in $LOG_FILE " >&2
        MESSAGE=$(get_json_value $LOG_FILE message)
        echo "ERROR MESSAGE: $MESSAGE"   
        return 
    else  
        GLOBUS_CONFIG=$(cat "$HPC_DM_UTILS/curl-globus" | sed "s@Bearer.*@Bearer $TOKEN\"@")
        echo "$GLOBUS_CONFIG" > $HPC_DM_UTILS/curl-globus
        rm $LOG_FILE 2>/dev/null
    fi
}




#Register a collection or a dataObject 
#Inputs:  <description.json>: The metadata json file 
#         <destinaton-path>: The logical path of the destination
#         <type>: dataObjet or collection 
#         [data-object-file] : For synchronous dataObject registration only
function dm_register {

    USAGE="USAGE: dm_register <description.json> <destination-path> <colleciton|dataObject> [data-object-file]"

    if [ -z "$1" ] || [ -z "$2" ] || [ -z "$3" ]
    then
        echo "ERROR: using dm_register" >&2
        echo "Received: $@" >&2
        echo "$USAGE" >&2
        return
    fi


    if [ ! -z "$4" ]
    then
        DATAOBJECT_FILE="$4"
        if [ ! -e "$DATAOBJECT_FILE" ]
        then 
            echo "ERROR: The data-object-file:$DATAOBJECT_FILE does not exist " >&2
            return
        fi
    fi
        
    DESCRIPTION="$1"
    DESTINATION_PATH="$2"
    TYPE="$3"
    USERID=$(get_username)
    SERVER=$(get_server)

    CONFIG="--config $HPC_DM_UTILS/curl-conf"
    
    RESPONSE_MSG=${TYPE}-registration-response-message.json.tmp
    RESPONSE_HEADER=${TYPE}-registration-response-header.tmp

    rm $RESPONSE_MSG 2>/dev/null 
    rm $RESPONSE_HEADER 2>/dev/null 

    CURL_FLAGS="-X PUT ${SERVER}/${TYPE}/${DESTINATION_PATH}  $CONFIG  -D $RESPONSE_HEADER -o $RESPONSE_MSG "
   
    if [ "$TYPE" == "dataObject" ]
    then
        if [ -z "$DATAOBJECT_FILE" ]
        then
            curl -F "dataObjectRegistration=@$DESCRIPTION;type=application/json" $CURL_FLAGS -H "Accept: application/json"  2> curl-status
        else
            curl -F "dataObjectRegistration=@$DESCRIPTION;type=application/json" -F "dataObject=@$DATAOBJECT_FILE;type=application/octet-stream" $CURL_FLAGS  -H "Accept: application/json"  2> curl-status 
        fi
    elif [ "$TYPE" == "collection" ]
    then

           curl -H "Content-Type: application/json" -d @$DESCRIPTION $CURL_FLAGS  -H "Accept: application/json" 2>curl-status
    else
        echo "ERROR: Unsupported registration type:$TYPE"
        return 
    fi
    check_connection $RESPONSE_HEADER
}

#Register a collection 
#Inputs:  <description.json>: The metadata json file for the collection 
#         <destinaton-path>: The destination logical path
function dm_register_collection {

    USAGE="USAGE: dm_register_collection <description.json> <destination-path>"

    if [ -z "$1" ] || [ -z "$2" ] 
    then
        echo "ERROR: using dm_register_collection" >&2
        echo "Received: $@" >&2
        echo "$USAGE" >&2
        return
    fi

    DESCRIPTION="$1"
    DESTINATION_PATH="$2"
    dm_register $DESCRIPTION $DESTINATION_PATH collection

    RESPONSE_HEADER=collection-registration-response-header.tmp
    RESPONSE_MSG=collection-registration-response-message.json.tmp

    verify_registration "$RESPONSE_HEADER" "$RESPONSE_MSG" "$DESTINATION_PATH"

}


#Register a dataObject 
#Inputs:  <description.json>: The metadata json file for the dataObject 
#         <destinaton-path>: The destination logical path
#         [source-file]: The source file for synchronous registratio.
function dm_register_dataobject {

    USAGE="USAGE: dm_register_dataobject <description.json> <destination-path> [source-file]"

    if [ -z "$1" ] || [ -z "$2" ] 
    then
        echo "ERROR: using dm_register_collection" >&2
        echo "Received: $@" >&2
        echo "$USAGE" >&2
        return
    fi

    DESCRIPTION="$1"
    DESTINATION_PATH="$2"
    SOURCE_FILE="$3"
    dm_register "$DESCRIPTION" "$DESTINATION_PATH" dataObject "$SOURCE_FILE" 

    RESPONSE_HEADER=dataObject-registration-response-header.tmp
    RESPONSE_MSG=dataObject-registration-response-message.json.tmp

    verify_registration "$RESPONSE_HEADER" "$RESPONSE_MSG" "$DESTINATION_PATH"
}

#Sync a folder in the current file system with a logical path in the Archive
#There is no metadata for folder and they will be automatically created.
#The files metadata is the list of attributes/values pair that are returned by the 
#function "get_json-file"
#Inputs: Globus endpoint
#        Source path on Globus endpoint
#        Destination logical path on Archive.
#<source-folder>    The source folder on the file system
#        <destination-path> The destination logical path
function dm_sync_globus_endpoint  {

    USAGE="USAGE: dm_sync_folder <source-folder> <destination-path>"

    if [ -z "$1" ] || [ -z "$2" ] 
    then
        echo "ERROR: using dm_register_collection" >&2
        echo "Received: $@" >&2
        echo "$USAGE" >&2
        return
    fi


    RESPONSE_HEADER=dataObject-registration-response-header.tmp
    RESPONSE_MSG=dataObject-registration-response-message.json.tmp


    FILE_LIST="./test.txt /TEST_Archive/test.txt"

    while read -r  NEW_FILE 
    do 

      SRC_PATH=$(echo $NEW_FILE | cut -d' ' -f1)
      DST_PATH=$(echo $NEW_FILE | cut -d' ' -f2)

      FILE_ATTRIBUTES=$(get_file_attributes $SRC_PATH)      
      DESC_JSON=$(get_json_description $FILE_ATTRIBUTES)
      echo $DESC_JSON >  temp.json
      echo "dm_register_dataobject  temp.json $DST_PATH $SRC_PATH"
      echo "verify_registration  $REPONSE_HEADER $RESPONSE_MSG $DST_PATH"

      rm $RESPONSE_HEADER 2>/dev/null
      rm $RESPONSE_MSG 2>/dev/null

    done <<< "$FILE_LIST"

}



