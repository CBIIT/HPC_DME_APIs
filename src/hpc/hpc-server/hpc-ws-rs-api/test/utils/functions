#!/usr/bin/env bash
# functions
# @author: George Zaki 
# 
# Copyright Leidos Biomedical Research, Inc
# 
# Distributed under the OSI-approved BSD 3-Clause License.
# See http://ncip.github.com/HPC/LICENSE.txt for details.
#
# Common functions used by the unit tests

#Return the HTTP code in the response excluding 100
#Inputs: <response-header-file>
function get_http_code {
    if [ -z "$1" ]
    then
        echo "ERROR: using get_http_code"
        echo "USAGE: get_http_code <http-response-file>"
        exit
    fi
    grep 'HTTP' $1  | grep '[02-9][0-9][0-9]' | sed 's/.*\([0-9][0-9][0-9]\).*/\1/'
}


#If the input is a filename, return the contents of the file, otherwise return the input
#Inputs: <input-string-or-filename>
function get_file_value {
    if [ -z "$1" ]
    then
        echo "ERROR: using get_file_value"
        echo "USAGE: get_file_value <input-string>"
        exit
    fi

    INPUT="$1"
    #Check if the input is a file
    if [ -e "$INPUT" ] 
    then
        INPUT=`cat $INPUT`
    fi
    echo "$INPUT"
}


#Return a single value for a given attribute in a json file 
#Inputs: json-file-name(or input string)  attribute-name 
function get_json_value {

    if [ -z "$1" ] || [ -z "$2" ]
    then
        echo "ERROR: using get_json_value"
        echo "USAGE: get_json_value <input-string-or-file> <attribute>"
        exit
    fi
    INPUT="$1"
    ATTRIBUTE="$2"
    INPUT=`get_file_value "$INPUT"`
    echo "$INPUT" | grep "$ATTRIBUTE" | sed "s/.*${ATTRIBUTE}\"[ 	]*:[ 	]*\"\([^\"]*\)\".*/\1/"
}


#Return the array value for a given attribute in a json file 
#Inputs: json-file-name(or input string)  attribute-name 
function get_json_array_value {

    if [ -z "$1" ] || [ -z "$2" ]
    then
        echo "ERROR: using get_json_array_value"
        echo "USAGE: get_json_array_value <input-string-or-file> <attribute>"
        exit
    fi

    INPUT="$1"
    ATTRIBUTE="$2"
    INPUT=`get_file_value "$INPUT"`
    echo "$INPUT" |  grep $ATTRIBUTE | sed "s/.*${ATTRIBUTE}\"[ 	]*:[ 	]*\[\([^]].*\)\].*/\1/"
}


#Return the hierarchical array value for a given attribute in a json string. 
#Limited to two levels of hierarchy. Example "Attribute":[ []   []  ] 
#Inputs: "Input string"  "attribute-name" 
function get_json_hier_array_value {
    INPUT="$1"
    ATTRIBUTE="$2"

    #First define the regex 'a': <text>[<text>]
    #Then generalize 'a' to define 'b': \(a\)*
    #Then define the matched string as: "attribute":['b'<text>]
    echo "$INPUT" | sed "s/\(.*\)\(\"$ATTRIBUTE\"[  ]*:[ 	]*\[\([^][]*\[[^][]*\]\)*[^][]*\]\)\(.*\)/\2/" 
}


#Return the value for a one line json file with the format "attribute"  "value"
#Inputs: <input-file.json or json string> 
#Inputs: <attribute name > 
function get_json_attribute_value {

    if [ -z "$1" ] || [ -z "$2" ]
    then
        echo "ERROR: using get_json_attribute_value"
        echo "USAGE: get_json_attribute_value <input-string-or-file> <attribute>"
        exit
    fi

    INPUT="$1"
    ATTRIBUTE="$2"
    INPUT=$(get_file_value "$INPUT")


    RESPONSE_GROUPS=$(echo "$INPUT" | tr "{" "\n" | grep "$ATTRIBUTE" )

    #echo "$RESPONSE_GROUPS"
    ACTUAL_VALUE=`get_json_value $RESPONSE_GROUPS value `
    echo $ACTUAL_VALUE
} 

#Checks that the response header file has information.
function check_connection {
    if [ -z "$1" ]
    then
        echo "ERROR: using check_connection"
        echo "USAGE: check_connection <response-file>"
        exit
    fi
    RESPONSE_HEADER="$1"
    if [ -e "$RESPONSE_HEADER" ]
    then 
        CONT=`cat "$RESPONSE_HEADER"`
    fi
    if [ -z "$CONT" ]
    then
        echo "ERROR: THE RESPONSE HEADER FILE $RESPONSE_HEADER IS EMPTY, CHECK CONNECTION" 1>&2
        exit
    fi
}

#Get the username from the config file.
function get_username {
    if [ -z "$1" ]
    then
     #   echo "ERROR: using get_username"
     #   echo "USAGE: get_username <curl-config-file>"
     #   exit
        CURL_CONFIG_FILE=$HPC_DM_TEST/utils/config
    else
        CURL_CONFIG_FILE="$1"
    fi

    USER_NAME=`grep '\-u' "$CURL_CONFIG_FILE" | sed "s/.*\-u[   ]*\([a-zA-Z]*\).*/\1/"`

    #If the username is not in the $CURL_CONFIG_FILE look in the general configuration
    if [ -z "$USER_NAME" ]
    then 
        USER_NAME=$(get_json_value $HPC_DM_TEST/utils/test-configuration username)
    fi

    if [ -z "$USER_NAME" ]
    then 
        echo "ERROR: Can not retrieve username"
        exit 
    fi
    echo $USER_NAME
}


#Get a parameter from the test-configuration file
#Usage get_parameter <parameter_name> 
function get_parameter {

    if [ -z "$1" ]
    then
        echo "ERROR: using get_parameter"
        echo "USAGE: get_parameter <parameter-name>"
        exit
    fi

    CONFIGURATION_FILE="$HPC_DM_TEST/utils/configuration-file"
    PARAMETER_NAME="$1"
    PARAMETER_VALUE=`grep "$PARAMETER_NAME" "$CONFIGURATION_FILE" | sed "s/.*$PARAMETER_NAME[   ]*\([a-zA-Z-0-9]*\).*/\1/"`
    echo $USER_NAME
}



#Verify that a collection or a dataObject  was registered correctly
#Input  registration-response-header
function verify_registration {

    if [ -z "$1" ]
    then
        echo "ERROR: using check_registration"
        echo "USAGE: check_registration <registration-response-header-file>"
        exit
    fi

    RESPONSE_HEADER="$1"
    REG_HTTP_CODE=`get_http_code $RESPONSE_HEADER`
    if [ "$REG_HTTP_CODE" != "201" ]  && [ "$REG_HTTP_CODE" != "200" ]
    then
        echo "FAILED TO REGISTER, HTTP_CODE = $REG_HTTP_CODE" 1>&2
        exit
    fi
}

#Register a collection or a dataObject 
#Inputs: description.json destinaton-path type  [data-object-file]
function curl_register {

    if [ -z "$1" ] || [ -z "$2" ] || [ -z "$3" ]
    then
        echo "ERROR: using curl_register"
        echo "USAGE: curl_register <collection-description.json> destination-path <[colleciton|dataObject]>"
        exit
    fi


    if [ ! -z "$4" ]
    then
        DATAOBJECT_FILE="$4"
        if [ ! -e "$DATAOBJECT_FILE" ]
        then 
            echo "ERROR: The data-object-file:$DATAOBJECT_FILE does not exist "
            exit
        fi
    fi
        
    DESCRIPTION="$1"
    DESTINATION_PATH="$2"
    TYPE="$3"
    USERID=`get_username $HPC_DM_TEST/utils/config`
    SERVER=`cat $HPC_DM_TEST/utils/server`

    RESPONSE_MSG=${TYPE}-registration-response-message.json.tmp
    RESPONSE_HEADER=${TYPE}-registration-response-header.tmp

    CURL_FLAGS="-X PUT ${SERVER}/hpc-server/${TYPE}/${DESTINATION_PATH}  --config $HPC_DM_TEST/utils/config  -H \"Accept: application/json\" -D $RESPONSE_HEADER -o $RESPONSE_MSG -s 2> curl-status"
   
    if [ "$TYPE" == "dataObject" ]
    then
        if [ -z "$DATAOBJECT_FILE" ]
        then
            curl -F "dataObjectRegistration=@$DESCRIPTION;type=application/json" $CURL_FLAGS 
        else
            curl -F "dataObjectRegistration=@$DESCRIPTION;type=application/json" -F dataObject=@"$DATAOBJECT_FILE" $CURL_FLAGS
        fi
    elif [ "$TYPE" == "collection" ]
    then
           curl -H "Content-Type: application/json" -d @$DESCRIPTION $CURL_FLAGS
    else
        echo "ERROR: Unsupported registration type:$TYPE"
        exit
    fi

    check_connection $RESPONSE_HEADER
}

#Substitute the "dxtestuid" string  with the actual username
# and globus-shared-endpoint-uid with the value mentiond in $HPC_DM_TEST/utils/test-configuration  
#Inputs: input_file  output_file
function update_uid {

    if [ -z "$1" ] || [ -z "$2" ]
    then
        echo "ERROR: using update_uid"
        echo "USAGE: update_uid <input-file> <output-file>"
        exit
    fi
    INPUT_FILE="$1"
    OUTPUT_FILE="$2"
    USERID=`get_username $HPC_DM_TEST/utils/config`
    ENDPOINT=$(get_json_value $HPC_DM_TEST/utils/test-configuration globus-shared-endpoint-uid)
    OUT=`cat "$INPUT_FILE" | sed "s/dxtestuid/$USERID/"`
    OUT=`echo "$OUT" | sed "s/globus-shared-endpoint-uid/$ENDPOINT/"`
    echo "$OUT" > $OUTPUT_FILE
}


#Verify the existance of a file in a given Globus endpoint 
#Inputs: <file path on the endpoint>
#Inputs: [EndpointID]
function verify_globus_file {

    if [ "$#" -ne  1 ]  && [ "$#" -ne 2  ]
    then
        echo "ERROR: using verify_globus_file $#"
        echo "USAGE: verify_globus_file <file-path-on-nihnci#NIH-NCI-TRANSFER1> [globus-endpointID]  "
        exit
    fi

    #If endpoint is not passed, use the default endpoint
    if [ "$#" -eq 1 ] 
    then
        FILE_PATH="$1"
        ENDPOINT_ID=$(get_json_value $HPC_DM_TEST/utils/test-configuration globus-shared-endpoint-uid)
    else 
        FILE_PATH="$1"
        ENDPOINT_ID="$2"
    fi

    GLOBUS_CREDENTIALS=$HPC_DM_TEST/utils/globus-config

    #Verify the existance of the credentials file
    if [ ! -e  "$GLOBUS_CREDENTIALS" ]
    then 
        echo "ERROR: Can not find $GLOBUS_CREDENTIALS"
        exit
    fi

    #Get a Globus token
    curl --config $GLOBUS_CREDENTIALS 'https://nexus.api.globusonline.org/goauth/token?grant_type=client_credentials' -s > globus-token.tmp 
    TOKEN=$(get_json_value globus-token.tmp access_token)
    if [ -z "$TOKEN" ]
    then 
        echo "ERROR: Can not get Globus token. Check connection and credentials in $GLOBUS_CREDENTIALS"
        exit
    fi

    #List the files in the path
    PARENT_DIR=$(dirname "$FILE_PATH") 
    curl -H "Authorization : Bearer $TOKEN" "https://transfer.api.globusonline.org/v0.10/operation/endpoint/$ENDPOINT_ID/ls?path=$PARENT_DIR" -s > directory-list.tmp

    FILE_NAME=$(basename $FILE_PATH)
    EXISTS=$(grep  "\"$FILE_NAME\"" directory-list.tmp)
    if [ -z "$EXISTS" ]
    then
        echo "ERROR: Can not find the file $FILE_PATH in the Globus endpoint $ENDPOINT_ID"
        exit
    fi
    
}


#Register a new test user 
#Input: registration-template.json 
function create_new_user {

    if [ -z "$1" ] 
    then
        echo "ERROR: using create_new_user"
        echo "USAGE: create_new_user  <registration-template.json>"
        exit
    fi

    REGISTRATION_TEMPLATE="$1"

    if [ ! -e $REGISTRATION_TEMPLATE ] 
    then
        echo "ERROR: The registration template file:$REGISTRATION_TEMPLATE does not exist "
        exit
    fi  

    SUFFIX=`date +"%b-%d-%G-%H-%M-%S"`
    NEW_USER_ID=testid-$SUFFIX
    UPDATED_FIRST=`cat $REGISTRATION_TEMPLATE | sed "s/testfirst/testfirst-$SUFFIX/"`
    UPDATED_LAST=`echo "$UPDATED_FIRST" | sed "s/testlast/testlast-$SUFFIX/"`
    UPDATED_ID=`echo "$UPDATED_LAST" | sed "s/testid/$NEW_USER_ID/"`
    echo "$UPDATED_ID" > register-user.json.tmp
    echo "$NEW_USER_ID" > new-user-id.tmp 
    
    RESPONSE_HEADER=user-registration-response-header.tmp
    RESPONSE_MSG=user-registration-response-message.json.tmp
    SERVER=`cat $HPC_DM_TEST/utils/server`
    
    curl -H "Content-Type: application/json" -d @register-user.json.tmp -X PUT ${SERVER}/hpc-server/user  --config $HPC_DM_TEST/utils/config  -H "Accept: application/json" -D $RESPONSE_HEADER -o $RESPONSE_MSG -s 2> curl-status
    check_connection $RESPONSE_HEADER
    RESPONSE_CODE=`get_http_code $RESPONSE_HEADER`
    echo $RESPONSE_CODE
}

#Register a new test user using the tempalte
function register_user_from_template {

    TEMPLATE=$HPC_DM_TEST/utils/templates/register-user-template.json
    RESPONSE_CODE=$(create_new_user $TEMPLATE)
    if [ "$RESPONSE_CODE" !=  "201" ] 
    then 
        echo "ERROR: Failed to register new user"
        echo "Response code:$RESPONSE_CODE "
        exit
    fi
}

#Register a new group
#Inputs: registration-input.json
#      : response-header
#      : response-msg
function register_group {

    if [ -z "$1" ] || [ -z "$2" ] || [ -z "$3" ] 
    then
        echo "ERROR: using register_group"
        echo "USAGE: register_group  <input.json> <response-header> <response-msg>"
        exit
    fi

    INPUT_FILE="$1"
    RESPONSE_HEADER="$2"
    RESPONSE_MSG="$3"

    SERVER=`cat $HPC_DM_TEST/utils/server`
    curl -H "Content-Type: application/json" -d @"$INPUT_FILE" -X POST ${SERVER}/hpc-server/group  --config $HPC_DM_TEST/utils/config  -H "Accept: application/json" -D $RESPONSE_HEADER -o $RESPONSE_MSG -s 2> curl-status
    check_connection $RESPONSE_HEADER

}

#Create a new group from template
function register_group_from_template {

    SUFFIX=`date +"%b-%d-%G-%H-%M-%S"`
    NEW_GROUP=group-$SUFFIX
    INPUT_TEMPLATE=$(cat $HPC_DM_TEST/utils/templates/register-new-group-template.json)
    
    ADDED_GROUP=$(echo "$INPUT_TEMPLATE" | sed "s/dxtest-group/$NEW_GROUP/")

    echo "$ADDED_GROUP" > input.json.tmp
    echo "$NEW_GROUP" > new-group-id.tmp

    RESPONSE_MSG=group-registration-response-message.json.tmp
    RESPONSE_HEADER=group-registration-response-header.tmp
    register_group  "input.json.tmp" "$RESPONSE_HEADER" "$RESPONSE_MSG"
}

#Add user to group
#Inputs: groupID
#      : userID 
function add_user_to_group {

    if [ -z "$1" ] || [ -z "$2" ]
    then
        echo "ERROR: using add_user_to_group"
        echo "USAGE: add_user_to_group  <group-id> <user-id>"
        exit
    fi

    GROUP_ID="$1"
    USER_ID="$2"

    INPUT_TEMPLATE=$(cat $HPC_DM_TEST/utils/templates/add-user-to-group-template.json)
    ADDED_USER=$(echo "$INPUT_TEMPLATE" | sed "s/dxtest-new-user/$USER_ID/")
    ADDED_GROUP=$(echo "$ADDED_USER" | sed "s/dxtest-group/$GROUP_ID/")

    echo "$ADDED_GROUP" > input.json.tmp

    RESPONSE_MSG=group-registration-response-message.json.tmp
    RESPONSE_HEADER=group-registration-response-header.tmp

    register_group "input.json.tmp" "$RESPONSE_HEADER" "$RESPONSE_MSG"
}

#Register a new user and a group from template:
function register-user-and-group {


    register_user_from_template
    register_group_from_template

    if ! [ -e new-user-id.tmp ] 
    then
        echo "ERROR: The file new-user.id-tmp does not exist"
        exit 1
    fi

 
    if ! [ -e new-group-id.tmp ] 
    then
        echo "ERROR: The file new-user.id-tmp does not exist"
        exit 1
    fi

    NEW_USER=$(cat new-user-id.tmp )
    NEW_GROUP=$(cat new-group-id.tmp)

    add_user_to_group  "$NEW_GROUP" "$NEW_USER"

}


#Register a new collection user using the project tempalte
#Input: collection-path
function register_collection_from_template {

    if [ -z "$1" ] 
    then
        echo "ERROR: using register_collection_from_template"
        echo "USAGE: register_collection_from_template  <project-path>"
        exit
    fi

    PROJECT_PATH="$1"
    TEMPLATE=$HPC_DM_TEST/utils/templates/register-project-template.json

    curl_register "$TEMPLATE" "$PROJECT_PATH" collection

}



#Register a new dataObject asynchronously using a template 
#Input: <collection-path> "The parent collection for the dataObject"
#Input: [dataObject-path] "the path for the object to replace fileId" 
function register_dataobject_async_from_template {

    if [ -z "$1" ] 
    then
        echo "ERROR: using register_dataobject_async_from_template"
        echo "USAGE: register_dataobject_async_from_template  <collection-path>"
        exit
    fi

    if ! [ -z "$2" ] 
    then
        FILE_ID="$2"
    else 
        FILE_ID="test.txt"
    fi

    COLLECTION_PATH="$1"
    SUFFIX=`date +"%b-%d-%G-%H-%M-%S"`
    DATAOBJECT_PATH="${COLLECTION_PATH}/object-${SUFFIX}.txt"
    echo "$DATAOBJECT_PATH" > registered-data-object-path.tmp


    TEMPLATE=$HPC_DM_TEST/utils/templates/register-dataobject-template.json

    #update the endpoint
    update_uid $TEMPLATE input.json.tmp

    #update the fileId    
    INPUT=$(cat input.json.tmp | sed "s/test\.txt/$FILE_ID/")
    echo "$INPUT" > input.json.tmp

    curl_register input.json.tmp  "$DATAOBJECT_PATH" dataObject 
}


#Register a new dataObject synchronously using a template 
#Input: collection-path "The parent collection for the dataObject"
function register_dataobject_sync_from_template {

    if [ -z "$1" ] 
    then
        echo "ERROR: using register_dataobject_async_from_template"
        echo "USAGE: register_dataobject_async_from_template  <collection-path>"
        exit
    fi

    COLLECTION_PATH="$1"
    SUFFIX=`date +"%b-%d-%G-%H-%M-%S"`
    DATAOBJECT_PATH="${COLLECTION_PATH}/object-${SUFFIX}.txt"
    echo "$DATAOBJECT_PATH" > registered-data-object-path.tmp

    TEMPLATE=$HPC_DM_TEST/utils/templates/upload-input-template.json
    update_uid $TEMPLATE input.json.tmp

    OBJECT_FILE="test-object.tmp"
    echo "test file" > $OBJECT_FILE 
    curl_register input.json.tmp  "$DATAOBJECT_PATH" dataObject "$OBJECT_FILE" 


}

#Download a dataObject synchronously 
#Input: dataObject-path 
function download_dataobject_sync {

    if [ -z "$1" ] 
    then
        echo "ERROR: using download_dataobject_sync"
        echo "USAGE: download_dataobject_sync <dataOjbect-path>"
        exit
    fi

    if [ -z $RESPONSE_HEADER ] 
    then
        $RESPONSE_HEADER=download-dataobject-response-header.tmp
    fi

    if [ -z $RESPONSE_MSG ] 
    then
        $RESPONSE_MSG=download-dataobject-response-message.json.tmp
    fi

    OBJECT_PATH="$1"
    SERVER=`cat $HPC_DM_TEST/utils/server`
    TEMPLATE="$HPC_DM_TEST/utils/templates/download-sync-template.json"
    curl -H "Content-Type: application/json" -d @$TEMPLATE -X POST ${SERVER}/hpc-server/dataObject/$OBJECT_PATH/download  --config $HPC_DM_TEST/utils/config  -H "Accept: application/json" -D $RESPONSE_HEADER -o $RESPONSE_MSG -s 2> curl-status 
    check_connection $RESPONSE_HEADER

}



#Download a dataObject asynchronously to the default globus endpoint
#Input: <dataObject-path>
#Input: [download-template]
function download_dataobject_async {

    if [ -z "$1" ] 
    then
        echo "ERROR: using download_dataobject_sync"
        echo "USAGE: download_dataobject_sync <dataOjbect-path>"
        exit
    fi

    if [ -z $RESPONSE_HEADER ] 
    then
        $RESPONSE_HEADER=download-dataobject-response-header.tmp
    fi

    if [ -z $RESPONSE_MSG ] 
    then
        $RESPONSE_MSG=download-dataobject-response-message.json.tmp
    fi

    OBJECT_PATH="$1"
    SERVER=`cat $HPC_DM_TEST/utils/server`

   
    if [ -z "$2" ]
    then 
        TEMPLATE="$HPC_DM_TEST/utils/templates/download-async-template.json"
    else 
        TEMPLATE="$2"
    fi


    FILE_NAME=$(basename $OBJECT_PATH)
    TEMP=input-temp.json.tmp

    #Update the globus endpoint
    update_uid "$TEMPLATE" "$TEMP"

    #Update the file name 
    INPUT_JSON=$(cat "$TEMP" | sed "s/dxfilename/$FILE_NAME/")
    echo "$INPUT_JSON" > input.json.tmp


    curl -H "Content-Type: application/json" -d @input.json.tmp -X POST ${SERVER}/hpc-server/dataObject/$OBJECT_PATH/download  --config $HPC_DM_TEST/utils/config  -H "Accept: application/json" -D $RESPONSE_HEADER -o $RESPONSE_MSG -s 2> curl-status 
    check_connection $RESPONSE_HEADER

}




#Get an item (collection or dataObject) from the archive
#Inputs: item-path (should have a prefix of "dataObject" or "collection:)
#      : response-header-filename
#      : response-message-filename
function get_item {

    if [ -z "$1" ] || [ -z "$2" ] || [ -z "$3" ]
    then
        echo "ERROR: using get_item"
        echo "USAGE: get_item  <item-path> <response-header-filename> <response-message-filename>"
        exit
    fi

    ITEM_PATH="$1"
    RESPONSE_HEADER="$2"
    RESPONSE_MSG="$3"
    SERVER=`cat $HPC_DM_TEST/utils/server`

    TOTAL_PATH="hpc-server/$ITEM_PATH"
    TOTAL_PATH=$(echo "$TOTAL_PATH" | sed "s#\/\/*#\/#g")
   
    curl -G -X GET "$SERVER/$TOTAL_PATH"  --config $HPC_DM_TEST/utils/config   -D $RESPONSE_HEADER -o $RESPONSE_MSG -s 2> curl-status 
    check_connection $RESPONSE_HEADER
}

