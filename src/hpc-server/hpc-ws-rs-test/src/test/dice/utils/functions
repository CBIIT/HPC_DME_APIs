#!/usr/bin/env bash
# functions
# @author: George Zaki 
# 
# Copyright Leidos Biomedical Research, Inc
# 
# Distributed under the OSI-approved BSD 3-Clause License.
# See http://ncip.github.com/HPC/LICENSE.txt for details.
#
# Common functions used by the unit tests


#prints a message to stderr and exits
#Input: <error_message>
function fail_and_exit {

  error_message=${1:-No error message passed}
  echo "$error_message" >&2
  exit 1

}

#Return the HTTP code in the response excluding 100
#Inputs: <response-header-file>
function get_http_code {
    if [ -z "$1" ]
    then
        echo "ERROR: using get_http_code"
        echo "USAGE: get_http_code <http-response-file>"
        exit
    fi
    grep 'HTTP' $1  | grep '[02-9][0-9][0-9]' | sed 's/.*\([0-9][0-9][0-9]\).*/\1/'
}


#If the input is a filename, return the contents of the file, otherwise return the input
#Inputs: <input-string-or-filename>
function get_file_value {
    if [ -z "$1" ]
    then
        echo "ERROR: using get_file_value"
        echo "USAGE: get_file_value <input-string>"
        exit
    fi

    INPUT="$1"
    #Check if the input is a file
    if [ -e "$INPUT" ] 
    then
        INPUT=`cat $INPUT`
    fi
    echo "$INPUT"
}


#Return a single value for a given attribute in a json file 
#Inputs: json-file-name(or input string)  attribute-name 
function get_json_value {

    if [ -z "$1" ] || [ -z "$2" ]
    then
        echo "ERROR: using get_json_value"
        echo "USAGE: get_json_value <input-string-or-file> <attribute>"
        exit
    fi
    INPUT="$1"
    ATTRIBUTE="$2"
    INPUT=`get_file_value "$INPUT"`
    echo "$INPUT" | grep "$ATTRIBUTE" | sed "s/.*${ATTRIBUTE}\"[ 	]*:[ 	]*\"\([^\"]*\)\".*/\1/"
}

#Return a single unquotted value for a given attribute in a json file 
#Inputs: json-file-name(or input string)  attribute-name 
function get_json_unquotted_value {

    if [ -z "$1" ] || [ -z "$2" ]
    then
        echo "ERROR: using get_json_value"
        echo "USAGE: get_json_value <input-string-or-file> <attribute>"
        exit
    fi
    INPUT="$1"
    ATTRIBUTE="$2"
    INPUT=`get_file_value "$INPUT"`
    echo "$INPUT" | grep "$ATTRIBUTE" | sed "s/.*${ATTRIBUTE}\"[ 	]*:[ 	]*\([^,]*\),.*/\1/"
}





#Return the array value for a given attribute in a json file 
#Inputs: json-file-name(or input string)  attribute-name 
function get_json_array_value {

    if [ -z "$1" ] || [ -z "$2" ]
    then
        echo "ERROR: using get_json_array_value"
        echo "USAGE: get_json_array_value <input-string-or-file> <attribute>"
        exit
    fi

    INPUT="$1"
    ATTRIBUTE="$2"
    INPUT=`get_file_value "$INPUT"`
    echo "$INPUT" |  grep $ATTRIBUTE | sed "s/.*${ATTRIBUTE}\"[ 	]*:[ 	]*\[\([^]].*\)\].*/\1/"
}



#Check the non existance of an attribute/value metadata in from the response header or message.
#Inputs: <RESPONSE_MSG>: The file that contains the response messge
#        <RESPONSE_HDR>: The file that contains the response header 
#        <ATTRIBE>: The attribute
#        <VALUE>: The value to be checked
#
#Returns: echo "TRUE" or "FALSE" 
function check_non_existance {


    if [ ! -e "$1" ]
    then
        echo "ERROR: The response header  file \"$1\" does not exists" >&2
        exit
    fi 


    RESPONSE_HEADER="$1"
    HTTP_CODE=$(verify_get $RESPONSE_HEADER)

    #If I got a response message, check that it does not include the attribute/value pair
    if [ "$HTTP_CODE"  -eq "200"  ]
    then

        if [ ! -e "$2" ]
        then
            echo "ERROR: The response message file \"$2\" does not exists" >&2
            exit
        fi 

        if [ -z "$3" ] || [ -z "$4" ] 
        then
            echo "ERROR: missing input arguments" >&2
            echo "USAGE: check_non_existance <response-msg> <response_header> <attribute> <value>" >&2
            exit
        fi 
    
        RESPONSE_MSG="$2"
        ATTRIBUTE="$3"
        VALUE="$4"
        RES=$(check_existance "$RESPONSE_MSG" "$ATTRIBUTE" "$VALUE" "FALSE")  
    fi
}




#Check the existance of an attribute/value metadata in a response message
#Inputs: <RESPONSE_MSG>: The file that contains the response messge
#        <ATTRIBE>: The attribute
#        <VALUE>: The value to be checked
#        [TEST]: TRUE if attribute should be found, FALSE if not
#
#Returns: echo "TRUE" or "FALSE" 
function check_existance {

    if [ ! -e "$1" ]
    then
        echo "ERROR: The response message file \"$1\" does not exists" >&2
        exit
    fi 

    RESPONSE_MSG="$1"
    if [ -z "$2" ] || [ -z "$3" ] 
    then
        echo "ERROR: missing input arguments" >&2
        echo "USAGE: check_existance <response-msg> <attribute> <value>" >&2
        exit
    fi 
    
    ATTRIBUTE="$2"
    VALUE="$3"

    #Make sure the response does include the object
    RESPONSE_GROUPS=`cat $RESPONSE_MSG | tr "{" "\n"`
    OBJECT_GROUPS=`echo "$RESPONSE_GROUPS" | grep "$ATTRIBUTE"`
    OBJECT_NAMES=`get_json_value "$OBJECT_GROUPS" value`

    OBJECT_FOUND="FALSE"
    for object in "$OBJECT_NAMES"; do
        if [[ $object == *"$VALUE"*  ]]
        then
            OBJECT_FOUND="TRUE"
            break
        fi
    done 
      

    if [ ! -z "$4" ] 
    then
        TEST="$4"
        if [ ! "$OBJECT_FOUND" == "$TEST" ] 
        then
            echo "ERROR: OBJECT \"$VALUE\" does not pass the test $TEST"  1>&2
        fi
    fi

    echo $OBJECT_FOUND 

}

#Return the hierarchical array value for a given attribute in a json string. 
#Limited to two levels of hierarchy. Example "Attribute":[ []   []  ] 
#Inputs: "Input string"  "attribute-name" 
function get_json_hier_array_value {
    INPUT="$1"
    ATTRIBUTE="$2"

    #First define the regex 'a': <text>[<text>]
    #Then generalize 'a' to define 'b': \(a\)*
    #Then define the matched string as: "attribute":['b'<text>]
    echo "$INPUT" | sed "s/\(.*\)\(\"$ATTRIBUTE\"[  ]*:[ 	]*\[\([^][]*\[[^][]*\]\)*[^][]*\]\)\(.*\)/\2/" 
}


#Return the value for a one line json file with the format "attribute"  "value"
#Inputs: <input-file.json or json string> 
#Inputs: <attribute name> 
function get_json_attribute_value {

    if [ -z "$1" ] || [ -z "$2" ]
    then
        echo "ERROR: using get_json_attribute_value"
        echo "USAGE: get_json_attribute_value <input-string-or-file> <attribute>"
        exit
    fi

    INPUT="$1"
    ATTRIBUTE="$2"
    INPUT=$(get_file_value "$INPUT")


    RESPONSE_GROUPS=$(echo "$INPUT" | tr "{" "\n" | grep "$ATTRIBUTE" )

    if [ -z $RESPONSE_GROUPS ]
    then
        echo "Can not find the attribute:$ATTRIBUTE in the input"   
        exit
    fi

    #echo "$RESPONSE_GROUPS"
    ACTUAL_VALUE=`get_json_value $RESPONSE_GROUPS value `
    echo $ACTUAL_VALUE
} 

#Checks that the response header file has information.
function check_connection {
    if [ -z "$1" ]
    then
        echo "ERROR: using check_connection"
        echo "USAGE: check_connection <response-file>"
        exit
    fi
    RESPONSE_HEADER="$1"
    if [ -e "$RESPONSE_HEADER" ]
    then 
        CONT=`cat "$RESPONSE_HEADER"`
    fi
    if [ -z "$CONT" ]
    then
        echo "ERROR: THE RESPONSE HEADER FILE $RESPONSE_HEADER IS EMPTY, CHECK CONNECTION" 1>&2
        exit
    fi
}

#Get the username from the config file.
function get_username {
    if [ -z "$1" ]
    then
     #   echo "ERROR: using get_username"
     #   echo "USAGE: get_username <curl-config-file>"
     #   exit
        CURL_CONFIG_FILE=$HPC_DM_TEST/utils/config
    else
        CURL_CONFIG_FILE="$1"
    fi

    #Make sure the line I get from config is not a token with -u. If the -u is for a username, then the number of 
    #characters  should be less than 40

    USER_NAME_LINE=`grep '\-u' "$CURL_CONFIG_FILE"`
    N_CHAR=${#USER_NAME_LINE}
    if [ "$N_CHAR" -lt "40" ]
    then
        USER_NAME=$(echo "$USER_NAME_LINE" | sed "s/.*\-u[   ]*\([a-zA-Z_]*\).*/\1/")
    fi

    #If the username is not in the $CURL_CONFIG_FILE look in the general configuration
    if [ -z "$USER_NAME" ]
    then 
        USER_NAME=$(get_json_value $HPC_DM_TEST/utils/test-configuration username)
    fi

    if [ -z "$USER_NAME" ]
    then 
        echo "ERROR: Can not retrieve username"
        exit 
    fi
    echo $USER_NAME
}


#Get the globus username from the test configuration file.
function get_globus_user {

    TEST_CONFIG=$HPC_DM_TEST/utils/test-configuration 
    GLOBUS_USER_NAME=$(get_json_value $TEST_CONFIG globus-user)

    if [ -z "$GLOBUS_USER_NAME" ]
    then 
        echo "ERROR: Can not retrieve globus-user from $TEST_CONFIG"
        exit 
    fi
    echo $GLOBUS_USER_NAME
}





#Get the basefolder 
function get_basefolder {

#    BASE_FILE="$HPC_DM_TEST/utils/base-folder"
#    if [ ! -e "$BASE_FILE" ]
#    then
#        echo "ERROR: can not find the base-folder file $BASE_FILE" 1>&2
#        exit
#    fi
#
#    BASE_FOLDER=$(cat $BASE_FILE)
#    if [ -z "$BASE_FOLDER" ]
#    then
#        echo "ERROR: the base-folder file $BASE_FILE is empyt" >&2
#        exit
#    fi

    BASE_FOLDER=$(get_json_value $HPC_DM_TEST/utils/test-configuration base-folder)

    if [ -z "$BASE_FOLDER" ]
    then 
        echo "ERROR: Can not retrieve base-folder from $HPC_DM_TEST/utils/test-configuration "
        exit 
    fi
 

    echo $BASE_FOLDER

}





#Get a parameter from the test-configuration file
#Usage get_parameter <parameter_name> 
function get_parameter {

    if [ -z "$1" ]
    then
        echo "ERROR: using get_parameter"
        echo "USAGE: get_parameter <parameter-name>"
        exit
    fi

    CONFIGURATION_FILE="$HPC_DM_TEST/utils/configuration-file"
    PARAMETER_NAME="$1"
    PARAMETER_VALUE=`grep "$PARAMETER_NAME" "$CONFIGURATION_FILE" | sed "s/.*$PARAMETER_NAME[   ]*\([a-zA-Z-0-9]*\).*/\1/"`
    echo $USER_NAME
}



#Verify that a collection or a dataObject  was registered correctly
#Input  registration-response-header
function verify_registration {

    if [ -z "$1" ]
    then
        echo "ERROR: using check_registration"
        echo "USAGE: check_registration <registration-response-header-file>"
        exit
    fi

    RESPONSE_HEADER="$1"
    REG_HTTP_CODE=`get_http_code $RESPONSE_HEADER`
    if [ "$REG_HTTP_CODE" != "201" ]  && [ "$REG_HTTP_CODE" != "200" ]
    then
        echo "FAILED TO REGISTER, HTTP_CODE = $REG_HTTP_CODE" 1>&2
        exit
    fi
}


#Verify that a get command returned either 200 or 204 
#Input  response-header
#Returns: HTTP_CODE
function verify_get {

    if [ -z "$1" ]
    then
        echo "ERROR: using verify_get"
        echo "USAGE: verify_get <response-header-file>"
        exit
    fi

    RESPONSE_HEADER="$1"
    HTTP_CODE=`get_http_code $RESPONSE_HEADER`
    if [ "$HTTP_CODE" != "200" ]  && [ "$HTTP_CODE" != "204" ]
    then
        echo "FAILED TO GET, HTTP_CODE = $HTTP_CODE" 1>&2
        exit
    fi

    echo "$HTTP_CODE"
}


#Register a collection or a dataObject 
#Inputs: <description.json> <destinaton-path> <type>  [data-object-file]
# If the nvironment varialbe ACTING_USER  is set, it will use it a username
function curl_register {

    if [ -z "$1" ] || [ -z "$2" ] || [ -z "$3" ]
    then
        echo "ERROR: using curl_register"
        echo "USAGE: curl_register <collection-description.json> destination-path <[colleciton|dataObject]>"
        exit
    fi


    if [ ! -z "$4" ]
    then
        DATAOBJECT_FILE="$4"
        if [ ! -e "$DATAOBJECT_FILE" ]
        then 
            echo "ERROR: The data-object-file:$DATAOBJECT_FILE does not exist "
            exit
        fi
    fi
        
    DESCRIPTION="$1"
    DESTINATION_PATH="$2"
    TYPE="$3"
    USERID=`get_username $HPC_DM_TEST/utils/config`
    SERVER=`cat $HPC_DM_TEST/utils/server`

    CONFIG=$(get_curl_config)
    
    #if [ -z "$RESPONSE_MSG" ]
    #then 
        RESPONSE_MSG=${TYPE}-registration-response-message.json.tmp
    #fi

    #if [ -z "$RESPONSE_HEADER" ]
    #then
        RESPONSE_HEADER=${TYPE}-registration-response-header.tmp
    #fi

    #CURL_FLAGS="-X PUT ${SERVER}/${TYPE}/${DESTINATION_PATH}  $CONFIG  -D $RESPONSE_HEADER -o $RESPONSE_MSG -s"
    CURL_FLAGS="-X PUT ${SERVER}/${TYPE}/${DESTINATION_PATH}  $CONFIG  -D $RESPONSE_HEADER -o $RESPONSE_MSG "
   
    if [ "$TYPE" == "dataObject" ]
    then
        if [ -z "$DATAOBJECT_FILE" ]
        then
            curl -F "dataObjectRegistration=@$DESCRIPTION;type=application/json" $CURL_FLAGS -H "Accept: application/json"  2> curl-status
        else
            curl -F "dataObjectRegistration=@$DESCRIPTION;type=application/json" -F "dataObject=@$DATAOBJECT_FILE;type=application/octet-stream" $CURL_FLAGS  -H "Accept: application/json"  2> curl-status 
        fi
    elif [ "$TYPE" == "collection" ]
    then

           curl -H "Content-Type: application/json" -d @$DESCRIPTION $CURL_FLAGS  -H "Accept: application/json" 2>curl-status
    else
        echo "ERROR: Unsupported registration type:$TYPE"
        exit
    fi

    check_connection $RESPONSE_HEADER
}

#Substitute the "dxtestuid" string  with the actual username
# and globus-shared-endpoint-uid with the value in $HPC_DM_TEST/utils/test-configuration  
# and dXBASEFOLDER with the value in $HPC_DM_TEST/utils/test-configuration  
#Inputs: input_file  output_file
function update_uid {

    if [ -z "$1" ] || [ -z "$2" ]
    then
        echo "ERROR: using update_uid"
        echo "USAGE: update_uid <input-file> <output-file>"
        exit
    fi
    INPUT_FILE="$1"
    OUTPUT_FILE="$2"
    USERID=`get_username $HPC_DM_TEST/utils/config` 
    ENDPOINT=$(get_json_value $HPC_DM_TEST/utils/test-configuration globus-shared-endpoint-uid)
    BASE_PATH=$(get_basefolder)
    OUT=`cat "$INPUT_FILE" | sed "s/dxtestuid/$USERID/"`
    OUT=`echo "$OUT" | sed "s/globus-shared-endpoint-uid/$ENDPOINT/"`
    OUT=`echo "$OUT" | sed "s/DXBASEFOLDER/$BASE_PATH/"`
    echo "$OUT" > $OUTPUT_FILE
}


#Verify the existance of a file in a given Globus endpoint 
#Inputs: [-s SLEEP time
#         -e directory listing exists, do not check globus again]
#Inputs: <file path on the endpoint>
#Inputs: [EndpointID]
function verify_globus_file {

    usage="${FUNCNAME} [-s sleep-time] file_path [EndpointID]"
    local OPTIND
    sleep_time=60
    list_exists=false
    while getopts ":s:e" option
    do
      case "${option}" in 
        s)
          sleep_time="${OPTARG}"
          ;;
        e)
          list_exists=true
          ;;
        *)
          echo "ERROR: Unsoported option ${option}" >&2
          echo "$usage" >&2
          exit 1
          ;;
      esac
    done

    shift $(( OPTIND-1 ))
    if [ "$#" -ne  1 ]  && [ "$#" -ne 2  ]
    then
        echo "ERROR: using verify_globus_file $#" >&2
        echo "$usage" >&2
        exit
    fi

    #If endpoint is not passed, use the default endpoint
    if [ "$#" -eq 1 ] 
    then
        FILE_PATH="$1"
        ENDPOINT_ID=$(get_json_value $HPC_DM_TEST/utils/test-configuration globus-shared-endpoint-uid)
    else 
        FILE_PATH="$1"
        ENDPOINT_ID="$2"
    fi

    ls_file=directory-list.tmp
    if [ $list_exists == "false" ]
    then 

        #This verifies that globus CLI is present
        which globus > /dev/null || fail_and_exit "ERROR:No globus CLI, READ $HPC_DM_TEST/README.txt" 
 

        #List the files in the path
        PARENT_DIR=$(dirname "$FILE_PATH") 
    
        #Sleep a bit for Globus to be updated
        sleep $sleep_time 
    
        globus ls "$ENDPOINT_ID:$PARENT_DIR" > $ls_file
    fi

    FILE_NAME=$(basename $FILE_PATH)
    EXISTS=$(grep  "$FILE_NAME" $ls_file)
    if [ -z "$EXISTS" ]
    then
        echo "ERROR: Can not find the file $FILE_PATH in the Globus endpoint $ENDPOINT_ID"
        exit
    fi
    
}


#Get a user 
#Inputs:    userid
#           response-header      
#           response-message
function get_user {

    usage="USAGE: get_user <userid> <response-header> <response-message>"

    nargs=$#
    if [ "$nargs" -ne  "3" ]
    then
        echo "ERROR: using get_user" >&2
        echo "received $nargs arguments." >&2
        echo "$usage" >&2 
        exit
    fi

    USER_ID="$1"
    RESPONSE_HEADER="$2"
    RESPONSE_MSG="$3"
    
    SERVER=`cat $HPC_DM_TEST/utils/server`
   
    curl  -X GET ${SERVER}/user/$USER_ID  --config $HPC_DM_TEST/utils/config  -H "Accept: application/json" -D $RESPONSE_HEADER -o $RESPONSE_MSG -s 2> curl-status
    check_connection $RESPONSE_HEADER
}



#Enroll a user 
#Inputs:    userid
#           registration-template.json 
#           response-header      
#           response-message
function enroll_user {

    usage="USAGE: enroll_user <userid> <registration-template.json> <response-header> <response-message>"

    nargs=$#
    if [ "$nargs" -ne  "4" ]
    then
        echo "ERROR: using enroll_user" >&2
        echo "received $nargs arguments." >&2
        echo "$usage" >&2 
        exit
    fi

    USER_ID="$1"
    REGISTRATION_TEMPLATE="$2"
    RESPONSE_HEADER="$3"
    RESPONSE_MSG="$4"

    if [ ! -e $REGISTRATION_TEMPLATE ] 
    then
        echo "ERROR: The registration template file:$REGISTRATION_TEMPLATE does not exist "
        exit
    fi  
    
    SERVER=`cat $HPC_DM_TEST/utils/server`
    CONFIG=$(get_curl_config)
   
    curl  -X PUT -H "Content-Type: application/json" -d @$REGISTRATION_TEMPLATE ${SERVER}/user/$USER_ID $CONFIG   -H "Accept: application/json" -D $RESPONSE_HEADER -o $RESPONSE_MSG -s 2> curl-status
    check_connection $RESPONSE_HEADER
}



#Register a new test user 
#Input: registration-template.json 
function create_new_user {

    if [ -z "$1" ] 
    then
        echo "ERROR: using create_new_user"
        echo "USAGE: create_new_user  <registration-template.json>"
        exit
    fi

    REGISTRATION_TEMPLATE="$1"

    if [ ! -e $REGISTRATION_TEMPLATE ] 
    then
        echo "ERROR: The registration template file:$REGISTRATION_TEMPLATE does not exist "
        exit
    fi  

    sleep 1
    SUFFIX=`date +"%b-%d-%G-%H-%M-%S"`
    NEW_USER_ID=testid-$SUFFIX
    NEW_FIRST_NAME=testfirst-$SUFFIX
    NEW_LAST_NAME=testlast-$SUFFIX
    UPDATED_FIRST=`cat $REGISTRATION_TEMPLATE | sed "s/testfirst/$NEW_FIRST_NAME/"`
    UPDATED_LAST=`echo "$UPDATED_FIRST" | sed "s/testlast/$NEW_LAST_NAME/"`
    echo "$UPDATED_LAST" > register-user.json.tmp
    echo "$NEW_USER_ID" > new-user-id.tmp 
    echo "$NEW_FIRST_NAME" > new-first-name.tmp 
    echo "$NEW_LAST_NAME" > new-last-name.tmp 
    
    RESPONSE_HEADER=user-registration-response-header.tmp
    RESPONSE_MSG=user-registration-response-message.json.tmp

    enroll_user $NEW_USER_ID register-user.json.tmp $RESPONSE_HEADER $RESPONSE_MSG

    RESPONSE_CODE=`get_http_code $RESPONSE_HEADER`
    echo $RESPONSE_CODE
}




#Register a new test user using the tempalte
function register_user_from_template {

    TEMPLATE=$HPC_DM_TEST/utils/templates/register-user-template.json
    RESPONSE_CODE=$(create_new_user $TEMPLATE)
    if [ "$RESPONSE_CODE" !=  "201" ] 
    then 
        echo "ERROR: Failed to register new user"
        echo "Response code:$RESPONSE_CODE "
        exit
    fi

}

#Update existing user 
#Inputs userid: The ID of the user
#       update-template: A json file with the updated attributes/values
#       response-header: the response header file 
#       response-message: the response message file 

function update_existing_user {

    usage="USAGE: update_user <userid> <update-template.json> <response-header> <response-message>"

    nargs=$#
    if [ "$nargs" -ne  "4" ]
    then
        echo "ERROR: using update_existing_user" >&2
        echo "received $nargs arguments." >&2
        echo "$usage" >&2 
        exit
    fi

    USER_ID="$1"
    UPDATES="$2"
    RESPONSE_HEADER="$3"
    RESPONSE_MSG="$4"


    if [ ! -e $UPDATES ] 
    then
        echo "ERROR: The update template file:$UPDATES does not exist "
        exit
    fi  
    
    
    SERVER=`cat $HPC_DM_TEST/utils/server`
    
    curl -H "Content-Type: application/json" -d @$UPDATES -X POST ${SERVER}/user/$USER_ID  --config $HPC_DM_TEST/utils/config  -H "Accept: application/json" -D $RESPONSE_HEADER -o $RESPONSE_MSG -s 2> curl-status 
    check_connection $RESPONSE_HEADER
}


#Search users 
#Inputs:     
#       [-u userID]
#       [-f firstName]
#       [-l lastName]
#       [-a] search all users, default is active only
function search_users {

    usage="USAGE: search_users -u [userid] -f [first-name] -l [last-name] -a"

    OPTIND=1
    search_args=

    #By default, search the active users only
    subset=active
    while getopts ":u:f:l:a" opt; do
        case $opt in
        a)
            subset=all
            ;;
        u)
            search_args="$search_args --data-urlencode nciUserId=$OPTARG" 
            ;;
        f)
            search_args="$search_args --data-urlencode firstNamePattern=$OPTARG" 
            ;;
        l)
            search_args="$search_args --data-urlencode lastNamePattern=$OPTARG" 
            ;;
        \?)
            echo "Invalid option: -$OPTARG" >&2
            echo $USAGE >&2
            exit 1
            ;;
        :)
            echo "Option -$OPTARG requires an argument." >&2
            echo $USAGE >&2
            exit 1
            ;;
        esac
    done

    response_hdr="search-$subset-users-response-header.tmp"
    response_msg="search-$subset-users-response-message.json.tmp"
    config=$(get_curl_config) 
    SERVER=`cat $HPC_DM_TEST/utils/server`
   
    curl  -G ${SERVER}/user/$subset $search_args  $config -H "Accept: application/json" -D $response_hdr -o $response_msg -s 2> curl-status
    check_connection $response_hdr
}


#Search groups
#Inputs:     
#       [search criteria]
function search_groups {

    usage="USAGE: search_groups  [search_criteria]"
    search_args=
    if [ ! -z "$1" ]
    then
        search_args="--data-urlencode groupPattern=$1"
    fi

    response_hdr="search-groups-response-header.tmp"
    response_msg="search-groups-response-message.json.tmp"
    config=$(get_curl_config) 
    SERVER=`cat $HPC_DM_TEST/utils/server`
   
    curl  -G ${SERVER}/group $search_args  $config -H "Accept: application/json" -D $response_hdr -o $response_msg -s 2> curl-status
    check_connection $response_hdr
}


#Update an existing  group
#Inputs: registration-input.json 
#      : group-name
#      : response-header
#      : response-msg
function update_group {

    USAGE="update_group  <input.json> <group-name> <response-header> <response-msg>"

    if [ "$#" -lt 4 ] 
    then
        echo "ERROR: using update_group" >&2
        echo "$USAGE" >&2
        exit 1
    fi

    INPUT_FILE="$1"
    GROUP_NAME="$2"
    RESPONSE_HEADER="$3"
    RESPONSE_MSG="$4"

    SERVER=`cat $HPC_DM_TEST/utils/server`
    CONFIG=$(get_curl_config)
    curl -H "Content-Type: application/json" -d @"$INPUT_FILE" -X POST ${SERVER}/group/$GROUP_NAME  $(get_curl_config)  -H "Accept: application/json" -D $RESPONSE_HEADER -o $RESPONSE_MSG -s 2> curl-status
    check_connection $RESPONSE_HEADER

}





#Register a new group
#Inputs: registration-input.json 
#      : group-name
#      : response-header
#      : response-msg
function register_group {

    USAGE="register_group  <input.json> <group-name> <response-header> <response-msg>"

    if [ "$#" -lt 4 ] 
    then
        echo "ERROR: using register_group" >&2
        echo "Got: $@" >&2
        echo "$USAGE" >&2
        exit 1
    fi

    INPUT_FILE="$1"
    GROUP_NAME="$2"
    RESPONSE_HEADER="$3"
    RESPONSE_MSG="$4"
    CONFIG=$(get_curl_config) 


    SERVER=`cat $HPC_DM_TEST/utils/server`


    curl -H "Content-Type: application/json" -d @"$INPUT_FILE" -X PUT ${SERVER}/group/"$GROUP_NAME"  $CONFIG  -H "Accept: application/json" -D $RESPONSE_HEADER -o $RESPONSE_MSG -s 2> curl-status

    check_connection $RESPONSE_HEADER

}

#Create a new group from template
#Arguments:   [group-name] 
function register_group_from_template {


    if [ -z "$1" ]
    then 
        sleep 1
        SUFFIX=`date +"%b-%d-%G-%H-%M-%S"`
        NEW_GROUP=group-$SUFFIX
    else
        NEW_GROUP="$1"
    fi 

    INPUT_TEMPLATE=$HPC_DM_TEST/utils/templates/register-new-group-template.json
    
    ADDED_GROUP=$(echo "$INPUT_TEMPLATE" | sed "s/dxtest-group/$NEW_GROUP/")

    cp $INPUT_TEMPLATE input.json.tmp
    echo "$NEW_GROUP" > new-group-id.tmp

    RESPONSE_MSG=group-registration-response-message.json.tmp
    RESPONSE_HEADER=group-registration-response-header.tmp
    register_group  "input.json.tmp" "$NEW_GROUP" "$RESPONSE_HEADER" "$RESPONSE_MSG"
}

#Add user to group
#Inputs: groupID
#      : userID 
function add_user_to_group {

    if [ -z "$1" ] || [ -z "$2" ]
    then
        echo "ERROR: using add_user_to_group"
        echo "USAGE: add_user_to_group  <group-id> <user-id>"
        exit
    fi

    GROUP_ID="$1"
    USER_ID="$2"

    INPUT_TEMPLATE=$(cat $HPC_DM_TEST/utils/templates/add-user-to-group-template.json)
    ADDED_USER=$(echo "$INPUT_TEMPLATE" | sed "s/dxtest-new-user/$USER_ID/")

    echo "$ADDED_USER" > input.json.tmp

    RESPONSE_MSG=group-update-response-message.json.tmp
    RESPONSE_HEADER=group-update-response-header.tmp

    update_group "input.json.tmp" "$GROUP_ID" "$RESPONSE_HEADER" "$RESPONSE_MSG"
}


#Remove user from group
#Inputs: groupID
#      : userID 
function remove_user_from_group {

    if [ -z "$1" ] || [ -z "$2" ]
    then
        echo "ERROR: using remove_user_to_group"
        echo "USAGE: remove_user_to_group  <group-id> <user-id>"
        exit
    fi

    GROUP_ID="$1"
    USER_ID="$2"

    INPUT_TEMPLATE=$(cat $HPC_DM_TEST/utils/templates/remove-user-from-group-template.json)
    REMOVED_USER=$(echo "$INPUT_TEMPLATE" | sed "s/dxtest-new-user/$USER_ID/")

    echo "$REMOVED_USER" > input.json.tmp

    RESPONSE_MSG=group-update-response-message.json.tmp
    RESPONSE_HEADER=group-update-response-header.tmp

    update_group "input.json.tmp" "$GROUP_ID" "$RESPONSE_HEADER" "$RESPONSE_MSG"
}



#Register a new user and a group from template:
function register_user_and_group {


    register_user_from_template
    register_group_from_template

    if ! [ -e new-user-id.tmp ] 
    then
        echo "ERROR: The file new-user.id-tmp does not exist"
        exit 1
    fi

 
    if ! [ -e new-group-id.tmp ] 
    then
        echo "ERROR: The file new-user.id-tmp does not exist"
        exit 1
    fi

    NEW_USER=$(cat new-user-id.tmp )
    NEW_GROUP=$(cat new-group-id.tmp)

    add_user_to_group  "$NEW_GROUP" "$NEW_USER"

}


#Register a new collection user using the project tempalte
#Input: collection-path
function register_collection_from_template {

    if [ -z "$1" ] 
    then
        echo "ERROR: using register_collection_from_template"
        echo "USAGE: register_collection_from_template  <project-path>"
        exit
    fi

    PROJECT_PATH="$1"
    TEMPLATE=$HPC_DM_TEST/utils/templates/register-project-template.json

    curl_register "$TEMPLATE" "$PROJECT_PATH" collection

}



#Register a new dataObject asynchronously using a template 
#Input: <collection-path> "The parent collection for the dataObject"
#Input: [dataObject-path] "the path for the object to replace fileId" 
function register_dataobject_async_from_template {

    if [ -z "$1" ] 
    then
        echo "ERROR: using register_dataobject_async_from_template"
        echo "USAGE: register_dataobject_async_from_template  <collection-path>"
        exit
    fi

    if ! [ -z "$2" ] 
    then
        FILE_ID="$2"
    else 
        FILE_ID="test.txt"
    fi

    COLLECTION_PATH="$1"
    sleep 1
    SUFFIX=`date +"%b-%d-%G-%H-%M-%S"`
    DATAOBJECT_PATH="${COLLECTION_PATH}/object-${SUFFIX}.txt"
    echo "$DATAOBJECT_PATH" > registered-data-object-path.tmp


    TEMPLATE=$HPC_DM_TEST/utils/templates/register-dataobject-template.json

    #update the endpoint
    update_uid $TEMPLATE input.json.tmp

    #update the fileId    
    INPUT=$(cat input.json.tmp | sed "s/test\.txt/$FILE_ID/")
    echo "$INPUT" > input.json.tmp

    curl_register input.json.tmp  "$DATAOBJECT_PATH" dataObject 
}


#Register a new dataObject synchronously using a template 
#Input: <collection-path> "The parent collection for the dataObject"
#Input: [object-name] "The name of the dataObject"
function register_dataobject_sync_from_template {

    USAGE="USAGE: register_dataobject_sync_from_template  <collection-path> [object-name]"

    if [ -z "$1" ] 
    then
        echo "ERROR: using register_dataobject_sync_from_template"
        echo "$USAGE"
        exit
    fi

    if [ ! -z "$2" ] 
    then
        OBJECT_NAME="$2" 
    else 
        sleep 1
        SUFFIX=`date +"%b-%d-%G-%H-%M-%S"`
        OBJECT_NAME="object-${SUFFIX}.txt"
    fi


    COLLECTION_PATH="$1"
    SUFFIX=`date +"%b-%d-%G-%H-%M-%S"`
    DATAOBJECT_PATH="${COLLECTION_PATH}/${OBJECT_NAME}"
    echo "$DATAOBJECT_PATH" > registered-data-object-path.tmp

    TEMPLATE=$HPC_DM_TEST/utils/templates/upload-input-template.json
    update_uid $TEMPLATE input.json.tmp

    OBJECT_FILE="test-object.tmp"
    echo "test file" > $OBJECT_FILE 
    curl_register input.json.tmp  "$DATAOBJECT_PATH" dataObject "$OBJECT_FILE" 


}

#Download a dataObject synchronously 
#Input: dataObject-path 
function download_dataobject_sync {

    if [ -z "$1" ] 
    then
        echo "ERROR: using download_dataobject_sync"
        echo "USAGE: download_dataobject_sync <dataOjbect-path>"
        exit
    fi

    if [ -z $RESPONSE_HEADER ] 
    then
        RESPONSE_HEADER=download-dataobject-response-header.tmp
    fi

    if [ -z $RESPONSE_MSG ] 
    then
        RESPONSE_MSG=download-dataobject-response-message.json.tmp
    fi

    OBJECT_PATH="$1"
    SERVER=`cat $HPC_DM_TEST/utils/server`
    TEMPLATE="$HPC_DM_TEST/utils/templates/download-sync-template.json"
    curl -H "Content-Type: application/json" -d @$TEMPLATE -X POST ${SERVER}/dataObject/$OBJECT_PATH/download  $(get_curl_config)  -H "Accept: application/json" -D $RESPONSE_HEADER -o $RESPONSE_MSG -s 2> curl-status 
    check_connection $RESPONSE_HEADER

}



#Download a dataObject or a collection asynchronously to the default globus endpoint
#Input: <item-path> 
#Input: [download-template]
function download_async {

    if [ "$#" -lt 1 ]
    then
        echo "ERROR: using download_async"
        echo "USAGE: download_async <item-path> [download-template]"
        exit
    fi


    if [ -z $RESPONSE_HEADER ] 
    then
        RESPONSE_HEADER=download-response-header.tmp
    fi

    if [ -z $RESPONSE_MSG ] 
    then
        RESPONSE_MSG=download-response-message.json.tmp
    fi

    ITEM_PATH="$1"
    SERVER=`cat $HPC_DM_TEST/utils/server`

    if [ "$ITEM_PATH" != ""  ]
    then
      ITEM_NAME=$(basename ${ITEM_PATH})
      ITEM_PATH=/${ITEM_PATH}
    else
      ITEM_NAME=""
    fi
   
    if [ -z "$2" ]
    then 
        TEMPLATE="$HPC_DM_TEST/utils/templates/download-async-template.json"
    else 
        TEMPLATE="$2"
    fi

    TEMP=download-input-temp.json.tmp
    #Update the globus endpoint
    update_uid "$TEMPLATE" "$TEMP"

    #Update the file name 
    INPUT_JSON=$(cat "$TEMP" | sed "s@dxfilename@$ITEM_NAME@")
    echo "$INPUT_JSON" > input.json.tmp

    curl -H "Content-Type: application/json" -d @input.json.tmp -X POST ${SERVER}${ITEM_PATH}/download  --config $HPC_DM_TEST/utils/config  -H "Accept: application/json" -D $RESPONSE_HEADER -o $RESPONSE_MSG -s 2> curl-status 
    check_connection $RESPONSE_HEADER
}



#Get the status of asynchronousl download request 
#Input: <taskId>  a numerical id for the download receipt
#Input: <type> dataObject or collection
function get_download_status {

    usage="USAGE: get_download_status <taskId> <type>"
    if [ "$#" -ne 2 ]
    then
        echo "ERROR: using get_download_status"
        echo "Received: $*" >&2
        echo "$usage"  >&2
        exit 1
    fi

    RESPONSE_HEADER=get-download-status-response-header.tmp
    RESPONSE_MSG=get-download-status-response-message.json.tmp

    taskId="$1"
    request_type="$2"

    if [ "$request_type" != "" ]
    then
      request_type=/${request_type}
    fi

    
    #Verify that taskId is a numerical value
    #re='^[0-9]+$'
    #if ! [[ "$taskId" =~ $re ]] ; then
    #    echo "ERROR: taskId $taskId is not a number" >&2; 
    #    exit 1
    #fi

    SERVER=`cat $HPC_DM_TEST/utils/server`

    
    curl -G -X GET ${SERVER}${request_type}/download?taskId="$taskId"  --config $HPC_DM_TEST/utils/config  -H "Accept: application/json" -D $RESPONSE_HEADER -o $RESPONSE_MSG -s 2> curl-status 
    check_connection $RESPONSE_HEADER
}




#Subscribe to all the notifications mentioned in the $HPC_DM_TEST/utils/templates/notifications-template.json
#Inputs: notification_file 
#        [userID]
function subscribe_to_notifications {


    if [ -z "$1" ] 
    then
        echo "ERROR: using subscribe_to_notifications"
        echo "USAGE: subscribe_to_notifications <notification_file>"
        exit
    fi

    INPUT_FILE="$1"

    if ! [ -e "$INPUT_FILE" ]  
    then
        echo "ERROR the input file \"$INPUT_FILE\" does not exist."
        exit
    fi

    if [ -z $RESPONSE_HEADER ] 
    then
        RESPONSE_HEADER=subscribe-notifications-response-header.tmp
    fi

    if [ -z $RESPONSE_MSG ] 
    then
        RESPONSE_MSG=subscribe-notifications-response-message.json.tmp
    fi

    if [ -z "$2" ] 
    then
        USERID=`get_username $HPC_DM_TEST/utils/config`
    else
        USERID="$2"
    fi

    NOTIFICATION_INPUT=dxdice-notification-input.json.tmp  
    cp $INPUT_FILE $NOTIFICATION_INPUT 

    SERVER=`cat $HPC_DM_TEST/utils/server`

    curl -H "Content-Type: application/json" -d @$NOTIFICATION_INPUT -X POST ${SERVER}/notification  --config $HPC_DM_TEST/utils/config  -H "Accept: application/json" -D $RESPONSE_HEADER -o $RESPONSE_MSG -s 2> curl-status 

    check_connection $RESPONSE_HEADER
}

#Get the notifications for a particular user
function get_notifications {

    if [ -z $RESPONSE_HEADER ] 
    then
        RESPONSE_HEADER=subscribe-notifications-response-header.tmp
    fi

    if [ -z $RESPONSE_MSG ] 
    then
        RESPONSE_MSG=subscribe-notifications-response-message.json.tmp
    fi

    USERID=`get_username $HPC_DM_TEST/utils/config`
    SERVER=`cat $HPC_DM_TEST/utils/server`


    curl -G -X GET $SERVER/notification --config $HPC_DM_TEST/utils/config   -D $RESPONSE_HEADER -o $RESPONSE_MSG -s 2> curl-status 

    check_connection $RESPONSE_HEADER
}


#Get the notifications receipts for a particular user
function get_notification_receipts {

    if [ -z $RESPONSE_HEADER ] 
    then
        #RESPONSE_HEADER=get-notifications-response-header.tmp 
        RESPONSE_HEADER=get-delived-notifications-response-header.tmp 
    fi

    if [ -z $RESPONSE_MSG ] 
    then
        #RESPONSE_MSG=get-notifications-response-message.json.tmp
        RESPONSE_MSG=get-delivered-notifications-response-message.json.tmp
    fi

    SERVER=`cat $HPC_DM_TEST/utils/server`


    curl -G -X GET $SERVER/notification/deliveryReceipts?totalCount=true --config $HPC_DM_TEST/utils/config   -D $RESPONSE_HEADER -o $RESPONSE_MSG -s 2> curl-status 

    check_connection $RESPONSE_HEADER
}




#Get the metadata attributes for a user 
function get_metadata_attributes {

    if [ -z $RESPONSE_HEADER ] 
    then
        RESPONSE_HEADER=metatadata-attributes-response-header.tmp
    fi

    if [ -z $RESPONSE_MSG ] 
    then
        RESPONSE_MSG=metadata-attributes-response-message.json.tmp
    fi

    SERVER=`cat $HPC_DM_TEST/utils/server`


    curl -G -X GET $SERVER/metadataAttributes --config $HPC_DM_TEST/utils/config   -D $RESPONSE_HEADER -o $RESPONSE_MSG -s 2> curl-status 
    check_connection $RESPONSE_HEADER
}



#Get the delivered notifications for a user 
#Parameters:
#           [page] The page number for the notifications
#           [totalcount] The page number for the notifications
function get_delivered_notifications {
    
    USAGE="USAGE: get_delivered_notificationn <page> <totalcount>"

    if [-z "$1" ]
    then
        echo "ERROR: missing the page parameter." >&2
        echo "$USAGE" >&2
        exit
    fi

    if [-z "$2" ]
    then
        echo "ERROR: missing the totalcount parameter." >&2
        echo "$USAGE" >&2
        exit
    fi

    PAGE="$1"
    TOTAL_COUNT="$2"
    if [ -z $RESPONSE_HEADER ] 
    then
        RESPONSE_HEADER=delivered-notifications-response-header.tmp
    fi

    if [ -z $RESPONSE_MSG ] 
    then
        RESPONSE_MSG=delivered-notifications-response-message.json.tmp
    fi

    USERID=`get_username $HPC_DM_TEST/utils/config`
    SERVER=`cat $HPC_DM_TEST/utils/server`

    echo "curl -G -X GET $SERVER/notification/deliveryReceipts?page=$PAGE&totalcount --config $HPC_DM_TEST/utils/config   -D $RESPONSE_HEADER -o $RESPONSE_MSG -s 2> curl-status"

    check_connection $RESPONSE_HEADER
}




#search  for a collection or an object by metadata
# Arguments :<type> Either collection or dataObject
#           :<query> The .json query file
#           :[user] The user to submit the query  
function search_by_metadata {
    if [ -z "$1" ] || [ -z "$2" ]
    then 
        echo "ERROR: using search_by_metadata"
        echo "USAGE: search_by_metadata <type> <query>"     
        exit
    fi

    TYPE="$1"
    QUERY="$2"

    if [ -z "$3" ]
    then
        CONFIG="--config $HPC_DM_TEST/utils/config"
    else
        USER=$3
        #TODO: note -k is not required, this is a random password
        CONFIG="-k -u ${USER}:password"
    fi

    if [ "$TYPE" != "collection" ] && [ "$TYPE" != "dataObject" ]
    then
        echo "ERROR: type shoube be either collection or dataObject"
        exit
    fi

    if [ ! -e "$QUERY" ]
    then
        echo "ERROR: the query file $QUERY does not exist"
        exit
    fi


    if [ -z "$RESPONSE_HEADER" ]
    then
        RESPONSE_HEADER=search-response-header.tmp
    fi


    if [ -z "$RESPONSE_MSG" ]
    then
        RESPONSE_MSG=search-response-msg.json.tmp
    fi

    SERVER=`cat $HPC_DM_TEST/utils/server`
    #CONFIG=$HPC_DM_TEST/utils/config 

    curl -G -X GET $SERVER/$TYPE?detailedResponse=true --data-urlencode metadataQuery@$QUERY $CONFIG   -D $RESPONSE_HEADER -o $RESPONSE_MSG -s 2> curl-status 

    check_connection $RESPONSE_HEADER
}


# query a collection or an object by metadata
# using the compound search API
# Arguments :<type> Either collection or dataObject
#           :<query> The .json query file
#           :[user] The user to submit the query  
function query_by_metadata {
    if [ -z "$1" ] || [ -z "$2" ]
    then 
        echo "ERROR: using query_by_metadata"
        echo "USAGE: query_by_metadata <type> <query> [user]"     
        exit
    fi

    TYPE="$1"
    QUERY="$2"

    if [ -z "$3" ]
    then
        CONFIG="--config $HPC_DM_TEST/utils/config"
    else
        USER=$3
        #if the passed user is the same as the user in config, use config, otherwise, use a different user  
        CONFIG_USER=$(get_username)
        if [ "$USER"  = "$CONFIG_USER" ]
        then
            CONFIG="--config $HPC_DM_TEST/utils/config"
        else
            #TODO: note -k is not required, this is a random password
            CONFIG="-k -u ${USER}:password"
        fi
    fi

    if [ "$TYPE" != "collection" ] && [ "$TYPE" != "dataObject" ]
    then
        echo "ERROR: type shoube be either collection or dataObject"
        exit
    fi

    if [ ! -e "$QUERY" ]
    then
        echo "ERROR: the query file $QUERY does not exist"
        exit
    fi

    if [ -z "$RESPONSE_HEADER" ]
    then
        RESPONSE_HEADER=search-response-header.tmp
    fi

    if [ -z "$RESPONSE_MSG" ]
    then
        RESPONSE_MSG=search-response-msg.json.tmp
    fi

    SERVER=`cat $HPC_DM_TEST/utils/server`
    #CONFIG=$HPC_DM_TEST/utils/config 

    curl -H "Content-Type: application/json" -d @"$QUERY" -X POST $SERVER/$TYPE/query $CONFIG  -H "Accept: application/json" -D $RESPONSE_HEADER -o $RESPONSE_MSG -s 2> curl-status 

    check_connection $RESPONSE_HEADER
}



# query a collection or an object by save query 
# Arguments :<type> Either collection or dataObject
#           :<query-name> 
function query_by_saved_name {
    if [ -z "$1" ] || [ -z "$2" ]
    then 
        echo "ERROR: using query_by_saved_name"
        echo "USAGE: query_by_saved_name <type> <query-name>"     
        exit
    fi

    TYPE="$1"
    QUERY="$2"

    CONFIG="--config $HPC_DM_TEST/utils/config"
        
    if [ "$TYPE" != "collection" ] && [ "$TYPE" != "dataObject" ]
    then
        echo "ERROR: type shoube be either collection or dataObject"
        exit
    fi

    RESPONSE_HEADER=query-response-header.tmp
    RESPONSE_MSG=query-response-msg.json.tmp

    SERVER=`cat $HPC_DM_TEST/utils/server`

    curl -X GET $SERVER/$TYPE/query/$QUERY $CONFIG  -H "Accept: application/json" -D $RESPONSE_HEADER -o $RESPONSE_MSG -s 2> curl-status 

    check_connection $RESPONSE_HEADER
}




# save a query
#           :<query> The .json query file
#           :<query-name> The query name 
function save_query {

    if [ -z "$1" ]  || [ -z "$2" ]
    then 
        echo "ERROR: using save_query"
        echo "USAGE: save_query <query> <query-name>"      
        exit
    fi

    QUERY="$1"
    QUERY_NAME="$2"

    if [ ! -e "$QUERY" ]
    then
        echo "ERROR: the query file $QUERY does not exist"
        exit
    fi

    if [ -z "$RESPONSE_HEADER" ]
    then
        RESPONSE_HEADER=save-query-response-header.tmp
    fi

    if [ -z "$RESPONSE_MSG" ]
    then
        RESPONSE_MSG=save-query-response-msg.json.tmp
    fi

    SERVER=`cat $HPC_DM_TEST/utils/server`
    CONFIG="--config $HPC_DM_TEST/utils/config"

    curl -H "Content-Type: application/json" -d @"$QUERY" -X POST $SERVER/query/$QUERY_NAME $CONFIG  -H "Accept: application/json" -D $RESPONSE_HEADER -o $RESPONSE_MSG -s 2> curl-status 
    check_connection $RESPONSE_HEADER
}

# Get search queries
#         
#        
function get_queries {

    if [ -z "$RESPONSE_HEADER" ]
    then
        RESPONSE_HEADER=get-query-response-header.tmp
    fi

    if [ -z "$RESPONSE_MSG" ]
    then
        RESPONSE_MSG=get-query-response-msg.json.tmp
    fi

    SERVER=`cat $HPC_DM_TEST/utils/server`
    CONFIG="--config $HPC_DM_TEST/utils/config"

    curl  -X GET $SERVER/query $CONFIG  -H "Accept: application/json" -D $RESPONSE_HEADER -o $RESPONSE_MSG -s 2> curl-status 
    check_connection $RESPONSE_HEADER
}

#Subscribe to notifications using template
function subscribe_to_template_notifications {

    SUBSCRIPTION_TEMPLATE=$HPC_DM_TEST/utils/templates/notifications_template.json
    NOTIFICATIONS=subscribe-notification_input.json.tmp
    #Edit the base path 
    BASE_PATH=$(get_basefolder)
    cat $SUBSCRIPTION_TEMPLATE  | sed "s/DXBASEFOLDER/$BASE_PATH/" > $NOTIFICATIONS
    subscribe_to_notifications  $NOTIFICATIONS
}

#Unsubscribe to notifications using template
function unsubscribe_to_template_notifications {

    UNSUBSCRIPTION_TEMPLATE=$HPC_DM_TEST/utils/templates/delete-notification-template.json
    cp $UNSUBSCRIPTION_TEMPLATE unsubscribe-notification_input.json.tmp
    subscribe_to_notifications  unsubscribe-notification_input.json.tmp 
}


#Get an item (collection or dataObject) from the archive
#Inputs: <item-path> (should have a prefix of "dataObject" or "collection:)
#      : <response-header-filename>
#      : <response-message-filename>
#      : [user]  The user who should get the item
function get_item {

    if [ -z "$1" ] || [ -z "$2" ] || [ -z "$3" ]
    then
        echo "ERROR: using get_item"
        echo "USAGE: get_item  <item-path> <response-header-filename> <response-message-filename>"
        exit
    fi

    if [ -z "$4" ]
    then
        CONFIG="--config $HPC_DM_TEST/utils/config"
    else
        USER="$4"
        #if the passed user is the same as the user in config, use config, otherwise, use a different user  
        CONFIG_USER=$(get_username)
        if [ "$USER"  = "$CONFIG_USER" ]
        then
            CONFIG="--config $HPC_DM_TEST/utils/config"
        else
            #TODO: note -k is not required, this is a random password
            CONFIG="-k -u ${USER}:password"
        fi
    fi


    ITEM_PATH="$1"
    RESPONSE_HEADER="$2"
    RESPONSE_MSG="$3"
    SERVER=`cat $HPC_DM_TEST/utils/server`

    TOTAL_PATH="$ITEM_PATH"
    TOTAL_PATH=$(echo "$TOTAL_PATH" | sed "s#\/\/*#\/#g")
   
    #echo curl -G -X GET "$SERVER/$TOTAL_PATH"  $CONFIG  -D $RESPONSE_HEADER -o $RESPONSE_MSG -s 2> curl-status 
    curl -G -X GET "$SERVER/$TOTAL_PATH"  $CONFIG  -D $RESPONSE_HEADER -o $RESPONSE_MSG -s 2> curl-status 
    check_connection $RESPONSE_HEADER
}

#Get a permisson on an item (collection or dataObject) from the archive
#Inputs: <item-path> (should have a prefix of "dataObject" or "collection:)
function get_permission {

    if [ -z "$1" ] 
    then
        echo "ERROR: using get_permission"
        echo "USAGE: get_permission  <item-path>"
        exit 1
    fi

    CONFIG=$(get_curl_config) 
    ITEM_PATH="$1"

    if [[ "$ITEM_PATH" != "dataObject"* ]] && [[ "$ITEM_PATH" !=  "collection"* ]]
    then 
        echo "ERROR: get_permission" >&2
        echo "PATH \"$ITEM_PATH\" does not contain the prefix \"collection\" or \"dataObject\"" >&2
        exit 1
    fi


    RESPONSE_HEADER=get-permission-response-header.tmp
    RESPONSE_MSG=get-permission-response-message.json.tmp
    SERVER=`cat $HPC_DM_TEST/utils/server`

    curl -X GET "$SERVER/$ITEM_PATH"/acl  $CONFIG -H "Accept: application/json" -D $RESPONSE_HEADER -o $RESPONSE_MSG -s 2> curl-status 
    check_connection $RESPONSE_HEADER
}




#Update the premission using an input json file
#Inputs: <premission-file> The file that describes the premission
#        <path> The path of the collection or dataObject (should include the type as prefix)
#        [response-header] The file where the response header will be written
#        [response-message] The file where the response message will be witten
# If the variable ACTING_USER is set, this will be used as the acting user 

function update_permission {

    USAGE="USAGE: update_group_permission <permission-file> <[dataObjecg|collection]path>[response-header-file] [response-message-file]"

    if [ "$#" -lt 2 ]
    then
        echo "ERROR: using update_permission" >&2
        echo "$USAGE" >&2
        exit
    fi

    PERMISSION_FILE="$1"
    ITEM_PATH="$2"

    #Make sure the path include collection or dataObject
    if [[ "$ITEM_PATH" != "dataObject"* ]] && [[ "$ITEM_PATH" !=  "collection"* ]]
    then 
        echo "ERROR: update permission" >&2
        echo "PATH \"$ITEM_PATH\" does not contain the prefix \"collection\" or \"dataObject\"" >&2
        exit 1
    fi

    if [ -z "$3" ]
    then
        RESPONSE_HEADER="permission-response-header.tmp"
    else
        RESPONSE_HEADER="$3"
    fi

    if [ -z "$4" ]
    then
        RESPONSE_MSG="permission-response-message.json.tmp"
    else    
        RESPONSE_MSG="$4"
    fi
        
    CONFIG=$(get_curl_config) 
    SERVER=`cat $HPC_DM_TEST/utils/server`
    curl -H "Content-Type: application/json" -d @$PERMISSION_FILE -X POST ${SERVER}/$ITEM_PATH/acl  $CONFIG  -H "Accept: application/json" -D $RESPONSE_HEADER -o $RESPONSE_MSG -s 2> curl-status 
    check_connection $RESPONSE_HEADER
}


#Update the user permission of a single path using a template
#Inputs: <path>         The path for the collection or the dataObject where the permission should be updated 
#        <group_id>      The group to be granted the new permission
#        <permission>   The new permission that should be given  
# If the variable ACTING_USER is set, this will be used as the acting user 


function update_group_permission {

     
    USAGE="ERROR: using update_group_permission.\nUSAGE: update_group_permission <path> <group_id> <permission>"

    if [ -z "$1" ]
    then    
        echo "Missing path" >&2
        echo "$USAGE"  1>&2
        exit

    fi

    if [ -z "$2" ]
    then

        echo "Missing user_id" >&2
        echo "$USAGE" >&2
        exit

    fi

    if [ -z "$3" ]
    then

        echo "Missing permission" >&2
        echo "$USAGE" >&2
        exit

    fi
   
    PERMISSION_PATH="$1"
    GROUP_ID="$2"
    NEW_PERMISSION="$3"
       
    UPDATED_GROUP=$(cat $HPC_DM_TEST/utils/templates/group-permission-update-template.json | sed "s#dxgroupid#$GROUP_ID#")
    UPDATED_PERMISSION=$(echo "$UPDATED_GROUP" | sed "s#dxnewpermission#$NEW_PERMISSION#")
    echo "$UPDATED_PERMISSION" > group-permission.json.tmp
    
    #Submit the request to change permission
    update_permission "group-permission.json.tmp" "$PERMISSION_PATH" 
    
}



#Update the group permission of a single path using a template
#Inputs: <path>         The path for the collection or the dataObject where the permission should be updated 
#        <user_id>      The user to be granted the new permission
#        <permission>   The new permission that should be given  
# If the variable ACTING_USER is set, this will be used as the acting user 


function update_single_permission {

     
    USAGE="ERROR: using update_permission.\nUSAGE: update_single_permission <path> <user_id> <permission>"

    if [ -z "$1" ]
    then    
        echo "Missing path" >&2
        echo "$USAGE"  1>&2
        exit

    fi

    if [ -z "$2" ]
    then

        echo "Missing user_id" >&2
        echo "$USAGE" >&2
        exit

    fi

    if [ -z "$3" ]
    then

        echo "Missing permission" >&2
        echo "$USAGE" >&2
        exit

    fi

   
    PERMISSION_PATH="$1"
    USER_ID="$2"
    NEW_PERMISSION="$3"
       
    #UPDATED_PATH=$(cat $HPC_DM_TEST/utils/templates/permission-update-template.json | sed "s#dxcollectionpath#$PERMISSION_PATH#")
    UPDATED_USER=$(cat $HPC_DM_TEST/utils/templates/permission-update-template.json | sed "s#dxnewuserid#$USER_ID#")
    UPDATED_PERMISSION=$(echo "$UPDATED_USER" | sed "s#dxnewpermission#$NEW_PERMISSION#")
    echo "$UPDATED_PERMISSION" > permission.json.tmp
    
    #Submit the request to change permission
    update_permission "permission.json.tmp" "$PERMISSION_PATH" 
    
}



#Register a query
#Inputs:    <query-name> 
#           <query-file>
#           [PUT-POST] Either register or update
function register_query {

    USAGE="ERROR: using register_query.\nUSAGE: register_query <query-name> <query-file> [PUT-POST]"

    if [ -z "$1" ]
    then    
        echo "Missing query-name" >&2
        echo "$USAGE"  1>&2
        exit

    fi

    if [ -z "$2" ]
    then

        echo "Missing query-file" >&2
        echo "$USAGE" >&2
        exit
    fi

    if [ -z "$3" ]
    then
        METHOD=PUT
    else
        METHOD=$3
    fi

    if [ "$METHOD" != PUT ] && [ "$METHOD" != POST ] 
    then
        echo "ERROR:unsupported method $METHOD" >&2
    fi


    if [ "$METHOD" = PUT ] 
    then
        RESPONSE_HEADER=register-query-response-header.tmp
        RESPONSE_MSG=register-query-response-message.json.tmp
    else
        RESPONSE_HEADER=update-query-response-header.tmp
        RESPONSE_MSG=update-query-response-message.json.tmp
    fi
    
    QUERY_NAME="$1"
    QUERY_PATH="$2"


    if [ ! -f "$QUERY_PATH" ]
    then
        echo "The query file $QUERY_PATH does not exist" >&2
        exit
    fi

    CONFIG="" 
    SERVER=`cat $HPC_DM_TEST/utils/server`


    curl -X $METHOD ${SERVER}/query/"$QUERY_NAME" -H "Content-Type: application/json" -d @$QUERY_PATH --config $HPC_DM_TEST/utils/config -H "Accept: application/json" -D $RESPONSE_HEADER -o $RESPONSE_MSG -s 2> curl-status
    check_connection $RESPONSE_HEADER
}


#Delete a query
#Inputs:    <query-name> 
function delete_query {

    USAGE="ERROR: using delete_query.\nUSAGE: delete_query <query-name> "

    if [ -z "$1" ]
    then    
        echo "Missing query-name" >&2
        echo "$USAGE"  1>&2
        exit

    fi

    QUERY_NAME="$1"

    SERVER=`cat $HPC_DM_TEST/utils/server`

    RESPONSE_HEADER=delete-query-response-header.tmp
    RESPONSE_MSG=delete-query-response-message.json.tmp

    curl -X DELETE ${SERVER}/query/"$QUERY_NAME" --config $HPC_DM_TEST/utils/config -H "Accept: application/json" -D $RESPONSE_HEADER -o $RESPONSE_MSG -s 2> curl-status
    check_connection $RESPONSE_HEADER
}




#Retrieve a saved query
#Inputs:    <query-name> 
function get_query {

    USAGE="ERROR: using get_query.\nUSAGE: get_query <query-name>"

    if [ -z "$1" ]
    then    
        echo "Missing query-name" >&2
        echo "$USAGE"  1>&2
        exit

    fi

    QUERY_NAME="$1"

    SERVER=`cat $HPC_DM_TEST/utils/server`

    RESPONSE_HEADER=get-query-response-header.tmp
    RESPONSE_MSG=get-query-response-message.json.tmp

    curl -X GET ${SERVER}/query/"$QUERY_NAME" --config $HPC_DM_TEST/utils/config -H "Accept: application/json" -D $RESPONSE_HEADER -o $RESPONSE_MSG -s 2> curl-status
    check_connection $RESPONSE_HEADER
}




#Register a query from a template
#Inputs:  [query-id]  
function register_query_from_template {


    if [ -z "$1" ]
    then
        sleep 1
        SUFFIX=`date +"%b-%d-%G-%H-%M-%S"`
        QUERY_ID=queryid-$SUFFIX
    else
        QUERY_ID="$1"
    fi

    QUERY_TEMPLATE=$HPC_DM_TEST/utils/templates/query-template.json

    QUERY_STRING=$(cat $QUERY_TEMPLATE  | sed "s/DXTEST/dxattribute-$QUERY_ID/")
    QUERY_FILE="query.json.tmp"

    echo "$QUERY_STRING"  >  $QUERY_FILE
    register_query "$QUERY_ID" "$QUERY_FILE"
    echo "$QUERY_ID"

}

#Refresh the query metadata view 
#Inputs: None 

function refresh_views {

    SERVER=`cat $HPC_DM_TEST/utils/server`
    RESPONSE_HEADER=refresh-views-response-header.tmp
    RESPONSE_MSG=refresh-views-response-message.json.tmp
    curl -X POST ${SERVER}/refreshMetadataViews  $(get_curl_config)  -H "Accept: application/json" -D $RESPONSE_HEADER -o $RESPONSE_MSG -s 2> curl-status 
    check_connection $RESPONSE_HEADER
}

#Returns the configuration argument for the curl command

function get_curl_config {


    if [ -z "$ACTING_USER" ]
    then
        CONFIG="--config $HPC_DM_TEST/utils/config" 
    else
        CONFIG="-k -u ${ACTING_USER}:password"
    fi 
    
    echo "$CONFIG"
}

#Sleep for a defined period of time before the asynchronous downlaod
#Inputs: [time] in seconds
function async_sleep {

    SLEEP_TIME="$1"
    if [ -z "$1" ]
    then
        SLEEP_TIME=$(get_json_value $HPC_DM_TEST/utils/test-configuration asynchronous-sleep)
    fi

    sleep "$SLEEP_TIME"
}



#Delete a dataObject 
#Inputs:    <dataObject-path> 
#           <response-header>
#           <response-message>
function delete_dataobject {

    USAGE="ERROR: using delete_dataObject.\nUSAGE: delete_dataObject <path> <response-header> <response-message>"

    if [ "$#" -ne  3 ] 
    then    
        echo "$USAGE"  1>&2
        exit 1

    fi

    DATAOBJECT_PATH="$1"
    RESPONSE_HEADER="$2"
    RESPONSE_MSG="$3"

    SERVER=`cat $HPC_DM_TEST/utils/server`
    CONFIG="$(get_curl_config)"

    curl -X DELETE ${SERVER}/dataObject/"$DATAOBJECT_PATH" $CONFIG -H "Accept: application/json" -D $RESPONSE_HEADER -o $RESPONSE_MSG -s 2> curl-status
    check_connection $RESPONSE_HEADER
}

#Check if dataobject is archived
#Inputs:	<dataobject-path>
function check_dataObject_archived { 
    USAGE="ERROR using check_dataObject_archived\nUSAGE: check_dataObject_archived <path>"

    if [ $# -ne 1 ]
    then
        echo "$USAGE" >&2
        exit 1
    fi
}

#Get DOC policies
#Inputs:    <DOC-NAME> 
#           <response-header>
#           <response-message>
function get_doc_policies {

    USAGE="ERROR: using get_doc_policies.\nUSAGE: get_doc_policies <DOC-NAME> <response-header> <response-message>"

    if [ "$#" -ne  3 ] 
    then    
        echo "$USAGE"  1>&2
        exit 1

    fi

    doc="$1"
    RESPONSE_HEADER="$2"
    RESPONSE_MSG="$3"

    SERVER=`cat $HPC_DM_TEST/utils/server`
    CONFIG=$(get_curl_config)

    curl -X GET $SERVER/dm/model/"$doc" $CONFIG -H "Accept: application/json" -D "$RESPONSE_HEADER" -o "$RESPONSE_MSG"  -s 2>curl-status
    check_connection $RESPONSE_HEADER
}


#Add bookmark for a path
#Inputs:    <bookmark-name> 
#           <bookmark.json>
#           <response-header>
#           <response-msg>
function add_bookmark {

    USAGE="ERROR: using add_bookmark.\nUSAGE: add_bookmark <bookmark-name> <bookmark.json> <response-header> <response-message>"

    if [ "$#" -ne  4 ] 
    then    
        echo "$USAGE"  1>&2
        exit 1

    fi

    bookmark_name="$1"
    json_file="$2"
    RESPONSE_HEADER="$3"
    RESPONSE_MSG="$4"

    if [ ! -e "$json_file" ]
    then
        echo "ERROR: the bookmark json file:$json_file does not exist." >&2
        exit 1
    fi 

    SERVER=`cat $HPC_DM_TEST/utils/server`
    CONFIG=$(get_curl_config)
    curl -X PUT $SERVER/bookmark/"$bookmark_name" -H "Content-Type: application/json" -d @$json_file $CONFIG -H "Accept: application/json" -D "$RESPONSE_HEADER" -o "$RESPONSE_MSG"  -s 2>curl-status
    check_connection $RESPONSE_HEADER
}


#Add bookmark for a path from template
#Inputs:    <bookmark-path> 
#           <response-header>
#           <response-msg>
function add_bookmark_from_template {

    USAGE="ERROR: using add_bookmark_from_template.\nUSAGE: add_bookmark_from_template <bookmark-path> <response-header> <response-message>"

    if [ "$#" -ne  3 ] 
    then    
        echo "$USAGE"  1>&2
        exit 1

    fi

    bookmark_path="$1"
    response_header="$2"
    response_msg="$3"

    sleep 1
    suffix=`date +"%b-%d-%G-%H-%M-%S"`
    bookmark_name=name-$suffix
    bookmark_group=group-$suffix

    echo $bookmark_name > bookmark-name.tmp
    echo $bookmark_group > bookmark-group.tmp

    template_file=$HPC_DM_TEST/utils/templates/bookmark-template.json
    json_file=bookmark.json.tmp
    new_template=$(cat $template_file | sed "s@dxpath@$bookmark_path@" | sed "s@dxgroup@$bookmark_group@") 
    echo "$new_template" > $json_file

    add_bookmark  "$bookmark_name" "$json_file" "$response_header" "$response_msg"
}

#Update bookmark for a path
#Inputs:    <bookmark-name> 
#           <bookmark-path>
#           <bookmark-group>
#           <response-header>
#           <response-msg>
function update_bookmark {

    USAGE="ERROR: using update_bookmark.\nUSAGE: update_bookmark <bookmark-name> <bookmark-path> <bookmark-group> <response-header> <response-message>"

    if [ "$#" -ne  5 ] 
    then    
        echo "$USAGE"  1>&2
        exit 1

    fi

    bookmark_name="$1"
    bookmark_path="$2"
    bookmark_group="$3"
    RESPONSE_HEADER="$4"
    RESPONSE_MSG="$5"

    template_file=$HPC_DM_TEST/utils/templates/bookmark-template.json
    json_file=bookmark.json.tmp
    new_template=$(cat $template_file | sed "s@dxpath@$bookmark_path@" | sed "s@dxgroup@$bookmark_group@") 
    echo "$new_template" > $json_file

    SERVER=`cat $HPC_DM_TEST/utils/server`
    CONFIG=$(get_curl_config)
    curl -X POST $SERVER/bookmark/"$bookmark_name" -H "Content-Type: application/json" -d @$json_file $CONFIG -H "Accept: application/json" -D "$RESPONSE_HEADER" -o "$RESPONSE_MSG"  -s 2>curl-status
    check_connection $RESPONSE_HEADER
}


#Delete a bookmark 
#Inputs:    <bookmark-name> 
#           <response-header>
#           <response-msg>
function delete_bookmark {

    USAGE="ERROR: using delete_bookmark.\nUSAGE: delete_bookmark <bookmark-name> <response-header> <response-message>"

    if [ "$#" -ne  3 ] 
    then    
        echo "$USAGE"  1>&2
        exit 1

    fi

    bookmark_name="$1"
    RESPONSE_HEADER="$2"
    RESPONSE_MSG="$3"

    SERVER=`cat $HPC_DM_TEST/utils/server`
    CONFIG=$(get_curl_config)
    curl -X DELETE $SERVER/bookmark/"$bookmark_name" $CONFIG -H "Accept: application/json" -D "$RESPONSE_HEADER" -o "$RESPONSE_MSG"  -s 2>curl-status
    check_connection $RESPONSE_HEADER
}

#get the details of a bookmark 
#Inputs:    <bookmark-name> 
#           <response-header>
#           <response-msg>
function get_bookmark {

    USAGE="ERROR: using get_bookmark.\nUSAGE: get_bookmark <bookmark-name> <response-header> <response-message>"

    if [ "$#" -ne  3 ] 
    then    
        echo "$USAGE"  1>&2
        exit 1

    fi

    bookmark_name="$1"
    RESPONSE_HEADER="$2"
    RESPONSE_MSG="$3"

    SERVER=`cat $HPC_DM_TEST/utils/server`
    CONFIG=$(get_curl_config)

    curl -X GET $SERVER/bookmark/"$bookmark_name" $CONFIG -H "Accept: application/json" -D "$RESPONSE_HEADER" -o "$RESPONSE_MSG"  -s 2>curl-status
    check_connection $RESPONSE_HEADER
}



#Get bookmarks for a user 
#           <response-header>
#           <response-msg>
function get_bookmarks {

    USAGE="ERROR: using get_bookmarks.\nUSAGE: get_bookmarks <response-header> <response-message>"

    if [ "$#" -ne  2 ] 
    then    
        echo "$USAGE"  1>&2
        exit 1

    fi

    RESPONSE_HEADER="$1"
    RESPONSE_MSG="$2"

    SERVER=`cat $HPC_DM_TEST/utils/server`
    CONFIG=$(get_curl_config)

    curl -X GET $SERVER/bookmark $CONFIG -H "Accept: application/json" -D "$RESPONSE_HEADER" -o "$RESPONSE_MSG"  -s 2>curl-status
    check_connection $RESPONSE_HEADER
}

function convert_date_to_seconds  {

    usage="convert_date_to_seconds month-day-year hour:minute:seconds"
    if [ $# -ne 1 ]
    then
        echo "$usage" >&2
        exit 1
    fi

    x="$1"
    month=${x:0:2}
    day=${x:3:2}
    year=${x:6:4}
    time=${x:11:9}
    new_string="$year-$month-$day $time"
    date --date="$new_string" +%s
}

#Verifies the download went through and the receipt was correctly generated. 
#Inputs: taskId: The download receipt.
#Inputs: files_paths: The download path on Globus
#Input: type: dataObject, collection, or ""
function verify_globus_download {


  taskID="$1"
  files_paths="$2"
  download_type="$3"

  #Get the status of the download request and verify it is true
  RESPONSE_HEADER=get-download-status-response-header.tmp
  RESPONSE_MSG=get-download-status-response-message.json.tmp
  get_download_status "$taskId" "$download_type" 
  HTTP_CODE=`get_http_code $RESPONSE_HEADER`
  echo "get_status_code $HTTP_CODE"

  #Do not check the file is the code is not 200
  if [ $HTTP_CODE != 200 ] 
  then
    echo "$FUNCNAME: Unable to get download status" >&2
    exit 1
  fi

  #Verify that the download is marked complete on the download status
  status=$(get_json_unquotted_value $RESPONSE_MSG inProgress)
  echo "in_progress:$status"
  mv $RESPONSE_HEADER first-get-status-header.tmp
  mv $RESPONSE_MSG first-get-status-message.tmp


  first=false
  for globus_path in $files_paths
  do
    if [ "$first" == "false" ]
    then
      verify_globus_file  -s 90 $globus_path 
      first=true
    else
      verify_globus_file  -e $globus_path 
    fi 
  done 


  #Sleep 50s and verify the status is updated
  sleep 50
  RESPONSE_HEADER=get-download-status-response-header.tmp
  RESPONSE_MSG=get-download-status-response-message.json.tmp
  get_download_status "$taskId" "$download_type"

  #Verify that the download is marked complete on the download status
  status=$(get_json_unquotted_value $RESPONSE_MSG inProgress)
  echo "in_progress:$status"
}
