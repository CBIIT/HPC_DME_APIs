#!/usr/bin/env bash
# functions
# @author: George Zaki 
# 
# Copyright Leidos Biomedical Research, Inc
# 
# Distributed under the OSI-approved BSD 3-Clause License.
# See http://ncip.github.com/HPC/LICENSE.txt for details.
#
# Common functions used by the unit tests



#Returns all task_ids for asynchronous download
function get_async_download_tasks {


  #Get the status of the download request and verify it is true
  response_header=get-async-download-tasks-response-header.tmp
  response_msg=get-async-download-tasks-response-message.json.tmp


  SERVER=`cat $HPC_DM_TEST/utils/server`
  CONFIG=$(get_curl_config)
  curl -X GET $SERVER/download $CONFIG -H "Accept: application/json" -D "$response_header" -o "$response_msg"  -s 2>curl-status
  check_connection $response_header
}




#prints a message to stderr and exits
#Input: <error_message>
function fail_and_exit {

  error_message=${1:-No error message passed}
  echo "$error_message" >&2
  exit 1

}

#Return the HTTP code in the response excluding 100
#Inputs: <response-header-file>
function get_http_code {
    if [ -z "$1" ]
    then
        echo "ERROR: using get_http_code"
        echo "USAGE: get_http_code <http-response-file>"
        exit
    fi

    if [ ! -e "$1" ]
    then
      echo "ERROR can not find the file:$1" >&2
      exit 1
    fi
    grep 'HTTP' $1  | grep '[02-9][0-9][0-9]' | sed 's/.*\([0-9][0-9][0-9]\).*/\1/'
}


#If the input is a filename, return the contents of the file, otherwise return the input
#Inputs: <input-string-or-filename>
function get_file_value {
    if [ -z "$1" ]
    then
        echo "ERROR: using get_file_value"
        echo "USAGE: get_file_value <input-string>"
        exit
    fi

    INPUT="$1"
    #Check if the input is a file
    if [ -e "$INPUT" ] 
    then
        INPUT=`cat $INPUT`
    fi
    echo "$INPUT"
}


#Return a single value for a given attribute in a json file 
#Inputs: json-file-name(or input string)  attribute-name 
function get_json_value {

    if [ -z "$1" ] || [ -z "$2" ]
    then
        echo "ERROR: using get_json_value"
        echo "USAGE: get_json_value <input-string-or-file> <attribute>"
        exit
    fi
    INPUT="$1"
    ATTRIBUTE="$2"
    INPUT=`get_file_value "$INPUT"`
    echo "$INPUT" | grep \""$ATTRIBUTE"\" | sed "s/.*${ATTRIBUTE}\"[ 	]*:[ 	]*\"\([^\"]*\)\".*/\1/"
}

#Return a single unquotted value for a given attribute in a json file 
#Inputs: json-file-name(or input string)  attribute-name 
function get_json_unquotted_value {

    if [ -z "$1" ] || [ -z "$2" ]
    then
        echo "ERROR: using get_json_value"
        echo "USAGE: get_json_value <input-string-or-file> <attribute>"
        exit
    fi
    INPUT="$1"
    ATTRIBUTE="$2"
    INPUT=`get_file_value "$INPUT"`
    echo "$INPUT" | grep "$ATTRIBUTE" | sed "s/.*${ATTRIBUTE}\"[ 	]*:[ 	]*\([^,]*\),.*/\1/"
}





#Return the array value for a given attribute in a json file 
#Inputs: json-file-name(or input string)  attribute-name 
function get_json_array_value {

    if [ -z "$1" ] || [ -z "$2" ]
    then
        echo "ERROR: using get_json_array_value"
        echo "USAGE: get_json_array_value <input-string-or-file> <attribute>"
        exit
    fi

    INPUT="$1"
    ATTRIBUTE="$2"
    INPUT=`get_file_value "$INPUT"`
    echo "$INPUT" |  grep $ATTRIBUTE | sed "s/.*${ATTRIBUTE}\"[ 	]*:[ 	]*\[\([^]].*\)\].*/\1/"
}



#Check the non existance of an attribute/value metadata in from the response header or message.
#Inputs: <RESPONSE_MSG>: The file that contains the response messge
#        <RESPONSE_HDR>: The file that contains the response header 
#        <ATTRIBE>: The attribute
#        <VALUE>: The value to be checked
#
#Returns: echo "TRUE" or "FALSE" 
function check_non_existance {


    if [ ! -e "$1" ]
    then
        echo "ERROR: The response header  file \"$1\" does not exists" >&2
        exit
    fi 


    RESPONSE_HEADER="$1"
    HTTP_CODE=$(verify_get $RESPONSE_HEADER)

    #If I got a response message, check that it does not include the attribute/value pair
    if [ "$HTTP_CODE"  -eq "200"  ]
    then

        if [ ! -e "$2" ]
        then
            echo "ERROR: The response message file \"$2\" does not exists" >&2
            exit
        fi 

        if [ -z "$3" ] || [ -z "$4" ] 
        then
            echo "ERROR: missing input arguments" >&2
            echo "USAGE: check_non_existance <response-msg> <response_header> <attribute> <value>" >&2
            exit
        fi 
    
        RESPONSE_MSG="$2"
        ATTRIBUTE="$3"
        VALUE="$4"
        RES=$(check_existance "$RESPONSE_MSG" "$ATTRIBUTE" "$VALUE" "FALSE")  
    fi
}




#Check the existance of an attribute/value metadata in a response message
#Inputs: <RESPONSE_MSG>: The file that contains the response messge
#        <ATTRIBE>: The attribute
#        <VALUE>: The value to be checked
#        [TEST]: TRUE if attribute should be found, FALSE if not
#
#Returns: echo "TRUE" or "FALSE" 
function check_existance {

    if [ ! -e "$1" ]
    then
        echo "ERROR: The response message file \"$1\" does not exists" >&2
        exit
    fi 

    RESPONSE_MSG="$1"
    if [ -z "$2" ] || [ -z "$3" ] 
    then
        echo "ERROR: missing input arguments" >&2
        echo "USAGE: check_existance <response-msg> <attribute> <value>" >&2
        exit
    fi 
    
    ATTRIBUTE="$2"
    VALUE="$3"

    #Make sure the response does include the object
    RESPONSE_GROUPS=`cat $RESPONSE_MSG | tr "{" "\n"`
    OBJECT_GROUPS=`echo "$RESPONSE_GROUPS" | grep "$ATTRIBUTE"`
    OBJECT_NAMES=`get_json_value "$OBJECT_GROUPS" value`

    OBJECT_FOUND="FALSE"
    for object in "$OBJECT_NAMES"; do
        if [[ $object == *"$VALUE"*  ]]
        then
            OBJECT_FOUND="TRUE"
            break
        fi
    done 
      

    if [ ! -z "$4" ] 
    then
        TEST="$4"
        if [ ! "$OBJECT_FOUND" == "$TEST" ] 
        then
            echo "ERROR: OBJECT \"$VALUE\" does not pass the test $TEST"  1>&2
        fi
    fi

    echo $OBJECT_FOUND 

}

#Return the hierarchical array value for a given attribute in a json string. 
#Limited to two levels of hierarchy. Example "Attribute":[ []   []  ] 
#Inputs: "Input string"  "attribute-name" 
function get_json_hier_array_value {
    INPUT="$1"
    ATTRIBUTE="$2"

    #First define the regex 'a': <text>[<text>]
    #Then generalize 'a' to define 'b': \(a\)*
    #Then define the matched string as: "attribute":['b'<text>]
    echo "$INPUT" | sed "s/\(.*\)\(\"$ATTRIBUTE\"[  ]*:[ 	]*\[\([^][]*\[[^][]*\]\)*[^][]*\]\)\(.*\)/\2/" 
}


#Return the value for a one line json file with the format "attribute"  "value"
#Inputs: <input-file.json or json string> 
#Inputs: <attribute name> 
function get_json_attribute_value {

    if [ -z "$1" ] || [ -z "$2" ]
    then
        echo "ERROR: using get_json_attribute_value"
        echo "USAGE: get_json_attribute_value <input-string-or-file> <attribute>"
        exit
    fi

    INPUT="$1"
    ATTRIBUTE="$2"
    INPUT=$(get_file_value "$INPUT")


    RESPONSE_GROUPS=$(echo "$INPUT" | tr "{" "\n" | grep "$ATTRIBUTE" )

    if [ -z $RESPONSE_GROUPS ]
    then
        echo "Can not find the attribute:$ATTRIBUTE in the input"   
        exit
    fi

    #echo "$RESPONSE_GROUPS"
    ACTUAL_VALUE=`get_json_value $RESPONSE_GROUPS value `
    echo $ACTUAL_VALUE
} 

#Checks that the response header file has information.
function check_connection {
    if [ -z "$1" ]
    then
        echo "ERROR: using check_connection"
        echo "USAGE: check_connection <response-file>"
        exit
    fi
    RESPONSE_HEADER="$1"
    if [ -e "$RESPONSE_HEADER" ]
    then 
        CONT=`cat "$RESPONSE_HEADER"`
    fi
    if [ -z "$CONT" ]
    then
        echo "ERROR: THE RESPONSE HEADER FILE $RESPONSE_HEADER IS EMPTY, CHECK CONNECTION" 1>&2
        exit
    fi
}

#Get the username from the config file.
function get_username {
    if [ -z "$1" ]
    then
     #   echo "ERROR: using get_username"
     #   echo "USAGE: get_username <curl-config-file>"
     #   exit
        CURL_CONFIG_FILE=$HPC_DM_TEST/utils/config
    else
        CURL_CONFIG_FILE="$1"
    fi

    #Make sure the line I get from config is not a token with -u. If the -u is for a username, then the number of 
    #characters  should be less than 40

    USER_NAME_LINE=`grep '\-u' "$CURL_CONFIG_FILE"`
    N_CHAR=${#USER_NAME_LINE}
    if [ "$N_CHAR" -lt "40" ]
    then
        USER_NAME=$(echo "$USER_NAME_LINE" | sed "s/.*\-u[   ]*\([a-zA-Z_]*\).*/\1/")
    fi

    #If the username is not in the $CURL_CONFIG_FILE look in the general configuration
    if [ -z "$USER_NAME" ]
    then 
        USER_NAME=$(get_json_value $HPC_DM_TEST/utils/test-configuration username)
    fi

    if [ -z "$USER_NAME" ]
    then 
        echo "ERROR: Can not retrieve username"
        exit 
    fi
    echo $USER_NAME
}


#Get the globus username from the test configuration file.
function get_globus_user {

    TEST_CONFIG=$HPC_DM_TEST/utils/test-configuration 
    GLOBUS_USER_NAME=$(get_json_value $TEST_CONFIG globus-user)

    if [ -z "$GLOBUS_USER_NAME" ]
    then 
        echo "ERROR: Can not retrieve globus-user from $TEST_CONFIG"
        exit 
    fi
    echo $GLOBUS_USER_NAME
}





#Get the basefolder 
#If the environment varialbe DX_BASE_FOLDER_NAME is not defined, the defaut collection with hierarchy is returned.
#Otherwise, the defined collection in the environment variable is returned
function get_basefolder {

    if [ -z "$DX_BASE_FOLDER_NAME" ]
    then
      BASE_FOLDER=$(get_json_value $HPC_DM_TEST/utils/test-configuration base-folder)
    else
      BASE_FOLDER=$(get_json_value $HPC_DM_TEST/utils/test-configuration $DX_BASE_FOLDER_NAME)
    fi

    if [ -z "$BASE_FOLDER" ]
    then 
        echo "ERROR: Can not retrieve base-folder from $HPC_DM_TEST/utils/test-configuration "
        exit 
    fi
 

    echo $BASE_FOLDER

}





#Get a parameter from the test-configuration file
#Usage get_parameter <parameter_name> 
function get_parameter {

    if [ -z "$1" ]
    then
        echo "ERROR: using get_parameter"
        echo "USAGE: get_parameter <parameter-name>"
        exit
    fi

    CONFIGURATION_FILE="$HPC_DM_TEST/utils/configuration-file"
    PARAMETER_NAME="$1"
    PARAMETER_VALUE=`grep "$PARAMETER_NAME" "$CONFIGURATION_FILE" | sed "s/.*$PARAMETER_NAME[   ]*\([a-zA-Z-0-9]*\).*/\1/"`
    echo $USER_NAME
}



#Verify that the "Location" returned in response header upon registration is correct
#Input  response-header: The registration-response-header
#       path: location string without the leading '/'
function verify_location {

    usage="ERROR using $FUNCNAME \n USAGE: $FUNCNAME <response-header> <path>"
    if [ -z "$1" ]  || [ -z "$2" ]
    then
        echo "$usage" >&2
        echo "RECEIVED: $@" >&2
        exit 1
    fi

    response_header="$1"
    item_path="$2"

    #Get the location without any white spaces
    location=$(grep Location $response_header | sed "s@Location:.*dataObject/@@" |  tr -d '[:space:]')

    if [ "$location" != "$item_path" ]
    then
      echo "ERROR: the returned location: $location does not match the path: $item_path" >&2
    fi

}




#Verify that a collection or a dataObject  was registered correctly
#Input  registration-response-header
function verify_registration {

    if [ -z "$1" ]
    then
        echo "ERROR: using check_registration"
        echo "USAGE: check_registration <registration-response-header-file>"
        exit
    fi

    RESPONSE_HEADER="$1"
    REG_HTTP_CODE=`get_http_code $RESPONSE_HEADER`
    if [ "$REG_HTTP_CODE" != "201" ]  && [ "$REG_HTTP_CODE" != "200" ]
    then
        echo "FAILED TO REGISTER, HTTP_CODE = $REG_HTTP_CODE" 1>&2
        exit
    fi
}


#Verify that a get command returned either 200 or 204 
#Input  response-header
#Returns: HTTP_CODE
function verify_get {

    if [ -z "$1" ]
    then
        echo "ERROR: using verify_get"
        echo "USAGE: verify_get <response-header-file>"
        exit
    fi

    RESPONSE_HEADER="$1"
    HTTP_CODE=`get_http_code $RESPONSE_HEADER`
    if [ "$HTTP_CODE" != "200" ]  && [ "$HTTP_CODE" != "204" ]
    then
        echo "FAILED TO GET, HTTP_CODE = $HTTP_CODE" 1>&2
        exit
    fi

    echo "$HTTP_CODE"
}


#Register a collection or a dataObject 
#Inputs: <description.json> <destinaton-path> <type>  [data-object-file]
# If the nvironment varialbe ACTING_USER  is set, it will use it a username
function curl_register {

    usage="ERROR using $FUNCNAME \n USAGE: $FUNCNAME <description.json> <destination-path> <[colleciton|dataObject|preSigned]> [dataObject-file]" 
    if [ -z "$1" ] || [ -z "$2" ] || [ -z "$3" ]
    then
        echo "$usage" >&2
        echo "Received: $*" >&2
        exit 1
    fi

    DESCRIPTION="$1"
    DESTINATION_PATH="$2"
    TYPE="$3"

    if [ "$TYPE" == "dataObject" ] && [ ! -z "$4" ]
    then
        DATAOBJECT_FILE="$4"
        if [ ! -e "$DATAOBJECT_FILE" ]
        then 
            echo "ERROR: The data-object-file:$DATAOBJECT_FILE does not exist "
            exit
        fi
    fi
        
    USERID=`get_username $HPC_DM_TEST/utils/config`
    SERVER=`cat $HPC_DM_TEST/utils/server`

    CONFIG=$(get_curl_config)
    
    #if [ -z "$RESPONSE_MSG" ]
    #then 
        RESPONSE_MSG=${TYPE}-registration-response-message.json.tmp
    #fi

    #if [ -z "$RESPONSE_HEADER" ]
    #then
        RESPONSE_HEADER=${TYPE}-registration-response-header.tmp
    #fi

    #CURL_FLAGS="-X PUT ${SERVER}/${TYPE}/${DESTINATION_PATH}  $CONFIG  -D $RESPONSE_HEADER -o $RESPONSE_MSG -s"
    CURL_FLAGS="-X PUT ${SERVER}/${TYPE}/${DESTINATION_PATH}  $CONFIG  -D $RESPONSE_HEADER -o $RESPONSE_MSG "

   
    if [ "$TYPE" == "dataObject" ]
    then
        if [ -z "$DATAOBJECT_FILE" ]
        then
            curl -F "dataObjectRegistration=@$DESCRIPTION;type=application/json" $CURL_FLAGS -H "Accept: application/json"  2> curl-status
        else
            curl -F "dataObjectRegistration=@$DESCRIPTION;type=application/json" -F "dataObject=@$DATAOBJECT_FILE;type=application/octet-stream" $CURL_FLAGS  -H "Accept: application/json"  2> curl-status 
        fi
    elif [ "$TYPE" == "preSigned" ]
    then
     	    CURL_FLAGS="-X PUT ${SERVER}/dataObject/${DESTINATION_PATH}  $CONFIG  -D $RESPONSE_HEADER -o $RESPONSE_MSG "
            curl -F "dataObjectRegistration=@$DESCRIPTION;type=application/json" $CURL_FLAGS  -H "Accept: application/json"  2> curl-status 
    elif [ "$TYPE" == "collection" ]
    then

           curl -H "Content-Type: application/json" -d @$DESCRIPTION $CURL_FLAGS  -H "Accept: application/json" 2>curl-status
    else
        echo "ERROR: Unsupported registration type:$TYPE"
        exit
    fi

    check_connection $RESPONSE_HEADER
}

#Substitute the "dxtestuid" string  with the actual username
# and globus-shared-endpoint-uid with the value in $HPC_DM_TEST/utils/test-configuration  
# and dXBASEFOLDER with the value in $HPC_DM_TEST/utils/test-configuration  
#Inputs: input_file  output_file
function update_uid {

    if [ -z "$1" ] || [ -z "$2" ]
    then
        echo "ERROR: using update_uid"
        echo "USAGE: update_uid <input-file> <output-file>"
        exit
    fi
    INPUT_FILE="$1"
    OUTPUT_FILE="$2"
    USERID=`get_username $HPC_DM_TEST/utils/config` 
    ENDPOINT=$(get_json_value $HPC_DM_TEST/utils/test-configuration globus-shared-endpoint-uid)
    BASE_PATH=$(get_basefolder)
    OUT=`cat "$INPUT_FILE" | sed "s/dxtestuid/$USERID/"`
    OUT=`echo "$OUT" | sed "s/globus-shared-endpoint-uid/$ENDPOINT/"`
    OUT=`echo "$OUT" | sed "s/DXBASEFOLDER/$BASE_PATH/"`
    echo "$OUT" > $OUTPUT_FILE
}


#Verify the existance of a file in a given Globus endpoint 
#Inputs: [-s SLEEP time
#         -e directory listing exists, do not check globus again]
#Inputs: <file path on the endpoint>
#Inputs: [EndpointID]
function verify_globus_file {

    usage="${FUNCNAME} [-s sleep-time] file_path [EndpointID]"
    local OPTIND
    sleep_time=120
    list_exists=false
    while getopts ":s:e" option
    do
      case "${option}" in 
        s)
          sleep_time="${OPTARG}"
          ;;
        e)
          list_exists=true
          ;;
        *)
          echo "ERROR: Unsoported option ${option}" >&2
          echo "$usage" >&2
          exit 1
          ;;
      esac
    done

    shift $(( OPTIND-1 ))
    if [ "$#" -ne  1 ]  && [ "$#" -ne 2  ]
    then
        echo "ERROR: using verify_globus_file $#" >&2
        echo "$usage" >&2
        exit
    fi

    #If endpoint is not passed, use the default endpoint
    if [ "$#" -eq 1 ] 
    then
        FILE_PATH="$1"
        ENDPOINT_ID=$(get_json_value $HPC_DM_TEST/utils/test-configuration globus-shared-endpoint-uid)
    else 
        FILE_PATH="$1"
        ENDPOINT_ID="$2"
    fi

    ls_file=directory-list.tmp
    if [ $list_exists == "false" ]
    then 

        #This verifies that globus CLI is present
        which globus > /dev/null || fail_and_exit "ERROR:No globus CLI, READ $HPC_DM_TEST/README.txt" 
 

        #List the files in the path
        PARENT_DIR=$(dirname "$FILE_PATH") 
    
        #Sleep a bit for Globus to be updated
        sleep $sleep_time 
    
        globus ls "$ENDPOINT_ID:$PARENT_DIR" > $ls_file
    fi

    FILE_NAME=$(basename $FILE_PATH)
    EXISTS=$(grep  "$FILE_NAME" $ls_file)
    if [ -z "$EXISTS" ]
    then
        echo "ERROR: Can not find the file $FILE_PATH in the Globus endpoint $ENDPOINT_ID"
        exit
    fi
    
}


#Get a user 
#Inputs:    userid
#           response-header      
#           response-message
function get_user {

    usage="USAGE: get_user <userid> <response-header> <response-message>"

    nargs=$#
    if [ "$nargs" -ne  "3" ]
    then
        echo "ERROR: using get_user" >&2
        echo "received $nargs arguments." >&2
        echo "$usage" >&2 
        exit
    fi

    USER_ID="$1"
    RESPONSE_HEADER="$2"
    RESPONSE_MSG="$3"
    
    SERVER=`cat $HPC_DM_TEST/utils/server`
   
    curl  -X GET ${SERVER}/user/$USER_ID  --config $HPC_DM_TEST/utils/config  -H "Accept: application/json" -D $RESPONSE_HEADER -o $RESPONSE_MSG -s 2> curl-status
    check_connection $RESPONSE_HEADER
}



#Enroll a user 
#Inputs:    userid
#           registration-template.json 
#           response-header      
#           response-message
function enroll_user {

    usage="USAGE: enroll_user <userid> <registration-template.json> <response-header> <response-message>"

    nargs=$#
    if [ "$nargs" -ne  "4" ]
    then
        echo "ERROR: using enroll_user" >&2
        echo "received $nargs arguments." >&2
        echo "$usage" >&2 
        exit
    fi

    USER_ID="$1"
    REGISTRATION_TEMPLATE="$2"
    RESPONSE_HEADER="$3"
    RESPONSE_MSG="$4"

    if [ ! -e $REGISTRATION_TEMPLATE ] 
    then
        echo "ERROR: The registration template file:$REGISTRATION_TEMPLATE does not exist "
        exit
    fi  
    
    SERVER=`cat $HPC_DM_TEST/utils/server`
    CONFIG=$(get_curl_config)
   
    curl  -X PUT -H "Content-Type: application/json" -d @$REGISTRATION_TEMPLATE ${SERVER}/user/$USER_ID $CONFIG   -H "Accept: application/json" -D $RESPONSE_HEADER -o $RESPONSE_MSG -s 2> curl-status
    check_connection $RESPONSE_HEADER
}



#Register a new test user 
#Input: registration-template.json 
function create_new_user {

    if [ -z "$1" ] 
    then
        echo "ERROR: using create_new_user"
        echo "USAGE: create_new_user  <registration-template.json>"
        exit
    fi

    REGISTRATION_TEMPLATE="$1"

    if [ ! -e $REGISTRATION_TEMPLATE ] 
    then
        echo "ERROR: The registration template file:$REGISTRATION_TEMPLATE does not exist "
        exit
    fi  

    sleep 1
    SUFFIX=`date +"%b-%d-%G-%H-%M-%S"`
    NEW_USER_ID=testid-$SUFFIX
    NEW_FIRST_NAME=testfirst-$SUFFIX
    NEW_LAST_NAME=testlast-$SUFFIX
    UPDATED_FIRST=`cat $REGISTRATION_TEMPLATE | sed "s/testfirst/$NEW_FIRST_NAME/"`
    UPDATED_LAST=`echo "$UPDATED_FIRST" | sed "s/testlast/$NEW_LAST_NAME/"`
    echo "$UPDATED_LAST" > register-user.json.tmp
    echo "$NEW_USER_ID" > new-user-id.tmp 
    echo "$NEW_FIRST_NAME" > new-first-name.tmp 
    echo "$NEW_LAST_NAME" > new-last-name.tmp 
    
    RESPONSE_HEADER=user-registration-response-header.tmp
    RESPONSE_MSG=user-registration-response-message.json.tmp

    enroll_user $NEW_USER_ID register-user.json.tmp $RESPONSE_HEADER $RESPONSE_MSG

    RESPONSE_CODE=`get_http_code $RESPONSE_HEADER`
    echo $RESPONSE_CODE
}




#Register a new test user using the tempalte
function register_user_from_template {

    TEMPLATE=$HPC_DM_TEST/utils/templates/register-user-template.json
    RESPONSE_CODE=$(create_new_user $TEMPLATE)
    if [ "$RESPONSE_CODE" !=  "201" ] 
    then 
        echo "ERROR: Failed to register new user"
        echo "Response code:$RESPONSE_CODE "
        exit
    fi

}

#Update existing user 
#Inputs userid: The ID of the user
#       update-template: A json file with the updated attributes/values
#       response-header: the response header file 
#       response-message: the response message file 

function update_existing_user {

    usage="USAGE: update_user <userid> <update-template.json> <response-header> <response-message>"

    nargs=$#
    if [ "$nargs" -ne  "4" ]
    then
        echo "ERROR: using update_existing_user" >&2
        echo "received $nargs arguments." >&2
        echo "$usage" >&2 
        exit
    fi

    USER_ID="$1"
    UPDATES="$2"
    RESPONSE_HEADER="$3"
    RESPONSE_MSG="$4"


    if [ ! -e $UPDATES ] 
    then
        echo "ERROR: The update template file:$UPDATES does not exist "
        exit
    fi  
    
    
    SERVER=`cat $HPC_DM_TEST/utils/server`
    
    curl -H "Content-Type: application/json" -d @$UPDATES -X POST ${SERVER}/user/$USER_ID  --config $HPC_DM_TEST/utils/config  -H "Accept: application/json" -D $RESPONSE_HEADER -o $RESPONSE_MSG -s 2> curl-status 
    check_connection $RESPONSE_HEADER
}


#Search users 
#Inputs:     
#       [-u userID]
#       [-f firstName]
#       [-l lastName]
#       [-a] search all users, default is active only
function search_users {

    usage="USAGE: search_users -u [userid] -f [first-name] -l [last-name] -a"

    OPTIND=1
    search_args=

    #By default, search the active users only
    subset=active
    while getopts ":u:f:l:a" opt; do
        case $opt in
        a)
            subset=all
            ;;
        u)
            search_args="$search_args --data-urlencode nciUserId=$OPTARG" 
            ;;
        f)
            search_args="$search_args --data-urlencode firstNamePattern=$OPTARG" 
            ;;
        l)
            search_args="$search_args --data-urlencode lastNamePattern=$OPTARG" 
            ;;
        \?)
            echo "Invalid option: -$OPTARG" >&2
            echo $USAGE >&2
            exit 1
            ;;
        :)
            echo "Option -$OPTARG requires an argument." >&2
            echo $USAGE >&2
            exit 1
            ;;
        esac
    done

    response_hdr="search-$subset-users-response-header.tmp"
    response_msg="search-$subset-users-response-message.json.tmp"
    config=$(get_curl_config) 
    SERVER=`cat $HPC_DM_TEST/utils/server`
   
    curl  -G ${SERVER}/user/$subset $search_args  $config -H "Accept: application/json" -D $response_hdr -o $response_msg -s 2> curl-status
    check_connection $response_hdr
}


#Search groups
#Inputs:     
#       [search criteria]
function search_groups {

    usage="USAGE: search_groups  [search_criteria]"
    search_args=
    if [ ! -z "$1" ]
    then
        search_args="--data-urlencode groupPattern=$1"
    fi

    response_hdr="search-groups-response-header.tmp"
    response_msg="search-groups-response-message.json.tmp"
    config=$(get_curl_config) 
    SERVER=`cat $HPC_DM_TEST/utils/server`
   
    curl  -G ${SERVER}/group $search_args  $config -H "Accept: application/json" -D $response_hdr -o $response_msg -s 2> curl-status
    check_connection $response_hdr
}


#Update an existing  group
#Inputs: registration-input.json 
#      : group-name
#      : response-header
#      : response-msg
function update_group {

    USAGE="update_group  <input.json> <group-name> <response-header> <response-msg>"

    if [ "$#" -lt 4 ] 
    then
        echo "ERROR: using update_group" >&2
        echo "$USAGE" >&2
        exit 1
    fi

    INPUT_FILE="$1"
    GROUP_NAME="$2"
    RESPONSE_HEADER="$3"
    RESPONSE_MSG="$4"

    SERVER=`cat $HPC_DM_TEST/utils/server`
    CONFIG=$(get_curl_config)
    curl -H "Content-Type: application/json" -d @"$INPUT_FILE" -X POST ${SERVER}/group/$GROUP_NAME  $(get_curl_config)  -H "Accept: application/json" -D $RESPONSE_HEADER -o $RESPONSE_MSG -s 2> curl-status
    check_connection $RESPONSE_HEADER

}





#Register a new group
#Inputs: registration-input.json 
#      : group-name
#      : response-header
#      : response-msg
function register_group {

    USAGE="register_group  <input.json> <group-name> <response-header> <response-msg>"

    if [ "$#" -lt 4 ] 
    then
        echo "ERROR: using register_group" >&2
        echo "Got: $@" >&2
        echo "$USAGE" >&2
        exit 1
    fi

    INPUT_FILE="$1"
    GROUP_NAME="$2"
    RESPONSE_HEADER="$3"
    RESPONSE_MSG="$4"
    CONFIG=$(get_curl_config) 


    SERVER=`cat $HPC_DM_TEST/utils/server`


    curl -H "Content-Type: application/json" -d @"$INPUT_FILE" -X PUT ${SERVER}/group/"$GROUP_NAME"  $CONFIG  -H "Accept: application/json" -D $RESPONSE_HEADER -o $RESPONSE_MSG -s 2> curl-status

    check_connection $RESPONSE_HEADER

}

#Create a new group from template
#Arguments:   [group-name] 
function register_group_from_template {


    if [ -z "$1" ]
    then 
        sleep 1
        SUFFIX=`date +"%b-%d-%G-%H-%M-%S"`
        NEW_GROUP=group-$SUFFIX
    else
        NEW_GROUP="$1"
    fi 

    INPUT_TEMPLATE=$HPC_DM_TEST/utils/templates/register-new-group-template.json
    
    ADDED_GROUP=$(echo "$INPUT_TEMPLATE" | sed "s/dxtest-group/$NEW_GROUP/")

    cp $INPUT_TEMPLATE input.json.tmp
    echo "$NEW_GROUP" > new-group-id.tmp

    RESPONSE_MSG=group-registration-response-message.json.tmp
    RESPONSE_HEADER=group-registration-response-header.tmp
    register_group  "input.json.tmp" "$NEW_GROUP" "$RESPONSE_HEADER" "$RESPONSE_MSG"
}

#Add user to group
#Inputs: groupID
#      : userID 
function add_user_to_group {

    if [ -z "$1" ] || [ -z "$2" ]
    then
        echo "ERROR: using add_user_to_group"
        echo "USAGE: add_user_to_group  <group-id> <user-id>"
        exit
    fi

    GROUP_ID="$1"
    USER_ID="$2"

    INPUT_TEMPLATE=$(cat $HPC_DM_TEST/utils/templates/add-user-to-group-template.json)
    ADDED_USER=$(echo "$INPUT_TEMPLATE" | sed "s/dxtest-new-user/$USER_ID/")

    echo "$ADDED_USER" > input.json.tmp

    RESPONSE_MSG=group-update-response-message.json.tmp
    RESPONSE_HEADER=group-update-response-header.tmp

    update_group "input.json.tmp" "$GROUP_ID" "$RESPONSE_HEADER" "$RESPONSE_MSG"
}


#Remove user from group
#Inputs: groupID
#      : userID 
function remove_user_from_group {

    if [ -z "$1" ] || [ -z "$2" ]
    then
        echo "ERROR: using remove_user_to_group"
        echo "USAGE: remove_user_to_group  <group-id> <user-id>"
        exit
    fi

    GROUP_ID="$1"
    USER_ID="$2"

    INPUT_TEMPLATE=$(cat $HPC_DM_TEST/utils/templates/remove-user-from-group-template.json)
    REMOVED_USER=$(echo "$INPUT_TEMPLATE" | sed "s/dxtest-new-user/$USER_ID/")

    echo "$REMOVED_USER" > input.json.tmp

    RESPONSE_MSG=group-update-response-message.json.tmp
    RESPONSE_HEADER=group-update-response-header.tmp

    update_group "input.json.tmp" "$GROUP_ID" "$RESPONSE_HEADER" "$RESPONSE_MSG"
}



#Register a new user and a group from template:
function register_user_and_group {


    register_user_from_template
    register_group_from_template

    if ! [ -e new-user-id.tmp ] 
    then
        echo "ERROR: The file new-user.id-tmp does not exist"
        exit 1
    fi

 
    if ! [ -e new-group-id.tmp ] 
    then
        echo "ERROR: The file new-user.id-tmp does not exist"
        exit 1
    fi

    NEW_USER=$(cat new-user-id.tmp )
    NEW_GROUP=$(cat new-group-id.tmp)

    add_user_to_group  "$NEW_GROUP" "$NEW_USER"

}


#Register a new collection user using the project tempalte
#Input: collection-path
function register_collection_from_template {

    if [ -z "$1" ] 
    then
        echo "ERROR: using register_collection_from_template"
        echo "USAGE: register_collection_from_template  <project-path>"
        exit
    fi

    PROJECT_PATH="$1"
    TEMPLATE=$HPC_DM_TEST/utils/templates/register-project-template.json

    curl_register "$TEMPLATE" "$PROJECT_PATH" collection

}



#Register a new dataObject asynchronously using a template 
#Input: <collection-path> "The parent collection for the dataObject"
#Input: [dataObject-path] "the path for the object to replace fileId" 
function register_dataobject_async_from_template {

    if [ -z "$1" ] 
    then
        echo "ERROR: using register_dataobject_async_from_template"
        echo "USAGE: register_dataobject_async_from_template  <collection-path>"
        exit
    fi

    if ! [ -z "$2" ] 
    then
        FILE_ID="$2"
    else 
        FILE_ID="test.txt"
    fi

    COLLECTION_PATH="$1"
    sleep 1
    SUFFIX=`date +"%b-%d-%G-%H-%M-%S"`
    DATAOBJECT_PATH="${COLLECTION_PATH}/object-${SUFFIX}.txt"
    echo "$DATAOBJECT_PATH" > registered-data-object-path.tmp


    TEMPLATE=$HPC_DM_TEST/utils/templates/register-dataobject-template.json

    #update the endpoint
    update_uid $TEMPLATE input.json.tmp

    #update the fileId    
    INPUT=$(cat input.json.tmp | sed "s/test\.txt/$FILE_ID/")
    echo "$INPUT" > input.json.tmp

    curl_register input.json.tmp  "$DATAOBJECT_PATH" dataObject 
}


#Register a new dataObject synchronously using a template 
#Input: <collection-path> "The parent collection for the dataObject"
#Input: [object-name] "The name of the dataObject"
function register_dataobject_sync_from_template {

    USAGE="USAGE: register_dataobject_sync_from_template  <collection-path> [object-name]"

    if [ -z "$1" ] 
    then
        echo "ERROR: using register_dataobject_sync_from_template"
        echo "$USAGE"
        exit
    fi

    if [ ! -z "$2" ] 
    then
        OBJECT_NAME="$2" 
    else 
        sleep 1
        SUFFIX=`date +"%b-%d-%G-%H-%M-%S"`
        OBJECT_NAME="object-${SUFFIX}.txt"
    fi


    COLLECTION_PATH="$1"
    SUFFIX=`date +"%b-%d-%G-%H-%M-%S"`
    DATAOBJECT_PATH="${COLLECTION_PATH}/${OBJECT_NAME}"
    echo "$DATAOBJECT_PATH" > registered-data-object-path.tmp

    TEMPLATE=$HPC_DM_TEST/utils/templates/upload-input-template.json
    update_uid $TEMPLATE input.json.tmp

    OBJECT_FILE="test-object.tmp"
    echo "test file" > $OBJECT_FILE 
    curl_register input.json.tmp  "$DATAOBJECT_PATH" dataObject "$OBJECT_FILE" 


}

#Register a new dataObject synchronously using a template 
#Input: <collection-path> "The parent collection for the dataObject"
#Input: [object-name] "The name of the dataObject"
function register_dataobject_sync_presignurl {

    USAGE="USAGE: register_dataobject_sync_presignurl  <collection-path> [object-name]"

    if [ -z "$1" ] 
    then
        echo "ERROR: using register_dataobject_sync_from_template"
        echo "$USAGE"
        exit
    fi

    if [ ! -z "$2" ] 
    then
        OBJECT_NAME="$2" 
    else 
        sleep 1
        SUFFIX=`date +"%b-%d-%G-%H-%M-%S"`
        OBJECT_NAME="object-${SUFFIX}.txt"
    fi


    COLLECTION_PATH="$1"
    SUFFIX=`date +"%b-%d-%G-%H-%M-%S"`
    DATAOBJECT_PATH="${COLLECTION_PATH}/${OBJECT_NAME}"
    echo "$DATAOBJECT_PATH" > registered-data-object-path.tmp

    TEMPLATE=$HPC_DM_TEST/utils/templates/upload-input-presigned-template.json
    update_uid $TEMPLATE input.json.tmp

    OBJECT_FILE="test-object.tmp"
    echo "test file" > $OBJECT_FILE 
    PRESIGNED="preSigned"
    curl_register input.json.tmp  "$DATAOBJECT_PATH" "$PRESIGNED"
    verify_registration preSigned-registration-response-header.tmp
    response_msg=preSigned-registration-response-message.json.tmp
    PRESIGNED_URL=`get_json_value $response_msg uploadRequestURL`
    fileName="test-object.tmp"
    RESPONSE_HEADER=presignedURL-registration-response-header.tmp
    RESPONSE_MSG=presignedURL-registration-response-message.tmp
    curl -i -X PUT -F 'Content-Type=application/octet-stream' -F "file=@${fileName}" "${PRESIGNED_URL}" -D $RESPONSE_HEADER -o $RESPONSE_MSG -s
    verify_registration presignedURL-registration-response-header.tmp
}

#Download a dataObject synchronously 
#Input: dataObject-path 
#Options: -p Use presigned URL
function download_dataobject_sync {

    usage="${FUNCNAME} [-p] [-f file_name] dataObject_path"

    presigned=false
    filename_provided=false
    local OPTIND
    while getopts ":f:p" option
    do
      case "${option}" in 
        f)
          file_name_provided=true
          download_file_name="${OPTARG}"
          ;;
        p)
          presigned=true
          ;;
        *)
          echo "ERROR: Unsupported option ${option}" >&2
          echo "$usage" >&2
          exit 1
          ;;
      esac
    done

    shift $(( OPTIND-1 ))
    if [ -z "$1" ] 
    then
        echo "ERROR: using ${FUNCNAME}" >&2
        echo "$usage" >&2
        exit 1
    fi

    if [ -z $RESPONSE_HEADER ] 
    then
        RESPONSE_HEADER=download-dataobject-response-header.tmp
    fi

    if [ -z $RESPONSE_MSG ] 
    then
        RESPONSE_MSG=download-dataobject-response-message.json.tmp
    fi

    if  [ "$presigned" == "false" ] && [ "$file_name_provided" == "true" ]
    then
      RESPONSE_MSG=$download_file_name
    fi


    TEMPLATE="$HPC_DM_TEST/utils/templates/download-sync-template.json"
    download_request=download-request.json.tmp
    cat "$TEMPLATE" | sed "s@generateDownloadRequestURL.*@generateDownloadRequestURL:\"$presigned\"@" >  $download_request
    OBJECT_PATH="$1"
    SERVER=`cat $HPC_DM_TEST/utils/server`
    curl -H "Content-Type: application/json" -d @$download_request -X POST ${SERVER}/dataObject/$OBJECT_PATH/download  $(get_curl_config)  -H "Accept: application/json" -D $RESPONSE_HEADER -o $RESPONSE_MSG -s 2> curl-status 
    check_connection $RESPONSE_HEADER

    #If presigned, then do another curl request 
    http_code=$(get_http_code $RESPONSE_HEADER)
    if [ "$http_code" == "200" ]
    then
      if [ "$presigned" == "true" ]
      then
        presigned_download_url=$(get_json_value $RESPONSE_MSG downloadRequestURL)
        presigned_response_header=presigned_request_header.tmp
        if [ $file_name_provided == "true" ]
        then
          presigned_response_message=$download_file_name
        else
          presigned_response_message=presigned_request_file.tmp
        fi
        curl -X GET  $presigned_download_url -D $presigned_response_header -o $presigned_response_message -s  2> presigned-status.tmp
        check_connection $presigned_response_header
      fi
    fi
}



#Download a dataObject or a collection asynchronously to the default globus endpoint
#Option:  -g: Generate a unique name for download file
#Input: <item-path> 
#Input: [download-template]
function download_async {

    usage="${FUNCNAME} [-g] file_path [download-template]"
    local OPTIND
    while getopts ":g" option
    do
      case "${option}" in 
        g)
          sleep 1 
          SUFFIX=`date +"%b-%d-%G-%H-%M-%S"`
          destination=object-$SUFFIX
          ;;
        *)
          echo "ERROR: Unsupported option ${option}" >&2
          echo "$usage" >&2
          exit 1
          ;;
      esac
    done

    shift $(( OPTIND-1 ))

    if [ "$#" -lt 1 ]
    then
        echo "ERROR: using download_async"
        echo "$usage" >&2
        exit 1
    fi


    if [ -z $RESPONSE_HEADER ] 
    then
        RESPONSE_HEADER=download-response-header.tmp
    fi

    if [ -z $RESPONSE_MSG ] 
    then
        RESPONSE_MSG=download-response-message.json.tmp
    fi

    ITEM_PATH="$1"
    SERVER=`cat $HPC_DM_TEST/utils/server`

    if [ "$ITEM_PATH" != ""  ]
    then
      if [ -z "$destination" ]
      then
        ITEM_NAME=$(basename ${ITEM_PATH})
        ITEM_PATH=/${ITEM_PATH}
      else
        ITEM_NAME=$destination
      fi
    else
      ITEM_NAME=""
    fi
   
    if [ -z "$2" ]
    then 
        TEMPLATE="$HPC_DM_TEST/utils/templates/download-async-template.json"
    else 
        TEMPLATE="$2"
    fi

    TEMP=download-input-temp.json.tmp
    #Update the globus endpoint
    update_uid "$TEMPLATE" "$TEMP"

    #Update the file name 
    INPUT_JSON=$(cat "$TEMP" | sed "s@dxfilename@$ITEM_NAME@")
    echo "$INPUT_JSON" > input.json.tmp

    curl -H "Content-Type: application/json" -d @input.json.tmp -X POST ${SERVER}${ITEM_PATH}/download  --config $HPC_DM_TEST/utils/config  -H "Accept: application/json" -D $RESPONSE_HEADER -o $RESPONSE_MSG -s 2> curl-status 
    check_connection $RESPONSE_HEADER
}


#Get the status of asynchronousl download request 
#Input: <taskId>  a numerical id for the download receipt
#Input: <type> dataObject, collection, or "" for list of dataObjects
function get_download_status_wrapper {

  get_download_status $*
}



#Get the status of asynchronousl download request 
#Input: <taskId>  a numerical id for the download receipt
#Input: <type> dataObject, collection, or "" for list of dataObjects
function get_download_status {

    usage="USAGE: get_download_status <taskId> <type>"
    if [ "$#" -ne 2 ]
    then
        echo "ERROR: using get_download_status"
        echo "Received: $*" >&2
        echo "$usage"  >&2
        exit 1
    fi

    RESPONSE_HEADER=get-download-status-response-header.tmp
    RESPONSE_MSG=get-download-status-response-message.json.tmp

    taskId="$1"
    request_type="$2"
    SERVER=`cat $HPC_DM_TEST/utils/server`

    if [ "$request_type" != "" ]
    then
      #dataObject or collection
      endpoint="${request_type}/download/?taskId=$taskId"
    else 
      endpoint=download/$taskId
    fi
      
    curl -G -X GET $SERVER/$endpoint  --config $HPC_DM_TEST/utils/config  -H "Accept: application/json" -D $RESPONSE_HEADER -o $RESPONSE_MSG  -s 2> curl-status
    check_connection $RESPONSE_HEADER
}




#Subscribe to all the notifications mentioned in the $HPC_DM_TEST/utils/templates/notifications-template.json
#Inputs: notification_file 
function subscribe_to_notifications {


    if [ -z "$1" ] 
    then
        echo "ERROR: using subscribe_to_notifications"
        echo "USAGE: subscribe_to_notifications <notification_file>"
        exit
    fi

    INPUT_FILE="$1"

    if ! [ -e "$INPUT_FILE" ]  
    then
        echo "ERROR the input file \"$INPUT_FILE\" does not exist."
        exit
    fi

    if [ -z $RESPONSE_HEADER ] 
    then
        RESPONSE_HEADER=subscribe-notifications-response-header.tmp
    fi

    if [ -z $RESPONSE_MSG ] 
    then
        RESPONSE_MSG=subscribe-notifications-response-message.json.tmp
    fi

    NOTIFICATION_INPUT=dxdice-notification-input.json.tmp  
    cp $INPUT_FILE $NOTIFICATION_INPUT 

    SERVER=`cat $HPC_DM_TEST/utils/server`

    curl -H "Content-Type: application/json" -d @$NOTIFICATION_INPUT -X POST ${SERVER}/notification  $(get_curl_config)  -H "Accept: application/json" -D $RESPONSE_HEADER -o $RESPONSE_MSG -s 2> curl-status 

    check_connection $RESPONSE_HEADER
}

#Get the notifications for a particular user
function get_notifications {

    if [ -z $RESPONSE_HEADER ] 
    then
        RESPONSE_HEADER=subscribe-notifications-response-header.tmp
    fi

    if [ -z $RESPONSE_MSG ] 
    then
        RESPONSE_MSG=subscribe-notifications-response-message.json.tmp
    fi

    SERVER=`cat $HPC_DM_TEST/utils/server`

    curl -G -X GET $SERVER/notification $(get_curl_config)  -D $RESPONSE_HEADER -o $RESPONSE_MSG -s 2> curl-status 

    check_connection $RESPONSE_HEADER
}


#Get the notifications receipts for a particular user
function get_notification_receipts {

    if [ -z $RESPONSE_HEADER ] 
    then
        #RESPONSE_HEADER=get-notifications-response-header.tmp 
        RESPONSE_HEADER=get-delived-notifications-response-header.tmp 
    fi

    if [ -z $RESPONSE_MSG ] 
    then
        #RESPONSE_MSG=get-notifications-response-message.json.tmp
        RESPONSE_MSG=get-delivered-notifications-response-message.json.tmp
    fi

    SERVER=`cat $HPC_DM_TEST/utils/server`


    curl -G -X GET $SERVER/notification/deliveryReceipts?totalCount=true $(get_curl_config) -D $RESPONSE_HEADER -o $RESPONSE_MSG -s 2> curl-status 

    check_connection $RESPONSE_HEADER
}




#Get the metadata attributes for a user 
function get_metadata_attributes {

    if [ -z $RESPONSE_HEADER ] 
    then
        RESPONSE_HEADER=metatadata-attributes-response-header.tmp
    fi

    if [ -z $RESPONSE_MSG ] 
    then
        RESPONSE_MSG=metadata-attributes-response-message.json.tmp
    fi

    SERVER=`cat $HPC_DM_TEST/utils/server`


    curl -G -X GET $SERVER/metadataAttributes --config $HPC_DM_TEST/utils/config   -D $RESPONSE_HEADER -o $RESPONSE_MSG -s 2> curl-status 
    check_connection $RESPONSE_HEADER
}



#Get the delivered notifications for a user 
#Parameters:
#           [page] The page number for the notifications
#           [totalcount] The page number for the notifications
function get_delivered_notifications {
    
    USAGE="USAGE: get_delivered_notificationn <page> <totalcount>"

    if [-z "$1" ]
    then
        echo "ERROR: missing the page parameter." >&2
        echo "$USAGE" >&2
        exit
    fi

    if [-z "$2" ]
    then
        echo "ERROR: missing the totalcount parameter." >&2
        echo "$USAGE" >&2
        exit
    fi

    PAGE="$1"
    TOTAL_COUNT="$2"
    if [ -z $RESPONSE_HEADER ] 
    then
        RESPONSE_HEADER=delivered-notifications-response-header.tmp
    fi

    if [ -z $RESPONSE_MSG ] 
    then
        RESPONSE_MSG=delivered-notifications-response-message.json.tmp
    fi

    USERID=`get_username $HPC_DM_TEST/utils/config`
    SERVER=`cat $HPC_DM_TEST/utils/server`

    echo "curl -G -X GET $SERVER/notification/deliveryReceipts?page=$PAGE&totalcount --config $HPC_DM_TEST/utils/config   -D $RESPONSE_HEADER -o $RESPONSE_MSG -s 2> curl-status"

    check_connection $RESPONSE_HEADER
}




#search  for a collection or an object by metadata
# Arguments :<type> Either collection or dataObject
#           :<query> The .json query file
#           :[user] The user to submit the query  
function search_by_metadata {
    if [ -z "$1" ] || [ -z "$2" ]
    then 
        echo "ERROR: using search_by_metadata"
        echo "USAGE: search_by_metadata <type> <query>"     
        exit
    fi

    TYPE="$1"
    QUERY="$2"

    if [ -z "$3" ]
    then
        CONFIG="--config $HPC_DM_TEST/utils/config"
    else
        USER=$3
        #TODO: note -k is not required, this is a random password
        CONFIG="-k -u ${USER}:password"
    fi

    if [ "$TYPE" != "collection" ] && [ "$TYPE" != "dataObject" ]
    then
        echo "ERROR: type shoube be either collection or dataObject"
        exit
    fi

    if [ ! -e "$QUERY" ]
    then
        echo "ERROR: the query file $QUERY does not exist"
        exit
    fi


    if [ -z "$RESPONSE_HEADER" ]
    then
        RESPONSE_HEADER=search-response-header.tmp
    fi


    if [ -z "$RESPONSE_MSG" ]
    then
        RESPONSE_MSG=search-response-msg.json.tmp
    fi

    SERVER=`cat $HPC_DM_TEST/utils/server`
    #CONFIG=$HPC_DM_TEST/utils/config 

    curl -G -X GET $SERVER/$TYPE?detailedResponse=true --data-urlencode metadataQuery@$QUERY $CONFIG   -D $RESPONSE_HEADER -o $RESPONSE_MSG -s 2> curl-status 

    check_connection $RESPONSE_HEADER
}


# query a collection or an object by metadata
# using the compound search API
# Arguments :<type> Either collection or dataObject
#           :<query> The .json query file
#           :[user] The user to submit the query  
function query_by_metadata {
    if [ -z "$1" ] || [ -z "$2" ]
    then 
        echo "ERROR: using query_by_metadata"
        echo "USAGE: query_by_metadata <type> <query> [user]"     
        exit
    fi

    TYPE="$1"
    QUERY="$2"

    if [ -z "$3" ]
    then
        CONFIG="--config $HPC_DM_TEST/utils/config"
    else
        USER=$3
        #if the passed user is the same as the user in config, use config, otherwise, use a different user  
        CONFIG_USER=$(get_username)
        if [ "$USER"  = "$CONFIG_USER" ]
        then
            CONFIG="--config $HPC_DM_TEST/utils/config"
        else
            #TODO: note -k is not required, this is a random password
            CONFIG="-k -u ${USER}:password"
        fi
    fi

    if [ "$TYPE" != "collection" ] && [ "$TYPE" != "dataObject" ]
    then
        echo "ERROR: type shoube be either collection or dataObject"
        exit
    fi

    if [ ! -e "$QUERY" ]
    then
        echo "ERROR: the query file $QUERY does not exist"
        exit
    fi

    if [ -z "$RESPONSE_HEADER" ]
    then
        RESPONSE_HEADER=search-response-header.tmp
    fi

    if [ -z "$RESPONSE_MSG" ]
    then
        RESPONSE_MSG=search-response-msg.json.tmp
    fi

    SERVER=`cat $HPC_DM_TEST/utils/server`
    #CONFIG=$HPC_DM_TEST/utils/config 

    curl -H "Content-Type: application/json" -d @"$QUERY" -X POST $SERVER/$TYPE/query $CONFIG  -H "Accept: application/json" -D $RESPONSE_HEADER -o $RESPONSE_MSG -s 2> curl-status 

    check_connection $RESPONSE_HEADER
}



# query a collection or an object by save query 
# Arguments :<type> Either collection or dataObject
#           :<query-name> 
function query_by_saved_name {
    if [ -z "$1" ] || [ -z "$2" ]
    then 
        echo "ERROR: using query_by_saved_name"
        echo "USAGE: query_by_saved_name <type> <query-name>"     
        exit
    fi

    TYPE="$1"
    QUERY="$2"

    CONFIG="--config $HPC_DM_TEST/utils/config"
        
    if [ "$TYPE" != "collection" ] && [ "$TYPE" != "dataObject" ]
    then
        echo "ERROR: type shoube be either collection or dataObject"
        exit
    fi

    RESPONSE_HEADER=query-response-header.tmp
    RESPONSE_MSG=query-response-msg.json.tmp

    SERVER=`cat $HPC_DM_TEST/utils/server`

    curl -X GET $SERVER/$TYPE/query/$QUERY $CONFIG  -H "Accept: application/json" -D $RESPONSE_HEADER -o $RESPONSE_MSG -s 2> curl-status 

    check_connection $RESPONSE_HEADER
}




# save a query
#           :<query> The .json query file
#           :<query-name> The query name 
function save_query {

    if [ -z "$1" ]  || [ -z "$2" ]
    then 
        echo "ERROR: using save_query"
        echo "USAGE: save_query <query> <query-name>"      
        exit
    fi

    QUERY="$1"
    QUERY_NAME="$2"

    if [ ! -e "$QUERY" ]
    then
        echo "ERROR: the query file $QUERY does not exist"
        exit
    fi

    if [ -z "$RESPONSE_HEADER" ]
    then
        RESPONSE_HEADER=save-query-response-header.tmp
    fi

    if [ -z "$RESPONSE_MSG" ]
    then
        RESPONSE_MSG=save-query-response-msg.json.tmp
    fi

    SERVER=`cat $HPC_DM_TEST/utils/server`
    CONFIG="--config $HPC_DM_TEST/utils/config"

    curl -H "Content-Type: application/json" -d @"$QUERY" -X POST $SERVER/query/$QUERY_NAME $CONFIG  -H "Accept: application/json" -D $RESPONSE_HEADER -o $RESPONSE_MSG -s 2> curl-status 
    check_connection $RESPONSE_HEADER
}

# Get search queries
#         
#        
function get_queries {

    if [ -z "$RESPONSE_HEADER" ]
    then
        RESPONSE_HEADER=get-query-response-header.tmp
    fi

    if [ -z "$RESPONSE_MSG" ]
    then
        RESPONSE_MSG=get-query-response-msg.json.tmp
    fi

    SERVER=`cat $HPC_DM_TEST/utils/server`
    CONFIG="--config $HPC_DM_TEST/utils/config"

    curl  -X GET $SERVER/query $CONFIG  -H "Accept: application/json" -D $RESPONSE_HEADER -o $RESPONSE_MSG -s 2> curl-status 
    check_connection $RESPONSE_HEADER
}

#Subscribe to notifications using template
function subscribe_to_template_notifications {

    SUBSCRIPTION_TEMPLATE=$HPC_DM_TEST/utils/templates/notifications_template.json
    NOTIFICATIONS=subscribe-notification_input.json.tmp
    #Edit the base path 
    BASE_PATH=$(get_basefolder)
    cat $SUBSCRIPTION_TEMPLATE  | sed "s/DXBASEFOLDER/$BASE_PATH/" > $NOTIFICATIONS
    subscribe_to_notifications  $NOTIFICATIONS
}

#Unsubscribe to notifications using template
function unsubscribe_to_template_notifications {

    UNSUBSCRIPTION_TEMPLATE=$HPC_DM_TEST/utils/templates/delete-notification-template.json
    cp $UNSUBSCRIPTION_TEMPLATE unsubscribe-notification_input.json.tmp
    subscribe_to_notifications  unsubscribe-notification_input.json.tmp 
}


#Get an item (collection or dataObject) from the archive
#Inputs: <item-path> (should have a prefix of "dataObject" or "collection:)
#      : <response-header-filename>
#      : <response-message-filename>
#      : [user]  The user who should get the item
function get_item {

    if [ -z "$1" ] || [ -z "$2" ] || [ -z "$3" ]
    then
        echo "ERROR: using get_item"
        echo "USAGE: get_item  <item-path> <response-header-filename> <response-message-filename>"
        exit
    fi

    if [ -z "$4" ]
    then
        CONFIG="--config $HPC_DM_TEST/utils/config"
    else
        USER="$4"
        #if the passed user is the same as the user in config, use config, otherwise, use a different user  
        CONFIG_USER=$(get_username)
        if [ "$USER"  = "$CONFIG_USER" ]
        then
            CONFIG="--config $HPC_DM_TEST/utils/config"
        else
            #TODO: note -k is not required, this is a random password
            CONFIG="-k -u ${USER}:password"
        fi
    fi


    ITEM_PATH="$1"
    RESPONSE_HEADER="$2"
    RESPONSE_MSG="$3"
    SERVER=`cat $HPC_DM_TEST/utils/server`

    TOTAL_PATH="$ITEM_PATH"
    TOTAL_PATH=$(echo "$TOTAL_PATH" | sed "s#\/\/*#\/#g")
   
    #echo curl -G -X GET "$SERVER/$TOTAL_PATH"  $CONFIG  -D $RESPONSE_HEADER -o $RESPONSE_MSG -s 2> curl-status 
    curl -G -X GET "$SERVER/$TOTAL_PATH"  $CONFIG  -D $RESPONSE_HEADER -o $RESPONSE_MSG -s 2> curl-status 
    check_connection $RESPONSE_HEADER
}

#Get a permisson on an item (collection or dataObject) from the archive
#Inputs: <item-path> (should have a prefix of "dataObject" or "collection:)
function get_permission {

    if [ -z "$1" ] 
    then
        echo "ERROR: using get_permission"
        echo "USAGE: get_permission  <item-path>"
        exit 1
    fi

    CONFIG=$(get_curl_config) 
    ITEM_PATH="$1"

    if [[ "$ITEM_PATH" != "dataObject"* ]] && [[ "$ITEM_PATH" !=  "collection"* ]]
    then 
        echo "ERROR: get_permission" >&2
        echo "PATH \"$ITEM_PATH\" does not contain the prefix \"collection\" or \"dataObject\"" >&2
        exit 1
    fi


    RESPONSE_HEADER=get-permission-response-header.tmp
    RESPONSE_MSG=get-permission-response-message.json.tmp
    SERVER=`cat $HPC_DM_TEST/utils/server`

    curl -X GET "$SERVER/$ITEM_PATH"/acl  $CONFIG -H "Accept: application/json" -D $RESPONSE_HEADER -o $RESPONSE_MSG -s 2> curl-status 
    check_connection $RESPONSE_HEADER
}


#Get a permisson on multiple collections from the archive
#Inputs: <item-path> (should have a prefix of "dataObject" or "collection:)
function get_permission_multiple {

    if [ -z "$1" ] 
    then
        echo "ERROR: using get_permission_multiple"
        echo "USAGE: get_permission_multiple  <item-path>"
        exit 1
    fi

    CONFIG=$(get_curl_config) 
    ITEM_PATH="$1"

    if [[ "$ITEM_PATH" !=  "collection"* ]]
    then 
        echo "ERROR: get_permission" >&2
        echo "PATH \"$ITEM_PATH\" does not contain the prefix \"collection\"" >&2
        exit 1
    fi


    RESPONSE_HEADER=get-permission-multiple-response-header.tmp
    RESPONSE_MSG=get-permission-multiple-response-message.json.tmp
    SERVER=`cat $HPC_DM_TEST/utils/server`

    curl -X GET "$SERVER/$ITEM_PATH"  $CONFIG -H "Accept: application/json" -D $RESPONSE_HEADER -o $RESPONSE_MSG -s 2> curl-status 
    check_connection $RESPONSE_HEADER
}


#Update the premission using an input json file
#Inputs: <premission-file> The file that describes the premission
#        <path> The path of the collection or dataObject (should include the type as prefix)
#        [response-header] The file where the response header will be written
#        [response-message] The file where the response message will be witten
# If the variable ACTING_USER is set, this will be used as the acting user 

function update_permission {

    USAGE="USAGE: update_group_permission <permission-file> <[dataObjecg|collection]path>[response-header-file] [response-message-file]"

    if [ "$#" -lt 2 ]
    then
        echo "ERROR: using update_permission" >&2
        echo "$USAGE" >&2
        exit
    fi

    PERMISSION_FILE="$1"
    ITEM_PATH="$2"

    #Make sure the path include collection or dataObject
    if [[ "$ITEM_PATH" != "dataObject"* ]] && [[ "$ITEM_PATH" !=  "collection"* ]]
    then 
        echo "ERROR: update permission" >&2
        echo "PATH \"$ITEM_PATH\" does not contain the prefix \"collection\" or \"dataObject\"" >&2
        exit 1
    fi

    if [ -z "$3" ]
    then
        RESPONSE_HEADER="permission-response-header.tmp"
    else
        RESPONSE_HEADER="$3"
    fi

    if [ -z "$4" ]
    then
        RESPONSE_MSG="permission-response-message.json.tmp"
    else    
        RESPONSE_MSG="$4"
    fi
        
    CONFIG=$(get_curl_config) 
    SERVER=`cat $HPC_DM_TEST/utils/server`
    curl -H "Content-Type: application/json" -d @$PERMISSION_FILE -X POST ${SERVER}/$ITEM_PATH/acl  $CONFIG  -H "Accept: application/json" -D $RESPONSE_HEADER -o $RESPONSE_MSG -s 2> curl-status 
    check_connection $RESPONSE_HEADER
}


#Update the user permission of a single path using a template
#Inputs: <path>         The path for the collection or the dataObject where the permission should be updated 
#        <group_id>      The group to be granted the new permission
#        <permission>   The new permission that should be given  
# If the variable ACTING_USER is set, this will be used as the acting user 


function update_group_permission {

     
    USAGE="ERROR: using update_group_permission.\nUSAGE: update_group_permission <path> <group_id> <permission>"

    if [ -z "$1" ]
    then    
        echo "Missing path" >&2
        echo "$USAGE"  1>&2
        exit

    fi

    if [ -z "$2" ]
    then

        echo "Missing user_id" >&2
        echo "$USAGE" >&2
        exit

    fi

    if [ -z "$3" ]
    then

        echo "Missing permission" >&2
        echo "$USAGE" >&2
        exit

    fi
   
    PERMISSION_PATH="$1"
    GROUP_ID="$2"
    NEW_PERMISSION="$3"
       
    UPDATED_GROUP=$(cat $HPC_DM_TEST/utils/templates/group-permission-update-template.json | sed "s#dxgroupid#$GROUP_ID#")
    UPDATED_PERMISSION=$(echo "$UPDATED_GROUP" | sed "s#dxnewpermission#$NEW_PERMISSION#")
    echo "$UPDATED_PERMISSION" > group-permission.json.tmp
    
    #Submit the request to change permission
    update_permission "group-permission.json.tmp" "$PERMISSION_PATH" 
    
}



#Update the group permission of a single path using a template
#Inputs: <path>         The path for the collection or the dataObject where the permission should be updated 
#        <user_id>      The user to be granted the new permission
#        <permission>   The new permission that should be given  
# If the variable ACTING_USER is set, this will be used as the acting user 


function update_single_permission {

     
    USAGE="ERROR: using update_permission.\nUSAGE: update_single_permission <path> <user_id> <permission>"

    if [ -z "$1" ]
    then    
        echo "Missing path" >&2
        echo "$USAGE"  1>&2
        exit

    fi

    if [ -z "$2" ]
    then

        echo "Missing user_id" >&2
        echo "$USAGE" >&2
        exit

    fi

    if [ -z "$3" ]
    then

        echo "Missing permission" >&2
        echo "$USAGE" >&2
        exit

    fi

   
    PERMISSION_PATH="$1"
    USER_ID="$2"
    NEW_PERMISSION="$3"
       
    #UPDATED_PATH=$(cat $HPC_DM_TEST/utils/templates/permission-update-template.json | sed "s#dxcollectionpath#$PERMISSION_PATH#")
    UPDATED_USER=$(cat $HPC_DM_TEST/utils/templates/permission-update-template.json | sed "s#dxnewuserid#$USER_ID#")
    UPDATED_PERMISSION=$(echo "$UPDATED_USER" | sed "s#dxnewpermission#$NEW_PERMISSION#")
    echo "$UPDATED_PERMISSION" > permission.json.tmp
    
    #Submit the request to change permission
    update_permission "permission.json.tmp" "$PERMISSION_PATH" 
    
}



#Register a query
#Inputs:    <query-name> 
#           <query-file>
#           [PUT-POST] Either register or update
function register_query {

    USAGE="ERROR: using register_query.\nUSAGE: register_query <query-name> <query-file> [PUT-POST]"

    if [ -z "$1" ]
    then    
        echo "Missing query-name" >&2
        echo "$USAGE"  1>&2
        exit

    fi

    if [ -z "$2" ]
    then

        echo "Missing query-file" >&2
        echo "$USAGE" >&2
        exit
    fi

    if [ -z "$3" ]
    then
        METHOD=PUT
    else
        METHOD=$3
    fi

    if [ "$METHOD" != PUT ] && [ "$METHOD" != POST ] 
    then
        echo "ERROR:unsupported method $METHOD" >&2
    fi


    if [ "$METHOD" = PUT ] 
    then
        RESPONSE_HEADER=register-query-response-header.tmp
        RESPONSE_MSG=register-query-response-message.json.tmp
    else
        RESPONSE_HEADER=update-query-response-header.tmp
        RESPONSE_MSG=update-query-response-message.json.tmp
    fi
    
    QUERY_NAME="$1"
    QUERY_PATH="$2"


    if [ ! -f "$QUERY_PATH" ]
    then
        echo "The query file $QUERY_PATH does not exist" >&2
        exit
    fi

    CONFIG="" 
    SERVER=`cat $HPC_DM_TEST/utils/server`


    curl -X $METHOD ${SERVER}/query/"$QUERY_NAME" -H "Content-Type: application/json" -d @$QUERY_PATH --config $HPC_DM_TEST/utils/config -H "Accept: application/json" -D $RESPONSE_HEADER -o $RESPONSE_MSG -s 2> curl-status
    check_connection $RESPONSE_HEADER
}


#Delete a query
#Inputs:    <query-name> 
function delete_query {

    USAGE="ERROR: using delete_query.\nUSAGE: delete_query <query-name> "

    if [ -z "$1" ]
    then    
        echo "Missing query-name" >&2
        echo "$USAGE"  1>&2
        exit

    fi

    QUERY_NAME="$1"

    SERVER=`cat $HPC_DM_TEST/utils/server`

    RESPONSE_HEADER=delete-query-response-header.tmp
    RESPONSE_MSG=delete-query-response-message.json.tmp

    curl -X DELETE ${SERVER}/query/"$QUERY_NAME" --config $HPC_DM_TEST/utils/config -H "Accept: application/json" -D $RESPONSE_HEADER -o $RESPONSE_MSG -s 2> curl-status
    check_connection $RESPONSE_HEADER
}




#Retrieve a saved query
#Inputs:    <query-name> 
function get_query {

    USAGE="ERROR: using get_query.\nUSAGE: get_query <query-name>"

    if [ -z "$1" ]
    then    
        echo "Missing query-name" >&2
        echo "$USAGE"  1>&2
        exit

    fi

    QUERY_NAME="$1"

    SERVER=`cat $HPC_DM_TEST/utils/server`

    RESPONSE_HEADER=get-query-response-header.tmp
    RESPONSE_MSG=get-query-response-message.json.tmp

    curl -X GET ${SERVER}/query/"$QUERY_NAME" --config $HPC_DM_TEST/utils/config -H "Accept: application/json" -D $RESPONSE_HEADER -o $RESPONSE_MSG -s 2> curl-status
    check_connection $RESPONSE_HEADER
}




#Register a query from a template
#Inputs:  [query-id]  
function register_query_from_template {


    if [ -z "$1" ]
    then
        sleep 1
        SUFFIX=`date +"%b-%d-%G-%H-%M-%S"`
        QUERY_ID=queryid-$SUFFIX
    else
        QUERY_ID="$1"
    fi

    QUERY_TEMPLATE=$HPC_DM_TEST/utils/templates/query-template.json

    QUERY_STRING=$(cat $QUERY_TEMPLATE  | sed "s/DXTEST/dxattribute-$QUERY_ID/")
    QUERY_FILE="query.json.tmp"

    echo "$QUERY_STRING"  >  $QUERY_FILE
    register_query "$QUERY_ID" "$QUERY_FILE"
    echo "$QUERY_ID"

}

#Refresh the query metadata view 
#Inputs: None 

function refresh_views {

    SERVER=`cat $HPC_DM_TEST/utils/server`
    RESPONSE_HEADER=refresh-views-response-header.tmp
    RESPONSE_MSG=refresh-views-response-message.json.tmp
    curl -X POST ${SERVER}/refreshMetadataViews  $(get_curl_config)  -H "Accept: application/json" -D $RESPONSE_HEADER -o $RESPONSE_MSG -s 2> curl-status 
    check_connection $RESPONSE_HEADER
}

#Returns the configuration argument for the curl command

function get_curl_config {


    if [ -z "$ACTING_USER" ]
    then
        CONFIG="--config $HPC_DM_TEST/utils/config" 
    else
        CONFIG="-k -u ${ACTING_USER}:password"
    fi 
    
    echo "$CONFIG"
}

#Sleep for a defined period of time before the asynchronous downlaod
#Inputs: [time] in seconds
function async_sleep {

    SLEEP_TIME="$1"
    if [ -z "$1" ]
    then
        SLEEP_TIME=$(get_json_value $HPC_DM_TEST/utils/test-configuration asynchronous-sleep)
    fi

    sleep "$SLEEP_TIME"
}



#Delete an item (collection or dataObject)
#Inputs:    <path> "Should have a prefix of dataObject or collection"
#           <response-header>
#           <response-message>
#           <force_flag>
function delete_item {

    USAGE="ERROR: using $FUNCNAME.\nUSAGE: $FUNCNAME <path> <response-header> <response-message> <force_flag>"


    FORCE_FLAG="true"

    if [ "$#" -lt 3 ] 
    then    
        echo "$USAGE"  >&2
        exit 1

    fi
    if [ ! -z "$4" ]
    then
      FORCE_FLAG="$4"
    fi
       

    ITEM_PATH="$1"
    RESPONSE_HEADER="$2"
    RESPONSE_MSG="$3"

    SERVER=`cat $HPC_DM_TEST/utils/server`
    CONFIG="$(get_curl_config)"

    curl -X DELETE ${SERVER}/$ITEM_PATH?force=$FORCE_FLAG $CONFIG -H "Accept: application/json" -D $RESPONSE_HEADER -o $RESPONSE_MSG -s 2> curl-status
    check_connection $RESPONSE_HEADER
}




#Delete a dataObject 
#Inputs:    <dataObject-path> 
#           <response-header>
#           <response-message>
function delete_dataobject {

    USAGE="ERROR: using $FUNCNAME.\nUSAGE: $FUNCNAME  <path> <response-header> <response-message>"

    if [ "$#" -ne  3 ] 
    then    
        echo "$USAGE"  1>&2
        exit 1

    fi

    DATAOBJECT_PATH=dataObject/"$1"
    RESPONSE_HEADER="$2"
    RESPONSE_MSG="$3"

    delete_item $DATAOBJECT_PATH $RESPONSE_HEADER $RESPONSE_MSG
}


#Delete a collection
#Inputs:    <collection-path> 
#           <response-header>
#           <response-message>
function delete_collection {

    USAGE="ERROR: using $FUNCNAME.\nUSAGE: $FUNCNAME  <path> <response-header> <response-message>"

    if [ "$#" -ne  3 ] 
    then    
        echo "$USAGE"  1>&2
        exit 1

    fi

    COLLECTION_PATH=collection/"$1"
    RESPONSE_HEADER="$2"
    RESPONSE_MSG="$3"

    delete_item $COLLECTION_PATH $RESPONSE_HEADER $RESPONSE_MSG
}



#Check if dataobject is archived
#Inputs:	<dataobject-path>
function check_dataObject_archived { 
    USAGE="ERROR using check_dataObject_archived\nUSAGE: check_dataObject_archived <path>"

    if [ $# -ne 1 ]
    then
        echo "$USAGE" >&2
        exit 1
    fi
}

#Get DOC policies
#Inputs:    <DOC-NAME> 
#           <response-header>
#           <response-message>
function get_doc_policies {

    USAGE="ERROR: using get_doc_policies.\nUSAGE: get_doc_policies <DOC-NAME> <response-header> <response-message>"

    if [ "$#" -ne  3 ] 
    then    
        echo "$USAGE"  1>&2
        exit 1

    fi

    doc="$1"
    RESPONSE_HEADER="$2"
    RESPONSE_MSG="$3"

    SERVER=`cat $HPC_DM_TEST/utils/server`
    CONFIG=$(get_curl_config)

    curl -X GET $SERVER/dm/model/ $CONFIG -H "Accept: application/json" -D "$RESPONSE_HEADER" -o "$RESPONSE_MSG"  -s 2>curl-status
    check_connection $RESPONSE_HEADER
}


#Add bookmark for a path
#Inputs:    <bookmark-name> 
#           <bookmark.json>
#           <response-header>
#           <response-msg>
function add_bookmark {

    USAGE="ERROR: using add_bookmark.\nUSAGE: add_bookmark <bookmark-name> <bookmark.json> <response-header> <response-message>"

    if [ "$#" -ne  4 ] 
    then    
        echo "$USAGE"  1>&2
        exit 1

    fi

    bookmark_name="$1"
    json_file="$2"
    RESPONSE_HEADER="$3"
    RESPONSE_MSG="$4"

    if [ ! -e "$json_file" ]
    then
        echo "ERROR: the bookmark json file:$json_file does not exist." >&2
        exit 1
    fi 

    SERVER=`cat $HPC_DM_TEST/utils/server`
    CONFIG=$(get_curl_config)
    curl -X PUT $SERVER/bookmark/"$bookmark_name" -H "Content-Type: application/json" -d @$json_file $CONFIG -H "Accept: application/json" -D "$RESPONSE_HEADER" -o "$RESPONSE_MSG"  -s 2>curl-status
    check_connection $RESPONSE_HEADER
}


#Add bookmark for a path from template
#Inputs:    <bookmark-path> 
#           <response-header>
#           <response-msg>
function add_bookmark_from_template {

    USAGE="ERROR: using add_bookmark_from_template.\nUSAGE: add_bookmark_from_template <bookmark-path> <response-header> <response-message>"

    if [ "$#" -ne  3 ] 
    then    
        echo "$USAGE"  1>&2
        exit 1

    fi

    bookmark_path="$1"
    response_header="$2"
    response_msg="$3"

    sleep 1
    suffix=`date +"%b-%d-%G-%H-%M-%S"`
    bookmark_name=name-$suffix
    bookmark_group=group-$suffix

    echo $bookmark_name > bookmark-name.tmp
    echo $bookmark_group > bookmark-group.tmp

    template_file=$HPC_DM_TEST/utils/templates/bookmark-template.json
    json_file=bookmark.json.tmp
    new_template=$(cat $template_file | sed "s@dxpath@$bookmark_path@" | sed "s@dxgroup@$bookmark_group@") 
    echo "$new_template" > $json_file

    add_bookmark  "$bookmark_name" "$json_file" "$response_header" "$response_msg"
}

#Update bookmark for a path
#Inputs:    <bookmark-name> 
#           <bookmark-path>
#           <bookmark-group>
#           <response-header>
#           <response-msg>
function update_bookmark {

    USAGE="ERROR: using update_bookmark.\nUSAGE: update_bookmark <bookmark-name> <bookmark-path> <bookmark-group> <response-header> <response-message>"

    if [ "$#" -ne  5 ] 
    then    
        echo "$USAGE"  1>&2
        exit 1

    fi

    bookmark_name="$1"
    bookmark_path="$2"
    bookmark_group="$3"
    RESPONSE_HEADER="$4"
    RESPONSE_MSG="$5"

    template_file=$HPC_DM_TEST/utils/templates/bookmark-template.json
    json_file=bookmark.json.tmp
    new_template=$(cat $template_file | sed "s@dxpath@$bookmark_path@" | sed "s@dxgroup@$bookmark_group@") 
    echo "$new_template" > $json_file

    SERVER=`cat $HPC_DM_TEST/utils/server`
    CONFIG=$(get_curl_config)
    curl -X POST $SERVER/bookmark/"$bookmark_name" -H "Content-Type: application/json" -d @$json_file $CONFIG -H "Accept: application/json" -D "$RESPONSE_HEADER" -o "$RESPONSE_MSG"  -s 2>curl-status
    check_connection $RESPONSE_HEADER
}


#Delete a bookmark 
#Inputs:    <bookmark-name> 
#           <response-header>
#           <response-msg>
function delete_bookmark {

    USAGE="ERROR: using delete_bookmark.\nUSAGE: delete_bookmark <bookmark-name> <response-header> <response-message>"

    if [ "$#" -ne  3 ] 
    then    
        echo "$USAGE"  1>&2
        exit 1

    fi

    bookmark_name="$1"
    RESPONSE_HEADER="$2"
    RESPONSE_MSG="$3"

    SERVER=`cat $HPC_DM_TEST/utils/server`
    CONFIG=$(get_curl_config)
    curl -X DELETE $SERVER/bookmark/"$bookmark_name" $CONFIG -H "Accept: application/json" -D "$RESPONSE_HEADER" -o "$RESPONSE_MSG"  -s 2>curl-status
    check_connection $RESPONSE_HEADER
}

#get the details of a bookmark 
#Inputs:    <bookmark-name> 
#           <response-header>
#           <response-msg>
function get_bookmark {

    USAGE="ERROR: using get_bookmark.\nUSAGE: get_bookmark <bookmark-name> <response-header> <response-message>"

    if [ "$#" -ne  3 ] 
    then    
        echo "$USAGE"  1>&2
        exit 1

    fi

    bookmark_name="$1"
    RESPONSE_HEADER="$2"
    RESPONSE_MSG="$3"

    SERVER=`cat $HPC_DM_TEST/utils/server`
    CONFIG=$(get_curl_config)

    curl -X GET $SERVER/bookmark/"$bookmark_name" $CONFIG -H "Accept: application/json" -D "$RESPONSE_HEADER" -o "$RESPONSE_MSG"  -s 2>curl-status
    check_connection $RESPONSE_HEADER
}



#Get bookmarks for a user 
#           <response-header>
#           <response-msg>
function get_bookmarks {

    USAGE="ERROR: using get_bookmarks.\nUSAGE: get_bookmarks <response-header> <response-message>"

    if [ "$#" -ne  2 ] 
    then    
        echo "$USAGE"  1>&2
        exit 1

    fi

    RESPONSE_HEADER="$1"
    RESPONSE_MSG="$2"

    SERVER=`cat $HPC_DM_TEST/utils/server`
    CONFIG=$(get_curl_config)

    curl -X GET $SERVER/bookmark $CONFIG -H "Accept: application/json" -D "$RESPONSE_HEADER" -o "$RESPONSE_MSG"  -s 2>curl-status
    check_connection $RESPONSE_HEADER
}

function convert_date_to_seconds  {

    usage="convert_date_to_seconds month-day-year hour:minute:seconds"
    if [ $# -ne 1 ]
    then
        echo "$usage" >&2
        exit 1
    fi

    x="$1"
    month=${x:0:2}
    day=${x:3:2}
    year=${x:6:4}
    time=${x:11:9}
    new_string="$year-$month-$day $time"
    date --date="$new_string" +%s
}

#Verifies the download went through and the receipt was correctly generated. 
#Inputs: taskId: The download receipt.
#Inputs: files_paths: The download path on Globus
#Input: type: dataObject, collection, or ""
function verify_globus_download {


  taskID="$1"
  files_paths="$2"
  download_type="$3"

  #Get the status of the download request and verify it is true
  RESPONSE_HEADER=get-download-status-response-header.tmp
  RESPONSE_MSG=get-download-status-response-message.json.tmp
  get_download_status "$taskId" "$download_type" 
  HTTP_CODE=`get_http_code $RESPONSE_HEADER`
  echo "get_status_code $HTTP_CODE"

  #Do not check the file is the code is not 200
  if [ $HTTP_CODE != 200 ] 
  then
    echo "$FUNCNAME: Unable to get download status" >&2
    exit 1
  fi

  #Verify that the download is marked complete on the download status
  status=$(get_json_unquotted_value $RESPONSE_MSG inProgress)
  echo "in_progress:$status"
  mv $RESPONSE_HEADER first-get-status-header.tmp
  mv $RESPONSE_MSG first-get-status-message.tmp


  first=false
  for globus_path in $files_paths
  do
    if [ "$first" == "false" ]
    then
      verify_globus_file  -s 100 $globus_path 
      first=true
    else
      verify_globus_file  -e $globus_path 
    fi 
  done 


  #Sleep 60s and verify the status is updated
  sleep 60 
  RESPONSE_HEADER=get-download-status-response-header.tmp
  RESPONSE_MSG=get-download-status-response-message.json.tmp
  get_download_status "$taskId" "$download_type"

  code=$(get_http_code $RESPONSE_HEADER) 
  if [ "$code" != 200 ]
  then
    echo "ERROR: The second get download status code returned $code" >&2
    exit 1
  fi
  #Verify that the download is marked complete on the download status
  status=$(get_json_unquotted_value $RESPONSE_MSG inProgress)
  echo "in_progress:$status"
}


#Get download requests
#Inputs:    <bookmark-name> 
#           <response-header>
#           <response-msg>
function delete_bookmark {

    USAGE="ERROR: using delete_bookmark.\nUSAGE: delete_bookmark <bookmark-name> <response-header> <response-message>"

    if [ "$#" -ne  3 ] 
    then    
        echo "$USAGE"  1>&2
        exit 1

    fi

    bookmark_name="$1"
    RESPONSE_HEADER="$2"
    RESPONSE_MSG="$3"

    SERVER=`cat $HPC_DM_TEST/utils/server`
    CONFIG=$(get_curl_config)
    curl -X DELETE $SERVER/bookmark/"$bookmark_name" $CONFIG -H "Accept: application/json" -D "$RESPONSE_HEADER" -o "$RESPONSE_MSG"  -s 2>curl-status
    check_connection $RESPONSE_HEADER
}


#Bulk registration for dataObjects from the default Globus endpoint
#inputs:
#     <src-directory>:  The source directory on the globus endpoint
#     <dst-collection>: The destination collection on the Archive
function register_globus_directory {

    usage="$FUNCNAME [-deih] <src-directory> <dst-collection>"
    local OPTIND
    while getopts ":de:i:h" option
    do
      case "${option}" in
        d)
          dry_run=1
          ;;
        e)
          #space separated exclude patterns
          exclude_option=1
          exclude_patterns="${OPTARG}"
          ;;
        i)
          #space separated include patterns
          include_option=1
          include_patterns="${OPTARG}"
          ;;
        h)
          echo "$usage"
          exit 1
          ;;
        *)
          echo "ERROR: Unsoported option ${option}" >&2
          echo "$usage" >&2
          exit 1
          ;;
      esac
    done

    shift $(( OPTIND-1 ))   

    if [ "$#" -lt 2 ]
    then
        echo "ERROR: using ${FUNCNAME}" >&2
        echo "Received $*" >&2
        show_register_globus_directory_usage >&2
        exit 1
    fi

    src_dir="$1"
    dst_dir="$2"

    if [ -z $RESPONSE_HEADER ] 
    then
        RESPONSE_HEADER=register-bulk-globus-response-header.tmp
    fi

    if [ -z $RESPONSE_MSG ] 
    then
        RESPONSE_MSG=register-bulk-globus-response-message.json.tmp
    fi


    #Prepare the request template
    #Set dry run value
    if [ "$dry_run" ]
    then
      dry_run_value=true
    else
      dry_run_value=false
    fi
  
    #Set include patterns
    if [ "$include_option" ]
    then
      include_values="\"includePatterns\":["
      for include_value in "$include_patterns"
      do
        include_values+="\"$include_value\","
      done    
      #Remove the last comma
      include_values=${include_values%?}
      include_values+="],"
    else
      include_values=""
    fi

  
    #Set exclude patterns
    if [ "$exclude_option" ]
    then
      exclude_values="\"excludePatterns\":["
      for exclude_value in "$exclude_patterns"
      do
        exclude_values+="\"$exclude_value\","
      done    
      #Remove the last comma
      exclude_values=${exclude_values%?}
      exclude_values+="],"
    else
      exclude_values=""
    fi

    TEMPLATE=$HPC_DM_TEST/utils/templates/globus-bulk-registration.json
    TEMP=upload-input.json.tmp

    #Update the globus endpoint
    update_uid "$TEMPLATE" "$TEMP"

    #Update the src, dst, include and exclude 
    INPUT_JSON=$(cat $TEMP  \
      | sed "s@dx_src_dir@$src_dir@" \
      | sed "s@dx_dst_dir@$dst_dir@" \
      | sed "s@dx_dry_run_value@$dry_run_value@" \
      | sed "s@dx_include_patterns@$include_values@" \
      | sed "s@dx_exclude_patterns@$exclude_values@")

    echo "$INPUT_JSON" > input.json.tmp

    SERVER=`cat $HPC_DM_TEST/utils/server`
    curl -X PUT -H "Content-Type: application/json" -d @input.json.tmp ${SERVER}/registration  $(get_curl_config)  -H "Accept: application/json" -D $RESPONSE_HEADER -o $RESPONSE_MSG -s 2> curl-status 
    check_connection $RESPONSE_HEADER
}



#Move collection or dataObject
#Inputs 

function move {

    usage="USAGE: move <move-template.json> <response-header> <response-message>"

    nargs=$#
    if [ "$nargs" -ne  "3" ]
    then
        echo "ERROR: using move" >&2
        echo "received $nargs arguments." >&2
        echo "$usage" >&2
        exit
    fi

    MOVES="$1"
    RESPONSE_HEADER="$2"
    RESPONSE_MSG="$3"


    if [ ! -e $MOVE ]
    then
        echo "ERROR: The move template file:$MOVE does not exist "
        exit
    fi


    SERVER=`cat $HPC_DM_TEST/utils/server`
    CONFIG="$(get_curl_config)"
    local CURL_FLAGS="-X POST ${SERVER}/move  $CONFIG  -D $RESPONSE_HEADER -o $RESPONSE_MSG "

    curl -H "Content-Type: application/json" -d @$MOVES $CURL_FLAGS 2>curl-status

    check_connection $RESPONSE_HEADER
}



#Check if a file contains a string 
#inputs:
#     <filename>
#     <string>
function verify_contains {

  usage="$FUNCNAME [-r] <filename> <string>"

  local OPTIND
  reverse_check=""
  while getopts ":rh" option
  do
    case "${option}" in
      r)
        #Check if the file does not contain
        reverse_check=1
        ;;
     h)
        echo "usage"
        exit 1
        ;;
      *)
        echo "ERROR: Unsoported option ${option}" >&2
        echo "$usage" >&2
        exit 1
        ;;
    esac
  done

  shift $(( OPTIND-1 ))   

  if [ "$#" -lt 2 ]
  then
    echo "ERROR using $FUNCNAME" >&2
    echo "RECEIVED: $*" >&2
    echo "$usage"  >&2
    exit 1
  fi
    
  
  filename="$1"
  string="$2"

  if [ ! -e "$filename" ]
  then
    echo "$FUNCNAME ERROR: Can not find the file $filename" >&2
    exit 1
  fi

  string_exists=$(grep $string $filename)
  if [ ! "$reverse_check" ]
  then
    if [ -z "$string_exists" ]
    then
      echo "ERROR: Can not find $string in the file $filename" >&2
      exit 1
    fi
  else
    if [ ! -z "$string_exists" ]
    then
      echo "ERROR: the $string exists in the file $filename" >&2
      exit 1
    fi
  fi

}





